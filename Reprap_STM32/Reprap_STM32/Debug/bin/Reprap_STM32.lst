
D:\CooCox\workspace\Reprap_STM32\reprap_stm32/Debug/bin\Reprap_STM32.elf:     file format elf32-littlearm


Disassembly of section .text:

08000000 <g_pfnVectors>:
 8000000:	18 2c 00 20 95 0e 00 08 91 0e 00 08 91 0e 00 08     .,. ............
 8000010:	91 0e 00 08 91 0e 00 08 91 0e 00 08 00 00 00 00     ................
	...
 800002c:	49 48 00 08 91 0e 00 08 00 00 00 00 11 49 00 08     IH...........I..
 800003c:	e1 03 00 08 91 0e 00 08 91 0e 00 08 91 0e 00 08     ................
 800004c:	91 0e 00 08 91 0e 00 08 91 0e 00 08 91 0e 00 08     ................
 800005c:	91 0e 00 08 91 0e 00 08 91 0e 00 08 91 0e 00 08     ................
 800006c:	f1 03 00 08 91 0e 00 08 91 0e 00 08 91 0e 00 08     ................
 800007c:	91 0e 00 08 91 0e 00 08 91 0e 00 08 91 0e 00 08     ................
 800008c:	91 0e 00 08 fd 03 00 08 91 0e 00 08 91 0e 00 08     ................
 800009c:	91 0e 00 08 91 0e 00 08 91 0e 00 08 91 0e 00 08     ................
 80000ac:	91 0e 00 08 09 04 00 08 91 0e 00 08 91 0e 00 08     ................
 80000bc:	91 0e 00 08 91 0e 00 08 91 0e 00 08 91 0e 00 08     ................
 80000cc:	91 0e 00 08 91 0e 00 08 91 0e 00 08 91 0e 00 08     ................
 80000dc:	91 0e 00 08 91 0e 00 08 91 0e 00 08 91 0e 00 08     ................
	...
 8000108:	5f f8 08 f1                                         _...

0800010c <HAL_RCCEx_PeriphCLKConfig>:
  *         manually disable it.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 800010c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000110:	4606      	mov	r6, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
  
  /*------------------------------- RTC/LCD Configuration ------------------------*/ 
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 8000112:	6800      	ldr	r0, [r0, #0]
  *         manually disable it.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8000114:	b082      	sub	sp, #8

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
  
  /*------------------------------- RTC/LCD Configuration ------------------------*/ 
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 8000116:	07c4      	lsls	r4, r0, #31
 8000118:	d417      	bmi.n	800014a <HAL_RCCEx_PeriphCLKConfig+0x3e>
      __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection); 
    }
  }

  /*------------------------------ ADC clock Configuration ------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 800011a:	0783      	lsls	r3, r0, #30
 800011c:	d40d      	bmi.n	800013a <HAL_RCCEx_PeriphCLKConfig+0x2e>

#if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
 || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
 || defined(STM32F105xC) || defined(STM32F107xC)
  /*------------------------------ USB clock Configuration ------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 800011e:	f010 0010 	ands.w	r0, r0, #16
 8000122:	d007      	beq.n	8000134 <HAL_RCCEx_PeriphCLKConfig+0x28>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPLLCLK_DIV(PeriphClkInit->UsbClockSelection));
    
    /* Configure the USB clock source */
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8000124:	493c      	ldr	r1, [pc, #240]	; (8000218 <HAL_RCCEx_PeriphCLKConfig+0x10c>)
 8000126:	68f2      	ldr	r2, [r6, #12]
 8000128:	684b      	ldr	r3, [r1, #4]
  }
#endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */

  return HAL_OK;
 800012a:	2000      	movs	r0, #0
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPLLCLK_DIV(PeriphClkInit->UsbClockSelection));
    
    /* Configure the USB clock source */
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800012c:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8000130:	4313      	orrs	r3, r2
 8000132:	604b      	str	r3, [r1, #4]
  }
#endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */

  return HAL_OK;
}
 8000134:	b002      	add	sp, #8
 8000136:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCPLLCLK_DIV(PeriphClkInit->AdcClockSelection));
    
    /* Configure the ADC clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 800013a:	4937      	ldr	r1, [pc, #220]	; (8000218 <HAL_RCCEx_PeriphCLKConfig+0x10c>)
 800013c:	68b3      	ldr	r3, [r6, #8]
 800013e:	684a      	ldr	r2, [r1, #4]
 8000140:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8000144:	4313      	orrs	r3, r2
 8000146:	604b      	str	r3, [r1, #4]
 8000148:	e7e9      	b.n	800011e <HAL_RCCEx_PeriphCLKConfig+0x12>
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 800014a:	4a33      	ldr	r2, [pc, #204]	; (8000218 <HAL_RCCEx_PeriphCLKConfig+0x10c>)
    
    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR, PWR_CR_DBP);
 800014c:	4b33      	ldr	r3, [pc, #204]	; (800021c <HAL_RCCEx_PeriphCLKConfig+0x110>)
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 800014e:	69d1      	ldr	r1, [r2, #28]
    SET_BIT(PWR->CR, PWR_CR_DBP);
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8000150:	461c      	mov	r4, r3
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8000152:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8000156:	61d1      	str	r1, [r2, #28]
 8000158:	69d2      	ldr	r2, [r2, #28]
 800015a:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 800015e:	9201      	str	r2, [sp, #4]
 8000160:	9a01      	ldr	r2, [sp, #4]
    
    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR, PWR_CR_DBP);
 8000162:	681a      	ldr	r2, [r3, #0]
 8000164:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000168:	601a      	str	r2, [r3, #0]
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 800016a:	f000 f925 	bl	80003b8 <HAL_GetTick>
 800016e:	4605      	mov	r5, r0
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8000170:	e004      	b.n	800017c <HAL_RCCEx_PeriphCLKConfig+0x70>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8000172:	f000 f921 	bl	80003b8 <HAL_GetTick>
 8000176:	1b40      	subs	r0, r0, r5
 8000178:	2864      	cmp	r0, #100	; 0x64
 800017a:	d829      	bhi.n	80001d0 <HAL_RCCEx_PeriphCLKConfig+0xc4>
    SET_BIT(PWR->CR, PWR_CR_DBP);
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 800017c:	6823      	ldr	r3, [r4, #0]
 800017e:	05d8      	lsls	r0, r3, #23
 8000180:	d5f7      	bpl.n	8000172 <HAL_RCCEx_PeriphCLKConfig+0x66>
        return HAL_TIMEOUT;
      }      
    }
      
    /* Reset the Backup domain only if the RTC Clock source selection is modified */ 
    if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
 8000182:	4c25      	ldr	r4, [pc, #148]	; (8000218 <HAL_RCCEx_PeriphCLKConfig+0x10c>)
 8000184:	6873      	ldr	r3, [r6, #4]
 8000186:	6a22      	ldr	r2, [r4, #32]
 8000188:	4053      	eors	r3, r2
 800018a:	f413 7f40 	tst.w	r3, #768	; 0x300
 800018e:	d01d      	beq.n	80001cc <HAL_RCCEx_PeriphCLKConfig+0xc0>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8000190:	6a21      	ldr	r1, [r4, #32]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8000192:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000196:	f421 7540 	bic.w	r5, r1, #768	; 0x300
 800019a:	fa93 f2a3 	rbit	r2, r3
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 800019e:	fab2 f282 	clz	r2, r2
 80001a2:	481f      	ldr	r0, [pc, #124]	; (8000220 <HAL_RCCEx_PeriphCLKConfig+0x114>)
 80001a4:	2701      	movs	r7, #1
 80001a6:	f840 7022 	str.w	r7, [r0, r2, lsl #2]
 80001aa:	fa93 f3a3 	rbit	r3, r3
      __HAL_RCC_BACKUPRESET_RELEASE();
 80001ae:	fab3 f383 	clz	r3, r3
 80001b2:	2200      	movs	r2, #0
      /* Restore the Content of BDCR register */
      RCC->BDCR = temp_reg;

      /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY))
 80001b4:	0789      	lsls	r1, r1, #30
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
      __HAL_RCC_BACKUPRESET_RELEASE();
 80001b6:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
      /* Restore the Content of BDCR register */
      RCC->BDCR = temp_reg;
 80001ba:	6225      	str	r5, [r4, #32]

      /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY))
 80001bc:	d40c      	bmi.n	80001d8 <HAL_RCCEx_PeriphCLKConfig+0xcc>
          {
            return HAL_TIMEOUT;
          }      
        }  
      }
      __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection); 
 80001be:	4916      	ldr	r1, [pc, #88]	; (8000218 <HAL_RCCEx_PeriphCLKConfig+0x10c>)
 80001c0:	6873      	ldr	r3, [r6, #4]
 80001c2:	6a0a      	ldr	r2, [r1, #32]
 80001c4:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 80001c8:	4313      	orrs	r3, r2
 80001ca:	620b      	str	r3, [r1, #32]
 80001cc:	6830      	ldr	r0, [r6, #0]
 80001ce:	e7a4      	b.n	800011a <HAL_RCCEx_PeriphCLKConfig+0xe>
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
      {
        return HAL_TIMEOUT;
 80001d0:	2003      	movs	r0, #3
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
  }
#endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */

  return HAL_OK;
}
 80001d2:	b002      	add	sp, #8
 80001d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

      /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY))
      {
        /* Get timeout */
        tickstart = HAL_GetTick();
 80001d8:	f000 f8ee 	bl	80003b8 <HAL_GetTick>
 80001dc:	f04f 0802 	mov.w	r8, #2
 80001e0:	4607      	mov	r7, r0
      
        /* Wait till LSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80001e2:	f241 3588 	movw	r5, #5000	; 0x1388
      {
        /* Get timeout */
        tickstart = HAL_GetTick();
      
        /* Wait till LSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80001e6:	e00f      	b.n	8000208 <HAL_RCCEx_PeriphCLKConfig+0xfc>
 80001e8:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80001ea:	fa98 f3a8 	rbit	r3, r8
 80001ee:	fab3 f383 	clz	r3, r3
 80001f2:	f003 031f 	and.w	r3, r3, #31
 80001f6:	fa22 f303 	lsr.w	r3, r2, r3
 80001fa:	07da      	lsls	r2, r3, #31
 80001fc:	d4df      	bmi.n	80001be <HAL_RCCEx_PeriphCLKConfig+0xb2>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80001fe:	f000 f8db 	bl	80003b8 <HAL_GetTick>
 8000202:	1bc0      	subs	r0, r0, r7
 8000204:	42a8      	cmp	r0, r5
 8000206:	d8e3      	bhi.n	80001d0 <HAL_RCCEx_PeriphCLKConfig+0xc4>
 8000208:	fa98 f3a8 	rbit	r3, r8
 800020c:	fa98 f3a8 	rbit	r3, r8
      {
        /* Get timeout */
        tickstart = HAL_GetTick();
      
        /* Wait till LSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000210:	2b00      	cmp	r3, #0
 8000212:	d0e9      	beq.n	80001e8 <HAL_RCCEx_PeriphCLKConfig+0xdc>
 8000214:	6a22      	ldr	r2, [r4, #32]
 8000216:	e7e8      	b.n	80001ea <HAL_RCCEx_PeriphCLKConfig+0xde>
 8000218:	40021000 	.word	0x40021000
 800021c:	40007000 	.word	0x40007000
 8000220:	42420400 	.word	0x42420400

08000224 <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg @ref RCC_PERIPHCLK_USB  USB peripheral clock
  @endif
  * @retval Frequency in Hz (0: means that no available frequency for the peripheral)
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
 8000224:	b570      	push	{r4, r5, r6, lr}
 8000226:	4606      	mov	r6, r0
 || defined(STM32F105xC) || defined(STM32F107xC)
#if defined(STM32F105xC) || defined(STM32F107xC)
  const uint8_t aPLLMULFactorTable[12] = {0, 0, 4,  5,  6,  7,  8,  9, 0, 0, 0, 13};
  const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
#else
  const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 16};
 8000228:	4d40      	ldr	r5, [pc, #256]	; (800032c <HAL_RCCEx_GetPeriphCLKFreq+0x108>)
  *            @arg @ref RCC_PERIPHCLK_USB  USB peripheral clock
  @endif
  * @retval Frequency in Hz (0: means that no available frequency for the peripheral)
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
 800022a:	b086      	sub	sp, #24
 || defined(STM32F105xC) || defined(STM32F107xC)
#if defined(STM32F105xC) || defined(STM32F107xC)
  const uint8_t aPLLMULFactorTable[12] = {0, 0, 4,  5,  6,  7,  8,  9, 0, 0, 0, 13};
  const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
#else
  const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 16};
 800022c:	6828      	ldr	r0, [r5, #0]
 800022e:	6869      	ldr	r1, [r5, #4]
 8000230:	68aa      	ldr	r2, [r5, #8]
 8000232:	68eb      	ldr	r3, [r5, #12]
  const uint8_t aPredivFactorTable[2] = { 1, 2};
 8000234:	8a2d      	ldrh	r5, [r5, #16]
 || defined(STM32F105xC) || defined(STM32F107xC)
#if defined(STM32F105xC) || defined(STM32F107xC)
  const uint8_t aPLLMULFactorTable[12] = {0, 0, 4,  5,  6,  7,  8,  9, 0, 0, 0, 13};
  const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
#else
  const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 16};
 8000236:	ac02      	add	r4, sp, #8
#endif /* STM32F105xC || STM32F107xC */

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
  
  switch (PeriphClk)
 8000238:	2e02      	cmp	r6, #2
 || defined(STM32F105xC) || defined(STM32F107xC)
#if defined(STM32F105xC) || defined(STM32F107xC)
  const uint8_t aPLLMULFactorTable[12] = {0, 0, 4,  5,  6,  7,  8,  9, 0, 0, 0, 13};
  const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
#else
  const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 16};
 800023a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  const uint8_t aPredivFactorTable[2] = { 1, 2};
 800023c:	f8ad 5004 	strh.w	r5, [sp, #4]
#endif /* STM32F105xC || STM32F107xC */

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
  
  switch (PeriphClk)
 8000240:	d050      	beq.n	80002e4 <HAL_RCCEx_GetPeriphCLKFreq+0xc0>
 8000242:	2e10      	cmp	r6, #16
 8000244:	d01c      	beq.n	8000280 <HAL_RCCEx_GetPeriphCLKFreq+0x5c>
 8000246:	2e01      	cmp	r6, #1
 8000248:	d002      	beq.n	8000250 <HAL_RCCEx_GetPeriphCLKFreq+0x2c>
        frequency = HSE_VALUE / 128;
      }
      /* Clock not enabled for RTC*/
      else
      {
        frequency = 0;
 800024a:	2000      	movs	r0, #0
    {
      break;
    }
  }
  return(frequency);
}
 800024c:	b006      	add	sp, #24
 800024e:	bd70      	pop	{r4, r5, r6, pc}
    {
      /* Get RCC BDCR configuration ------------------------------------------------------*/
      temp_reg = RCC->BDCR;

      /* Check if LSE is ready if RTC clock selection is LSE */
      if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY)))
 8000250:	f240 3202 	movw	r2, #770	; 0x302
    }
#endif /* STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
  case RCC_PERIPHCLK_RTC:  
    {
      /* Get RCC BDCR configuration ------------------------------------------------------*/
      temp_reg = RCC->BDCR;
 8000254:	4936      	ldr	r1, [pc, #216]	; (8000330 <HAL_RCCEx_GetPeriphCLKFreq+0x10c>)
 8000256:	6a0b      	ldr	r3, [r1, #32]

      /* Check if LSE is ready if RTC clock selection is LSE */
      if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY)))
 8000258:	401a      	ands	r2, r3
 800025a:	f5b2 7f81 	cmp.w	r2, #258	; 0x102
 800025e:	d054      	beq.n	800030a <HAL_RCCEx_GetPeriphCLKFreq+0xe6>
      {
        frequency = LSE_VALUE;
      }
      /* Check if LSI is ready if RTC clock selection is LSI */
      else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
 8000260:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8000264:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8000268:	d057      	beq.n	800031a <HAL_RCCEx_GetPeriphCLKFreq+0xf6>
      {
        frequency = LSI_VALUE;
      }
      else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_HSE_DIV128) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
 800026a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800026e:	d1ec      	bne.n	800024a <HAL_RCCEx_GetPeriphCLKFreq+0x26>
 8000270:	680b      	ldr	r3, [r1, #0]
      {
        frequency = HSE_VALUE / 128;
 8000272:	f24f 4024 	movw	r0, #62500	; 0xf424
 8000276:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800027a:	bf08      	it	eq
 800027c:	2000      	moveq	r0, #0
 800027e:	e7e5      	b.n	800024c <HAL_RCCEx_GetPeriphCLKFreq+0x28>
 || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
 || defined(STM32F105xC) || defined(STM32F107xC)
  case RCC_PERIPHCLK_USB:  
    {
      /* Get RCC configuration ------------------------------------------------------*/
      temp_reg = RCC->CFGR;
 8000280:	492b      	ldr	r1, [pc, #172]	; (8000330 <HAL_RCCEx_GetPeriphCLKFreq+0x10c>)
 8000282:	684c      	ldr	r4, [r1, #4]
  
      /* Check if PLL is enabled */
      if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLLON))
 8000284:	6808      	ldr	r0, [r1, #0]
 8000286:	f010 7080 	ands.w	r0, r0, #16777216	; 0x1000000
 800028a:	d0df      	beq.n	800024c <HAL_RCCEx_GetPeriphCLKFreq+0x28>
 800028c:	f44f 1370 	mov.w	r3, #3932160	; 0x3c0000
 8000290:	fa93 f3a3 	rbit	r3, r3
      {
        pllmul = aPLLMULFactorTable[(uint32_t)(temp_reg & RCC_CFGR_PLLMULL) >> POSITION_VAL(RCC_CFGR_PLLMULL)];
 8000294:	fab3 f283 	clz	r2, r3
 8000298:	f404 1370 	and.w	r3, r4, #3932160	; 0x3c0000
 800029c:	40d3      	lsrs	r3, r2
 800029e:	aa06      	add	r2, sp, #24
 80002a0:	4413      	add	r3, r2
        if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 80002a2:	03e2      	lsls	r2, r4, #15
      temp_reg = RCC->CFGR;
  
      /* Check if PLL is enabled */
      if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLLON))
      {
        pllmul = aPLLMULFactorTable[(uint32_t)(temp_reg & RCC_CFGR_PLLMULL) >> POSITION_VAL(RCC_CFGR_PLLMULL)];
 80002a4:	f813 3c10 	ldrb.w	r3, [r3, #-16]
        if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 80002a8:	d533      	bpl.n	8000312 <HAL_RCCEx_GetPeriphCLKFreq+0xee>
        {
#if defined(STM32F105xC) || defined(STM32F107xC) || defined(STM32F100xB)\
 || defined(STM32F100xE)
          prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> POSITION_VAL(RCC_CFGR2_PREDIV1)];
#else
          prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> POSITION_VAL(RCC_CFGR_PLLXTPRE)];
 80002aa:	6849      	ldr	r1, [r1, #4]
 80002ac:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 80002b0:	fa92 f2a2 	rbit	r2, r2
 80002b4:	fab2 f082 	clz	r0, r2
 80002b8:	f401 3200 	and.w	r2, r1, #131072	; 0x20000
 80002bc:	40c2      	lsrs	r2, r0
 80002be:	a906      	add	r1, sp, #24
 80002c0:	440a      	add	r2, r1
          }
#else
          if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
          {
            /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
            pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
 80002c2:	f812 0c14 	ldrb.w	r0, [r2, #-20]
 80002c6:	4a1b      	ldr	r2, [pc, #108]	; (8000334 <HAL_RCCEx_GetPeriphCLKFreq+0x110>)
 80002c8:	fbb2 f0f0 	udiv	r0, r2, r0
 80002cc:	fb03 f000 	mul.w	r0, r3, r0
          /* Prescaler of 3 selected for USB */ 
          frequency = (2 * pllclk) / 3;
        }
#else
        /* USBCLK = PLLCLK / USB prescaler */
        if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL)
 80002d0:	4b17      	ldr	r3, [pc, #92]	; (8000330 <HAL_RCCEx_GetPeriphCLKFreq+0x10c>)
 80002d2:	685b      	ldr	r3, [r3, #4]
 80002d4:	025b      	lsls	r3, r3, #9
 80002d6:	d4b9      	bmi.n	800024c <HAL_RCCEx_GetPeriphCLKFreq+0x28>
          frequency = pllclk;
        }
        else
        {
          /* Prescaler of 1.5 selected for USB */ 
          frequency = (pllclk * 2) / 3;
 80002d8:	4b17      	ldr	r3, [pc, #92]	; (8000338 <HAL_RCCEx_GetPeriphCLKFreq+0x114>)
 80002da:	0040      	lsls	r0, r0, #1
 80002dc:	fba3 3000 	umull	r3, r0, r3, r0
 80002e0:	0840      	lsrs	r0, r0, #1
 80002e2:	e7b3      	b.n	800024c <HAL_RCCEx_GetPeriphCLKFreq+0x28>
      }
      break;
    }
  case RCC_PERIPHCLK_ADC:  
    {
      frequency = HAL_RCC_GetPCLK2Freq() / (((__HAL_RCC_GET_ADC_SOURCE() >> POSITION_VAL(RCC_CFGR_ADCPRE_DIV4)) + 1) * 2);
 80002e4:	f000 fdbc 	bl	8000e60 <HAL_RCC_GetPCLK2Freq>
 80002e8:	4a11      	ldr	r2, [pc, #68]	; (8000330 <HAL_RCCEx_GetPeriphCLKFreq+0x10c>)
 80002ea:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80002ee:	6852      	ldr	r2, [r2, #4]
 80002f0:	fa93 f3a3 	rbit	r3, r3
 80002f4:	fab3 f183 	clz	r1, r3
 80002f8:	f402 4340 	and.w	r3, r2, #49152	; 0xc000
 80002fc:	40cb      	lsrs	r3, r1
 80002fe:	3301      	adds	r3, #1
 8000300:	005b      	lsls	r3, r3, #1
 8000302:	fbb0 f0f3 	udiv	r0, r0, r3
    {
      break;
    }
  }
  return(frequency);
}
 8000306:	b006      	add	sp, #24
 8000308:	bd70      	pop	{r4, r5, r6, pc}
      temp_reg = RCC->BDCR;

      /* Check if LSE is ready if RTC clock selection is LSE */
      if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY)))
      {
        frequency = LSE_VALUE;
 800030a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
    {
      break;
    }
  }
  return(frequency);
}
 800030e:	b006      	add	sp, #24
 8000310:	bd70      	pop	{r4, r5, r6, pc}
#endif /* STM32F105xC || STM32F107xC */
        }
        else
        {
          /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
          pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
 8000312:	480a      	ldr	r0, [pc, #40]	; (800033c <HAL_RCCEx_GetPeriphCLKFreq+0x118>)
 8000314:	fb00 f003 	mul.w	r0, r0, r3
 8000318:	e7da      	b.n	80002d0 <HAL_RCCEx_GetPeriphCLKFreq+0xac>
      if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY)))
      {
        frequency = LSE_VALUE;
      }
      /* Check if LSI is ready if RTC clock selection is LSI */
      else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
 800031a:	6a4b      	ldr	r3, [r1, #36]	; 0x24
      {
        frequency = LSI_VALUE;
 800031c:	f649 4040 	movw	r0, #40000	; 0x9c40
 8000320:	f013 0f02 	tst.w	r3, #2
 8000324:	bf08      	it	eq
 8000326:	2000      	moveq	r0, #0
 8000328:	e790      	b.n	800024c <HAL_RCCEx_GetPeriphCLKFreq+0x28>
 800032a:	bf00      	nop
 800032c:	080061b0 	.word	0x080061b0
 8000330:	40021000 	.word	0x40021000
 8000334:	007a1200 	.word	0x007a1200
 8000338:	aaaaaaab 	.word	0xaaaaaaab
 800033c:	003d0900 	.word	0x003d0900

08000340 <HAL_PWR_EnableBkUpAccess>:
 8000340:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000344:	fa93 f3a3 	rbit	r3, r3
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  /* Enable access to RTC and backup registers */
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)ENABLE;
 8000348:	fab3 f383 	clz	r3, r3
 800034c:	009b      	lsls	r3, r3, #2
 800034e:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8000352:	f503 2360 	add.w	r3, r3, #917504	; 0xe0000
 8000356:	2201      	movs	r2, #1
 8000358:	601a      	str	r2, [r3, #0]
 800035a:	4770      	bx	lr

0800035c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800035c:	b510      	push	{r4, lr}
 800035e:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8000360:	f000 fd62 	bl	8000e28 <HAL_RCC_GetHCLKFreq>
 8000364:	4b06      	ldr	r3, [pc, #24]	; (8000380 <HAL_InitTick+0x24>)
 8000366:	fba3 3000 	umull	r3, r0, r3, r0
 800036a:	0980      	lsrs	r0, r0, #6
 800036c:	f000 f8a8 	bl	80004c0 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 8000370:	4621      	mov	r1, r4
 8000372:	2200      	movs	r2, #0
 8000374:	f04f 30ff 	mov.w	r0, #4294967295
 8000378:	f000 f85e 	bl	8000438 <HAL_NVIC_SetPriority>

   /* Return function status */
  return HAL_OK;
}
 800037c:	2000      	movs	r0, #0
 800037e:	bd10      	pop	{r4, pc}
 8000380:	10624dd3 	.word	0x10624dd3

08000384 <HAL_Init>:
    defined(STM32F102x6) || defined(STM32F102xB) || \
    defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || \
    defined(STM32F105xC) || defined(STM32F107xC)

  /* Prefetch buffer is not available on value line devices */
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000384:	4a07      	ldr	r2, [pc, #28]	; (80003a4 <HAL_Init+0x20>)
  *        In the default implementation,Systick is used as source of time base.
  *       The tick variable is incremented each 1ms in its ISR.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8000386:	b508      	push	{r3, lr}
    defined(STM32F102x6) || defined(STM32F102xB) || \
    defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || \
    defined(STM32F105xC) || defined(STM32F107xC)

  /* Prefetch buffer is not available on value line devices */
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000388:	6813      	ldr	r3, [r2, #0]
#endif
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800038a:	2003      	movs	r0, #3
    defined(STM32F102x6) || defined(STM32F102xB) || \
    defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || \
    defined(STM32F105xC) || defined(STM32F107xC)

  /* Prefetch buffer is not available on value line devices */
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800038c:	f043 0310 	orr.w	r3, r3, #16
 8000390:	6013      	str	r3, [r2, #0]
#endif
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000392:	f000 f83f 	bl	8000414 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8000396:	200f      	movs	r0, #15
 8000398:	f7ff ffe0 	bl	800035c <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 800039c:	f003 fdfe 	bl	8003f9c <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 80003a0:	2000      	movs	r0, #0
 80003a2:	bd08      	pop	{r3, pc}
 80003a4:	40022000 	.word	0x40022000

080003a8 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 80003a8:	4a02      	ldr	r2, [pc, #8]	; (80003b4 <HAL_IncTick+0xc>)
 80003aa:	6813      	ldr	r3, [r2, #0]
 80003ac:	3301      	adds	r3, #1
 80003ae:	6013      	str	r3, [r2, #0]
 80003b0:	4770      	bx	lr
 80003b2:	bf00      	nop
 80003b4:	200009a4 	.word	0x200009a4

080003b8 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80003b8:	4b01      	ldr	r3, [pc, #4]	; (80003c0 <HAL_GetTick+0x8>)
 80003ba:	6818      	ldr	r0, [r3, #0]
}
 80003bc:	4770      	bx	lr
 80003be:	bf00      	nop
 80003c0:	200009a4 	.word	0x200009a4

080003c4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 80003c4:	b510      	push	{r4, lr}
 80003c6:	b082      	sub	sp, #8
 80003c8:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = 0;
  tickstart = HAL_GetTick();
 80003ca:	f7ff fff5 	bl	80003b8 <HAL_GetTick>
 80003ce:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 80003d0:	f7ff fff2 	bl	80003b8 <HAL_GetTick>
 80003d4:	9b01      	ldr	r3, [sp, #4]
 80003d6:	1b00      	subs	r0, r0, r4
 80003d8:	4298      	cmp	r0, r3
 80003da:	d3f9      	bcc.n	80003d0 <HAL_Delay+0xc>
  {
  }
}
 80003dc:	b002      	add	sp, #8
 80003de:	bd10      	pop	{r4, pc}

080003e0 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 80003e0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80003e2:	f7ff ffe1 	bl	80003a8 <HAL_IncTick>
  osSystickHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 80003e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  osSystickHandler();
 80003ea:	f003 bf2b 	b.w	8004244 <osSystickHandler>
 80003ee:	bf00      	nop

080003f0 <DMA1_Channel1_IRQHandler>:
void DMA1_Channel1_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Channel1_IRQn 0 */

  /* USER CODE END DMA1_Channel1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc1);
 80003f0:	4801      	ldr	r0, [pc, #4]	; (80003f8 <DMA1_Channel1_IRQHandler+0x8>)
 80003f2:	f003 ba35 	b.w	8003860 <HAL_DMA_IRQHandler>
 80003f6:	bf00      	nop
 80003f8:	20001dfc 	.word	0x20001dfc

080003fc <USB_LP_CAN1_RX0_IRQHandler>:
void USB_LP_CAN1_RX0_IRQHandler(void)
{
  /* USER CODE BEGIN USB_LP_CAN1_RX0_IRQn 0 */

  /* USER CODE END USB_LP_CAN1_RX0_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_FS);
 80003fc:	4801      	ldr	r0, [pc, #4]	; (8000404 <USB_LP_CAN1_RX0_IRQHandler+0x8>)
 80003fe:	f001 b853 	b.w	80014a8 <HAL_PCD_IRQHandler>
 8000402:	bf00      	nop
 8000404:	2000208c 	.word	0x2000208c

08000408 <TIM2_IRQHandler>:
void TIM2_IRQHandler(void)
{
  /* USER CODE BEGIN TIM2_IRQn 0 */

  /* USER CODE END TIM2_IRQn 0 */
  HAL_TIM_IRQHandler(&htim2);
 8000408:	4801      	ldr	r0, [pc, #4]	; (8000410 <TIM2_IRQHandler+0x8>)
 800040a:	f004 bfcd 	b.w	80053a8 <HAL_TIM_IRQHandler>
 800040e:	bf00      	nop
 8000410:	20001e50 	.word	0x20001e50

08000414 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8000414:	f64f 02ff 	movw	r2, #63743	; 0xf8ff
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000418:	4906      	ldr	r1, [pc, #24]	; (8000434 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 800041a:	0200      	lsls	r0, r0, #8
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800041c:	68cb      	ldr	r3, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 800041e:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 8000422:	401a      	ands	r2, r3
 8000424:	f042 63bf 	orr.w	r3, r2, #100139008	; 0x5f80000
 8000428:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800042c:	4303      	orrs	r3, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800042e:	60cb      	str	r3, [r1, #12]
 8000430:	4770      	bx	lr
 8000432:	bf00      	nop
 8000434:	e000ed00 	.word	0xe000ed00

08000438 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000438:	4b19      	ldr	r3, [pc, #100]	; (80004a0 <HAL_NVIC_SetPriority+0x68>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800043a:	b430      	push	{r4, r5}
 800043c:	68db      	ldr	r3, [r3, #12]
 800043e:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000442:	f1c3 0507 	rsb	r5, r3, #7
 8000446:	2d04      	cmp	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000448:	f103 0404 	add.w	r4, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800044c:	bf28      	it	cs
 800044e:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000450:	2c06      	cmp	r4, #6
 8000452:	d918      	bls.n	8000486 <HAL_NVIC_SetPriority+0x4e>
 8000454:	3b03      	subs	r3, #3
 8000456:	2401      	movs	r4, #1
 8000458:	409c      	lsls	r4, r3
 800045a:	3c01      	subs	r4, #1
 800045c:	4022      	ands	r2, r4

  return (
 800045e:	2401      	movs	r4, #1
 8000460:	40ac      	lsls	r4, r5
 8000462:	3c01      	subs	r4, #1
 8000464:	4021      	ands	r1, r4
 8000466:	fa01 f303 	lsl.w	r3, r1, r3
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 800046a:	2800      	cmp	r0, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 800046c:	ea42 0203 	orr.w	r2, r2, r3
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8000470:	db0c      	blt.n	800048c <HAL_NVIC_SetPriority+0x54>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000472:	0112      	lsls	r2, r2, #4
 8000474:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8000478:	b2d2      	uxtb	r2, r2
 800047a:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 800047e:	f880 2300 	strb.w	r2, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8000482:	bc30      	pop	{r4, r5}
 8000484:	4770      	bx	lr
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000486:	2200      	movs	r2, #0
 8000488:	4613      	mov	r3, r2
 800048a:	e7e8      	b.n	800045e <HAL_NVIC_SetPriority+0x26>
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800048c:	4b05      	ldr	r3, [pc, #20]	; (80004a4 <HAL_NVIC_SetPriority+0x6c>)
 800048e:	f000 000f 	and.w	r0, r0, #15
 8000492:	0112      	lsls	r2, r2, #4
 8000494:	b2d2      	uxtb	r2, r2
 8000496:	4403      	add	r3, r0
 8000498:	761a      	strb	r2, [r3, #24]
 800049a:	bc30      	pop	{r4, r5}
 800049c:	4770      	bx	lr
 800049e:	bf00      	nop
 80004a0:	e000ed00 	.word	0xe000ed00
 80004a4:	e000ecfc 	.word	0xe000ecfc

080004a8 <HAL_NVIC_EnableIRQ>:
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80004a8:	f000 011f 	and.w	r1, r0, #31
 80004ac:	2301      	movs	r3, #1
 80004ae:	4a03      	ldr	r2, [pc, #12]	; (80004bc <HAL_NVIC_EnableIRQ+0x14>)
 80004b0:	0940      	lsrs	r0, r0, #5
 80004b2:	408b      	lsls	r3, r1
 80004b4:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
 80004b8:	4770      	bx	lr
 80004ba:	bf00      	nop
 80004bc:	e000e100 	.word	0xe000e100

080004c0 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80004c0:	3801      	subs	r0, #1
 80004c2:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80004c6:	d20d      	bcs.n	80004e4 <HAL_SYSTICK_Config+0x24>
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 80004c8:	b430      	push	{r4, r5}
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80004ca:	4b07      	ldr	r3, [pc, #28]	; (80004e8 <HAL_SYSTICK_Config+0x28>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80004cc:	4c07      	ldr	r4, [pc, #28]	; (80004ec <HAL_SYSTICK_Config+0x2c>)
 80004ce:	25f0      	movs	r5, #240	; 0xf0
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80004d0:	6058      	str	r0, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80004d2:	2200      	movs	r2, #0
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80004d4:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80004d8:	2107      	movs	r1, #7
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80004da:	4610      	mov	r0, r2
   return SysTick_Config(TicksNumb);
}
 80004dc:	bc30      	pop	{r4, r5}
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80004de:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80004e0:	6019      	str	r1, [r3, #0]
 80004e2:	4770      	bx	lr
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
 80004e4:	2001      	movs	r0, #1
 80004e6:	4770      	bx	lr
 80004e8:	e000e010 	.word	0xe000e010
 80004ec:	e000ed00 	.word	0xe000ed00

080004f0 <HAL_SYSTICK_CLKSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 80004f0:	4a04      	ldr	r2, [pc, #16]	; (8000504 <HAL_SYSTICK_CLKSourceConfig+0x14>)
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 80004f2:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 80004f4:	6813      	ldr	r3, [r2, #0]
 80004f6:	bf0c      	ite	eq
 80004f8:	f043 0304 	orreq.w	r3, r3, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 80004fc:	f023 0304 	bicne.w	r3, r3, #4
 8000500:	6013      	str	r3, [r2, #0]
 8000502:	4770      	bx	lr
 8000504:	e000e010 	.word	0xe000e010

08000508 <HAL_CRC_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
{
  /* Check the CRC handle allocation */
  if(hcrc == NULL)
 8000508:	b180      	cbz	r0, 800052c <HAL_CRC_Init+0x24>
  }

  /* Check the parameters */
  assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));

  if(hcrc->State == HAL_CRC_STATE_RESET)
 800050a:	7943      	ldrb	r3, [r0, #5]
  * @param  hcrc: pointer to a CRC_HandleTypeDef structure that contains
  *         the configuration information for CRC
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
{
 800050c:	b510      	push	{r4, lr}
  }

  /* Check the parameters */
  assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));

  if(hcrc->State == HAL_CRC_STATE_RESET)
 800050e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8000512:	4604      	mov	r4, r0
 8000514:	b11b      	cbz	r3, 800051e <HAL_CRC_Init+0x16>
    /* Init the low level hardware */
    HAL_CRC_MspInit(hcrc);
  }

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_READY;
 8000516:	2301      	movs	r3, #1
 8000518:	7163      	strb	r3, [r4, #5]
  
  /* Return function status */
  return HAL_OK;
 800051a:	2000      	movs	r0, #0
 800051c:	bd10      	pop	{r4, pc}
  assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));

  if(hcrc->State == HAL_CRC_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hcrc->Lock = HAL_UNLOCKED;
 800051e:	7102      	strb	r2, [r0, #4]
    
    /* Init the low level hardware */
    HAL_CRC_MspInit(hcrc);
 8000520:	f003 fd9c 	bl	800405c <HAL_CRC_MspInit>
  }

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_READY;
 8000524:	2301      	movs	r3, #1
 8000526:	7163      	strb	r3, [r4, #5]
  
  /* Return function status */
  return HAL_OK;
 8000528:	2000      	movs	r0, #0
 800052a:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
{
  /* Check the CRC handle allocation */
  if(hcrc == NULL)
  {
    return HAL_ERROR;
 800052c:	2001      	movs	r0, #1
 800052e:	4770      	bx	lr

08000530 <HAL_IWDG_Init>:
  * @param  hiwdg: pointer to a IWDG_HandleTypeDef structure that contains
  *                the configuration information for the specified IWDG module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_IWDG_Init(IWDG_HandleTypeDef *hiwdg)
{
 8000530:	b510      	push	{r4, lr}
  /* Check the IWDG handle allocation */
  if(hiwdg == NULL)
 8000532:	b310      	cbz	r0, 800057a <HAL_IWDG_Init+0x4a>
  assert_param(IS_IWDG_ALL_INSTANCE(hiwdg->Instance));
  assert_param(IS_IWDG_PRESCALER(hiwdg->Init.Prescaler));
  assert_param(IS_IWDG_RELOAD(hiwdg->Init.Reload)); 
  
  /* Check pending flag, if previous update not done, return error */
  if((__HAL_IWDG_GET_FLAG(hiwdg, IWDG_FLAG_PVU) != RESET)
 8000534:	6803      	ldr	r3, [r0, #0]
 8000536:	68da      	ldr	r2, [r3, #12]
 8000538:	07d1      	lsls	r1, r2, #31
 800053a:	d41b      	bmi.n	8000574 <HAL_IWDG_Init+0x44>
     &&(__HAL_IWDG_GET_FLAG(hiwdg, IWDG_FLAG_RVU) != RESET))
  {
    return HAL_ERROR;
  }
    
  if(hiwdg->State == HAL_IWDG_STATE_RESET)
 800053c:	7b42      	ldrb	r2, [r0, #13]
 800053e:	4604      	mov	r4, r0
 8000540:	f002 01ff 	and.w	r1, r2, #255	; 0xff
 8000544:	b1da      	cbz	r2, 800057e <HAL_IWDG_Init+0x4e>
  
  /* Change IWDG peripheral state */
  hiwdg->State = HAL_IWDG_STATE_BUSY;  
  
  /* Enable write access to IWDG_PR and IWDG_RLR registers */  
  IWDG_ENABLE_WRITE_ACCESS(hiwdg);
 8000546:	f245 5255 	movw	r2, #21845	; 0x5555
    /* Init the low level hardware */
    HAL_IWDG_MspInit(hiwdg);
  }
  
  /* Change IWDG peripheral state */
  hiwdg->State = HAL_IWDG_STATE_BUSY;  
 800054a:	2102      	movs	r1, #2
 800054c:	7361      	strb	r1, [r4, #13]
  
  /* Enable write access to IWDG_PR and IWDG_RLR registers */  
  IWDG_ENABLE_WRITE_ACCESS(hiwdg);
 800054e:	601a      	str	r2, [r3, #0]
  
  /* Write to IWDG registers the IWDG_Prescaler & IWDG_Reload values to work with */
  MODIFY_REG(hiwdg->Instance->PR, IWDG_PR_PR, hiwdg->Init.Prescaler);
 8000550:	6859      	ldr	r1, [r3, #4]
 8000552:	6862      	ldr	r2, [r4, #4]
 8000554:	f021 0107 	bic.w	r1, r1, #7
 8000558:	430a      	orrs	r2, r1
 800055a:	605a      	str	r2, [r3, #4]
  MODIFY_REG(hiwdg->Instance->RLR, IWDG_RLR_RL, hiwdg->Init.Reload);
 800055c:	689a      	ldr	r2, [r3, #8]
 800055e:	68a1      	ldr	r1, [r4, #8]
 8000560:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 8000564:	f022 020f 	bic.w	r2, r2, #15
 8000568:	430a      	orrs	r2, r1
 
  /* Change IWDG peripheral state */
  hiwdg->State = HAL_IWDG_STATE_READY;
 800056a:	2101      	movs	r1, #1
  /* Enable write access to IWDG_PR and IWDG_RLR registers */  
  IWDG_ENABLE_WRITE_ACCESS(hiwdg);
  
  /* Write to IWDG registers the IWDG_Prescaler & IWDG_Reload values to work with */
  MODIFY_REG(hiwdg->Instance->PR, IWDG_PR_PR, hiwdg->Init.Prescaler);
  MODIFY_REG(hiwdg->Instance->RLR, IWDG_RLR_RL, hiwdg->Init.Reload);
 800056c:	609a      	str	r2, [r3, #8]
 
  /* Change IWDG peripheral state */
  hiwdg->State = HAL_IWDG_STATE_READY;
  
  /* Return function status */
  return HAL_OK;
 800056e:	2000      	movs	r0, #0
  /* Write to IWDG registers the IWDG_Prescaler & IWDG_Reload values to work with */
  MODIFY_REG(hiwdg->Instance->PR, IWDG_PR_PR, hiwdg->Init.Prescaler);
  MODIFY_REG(hiwdg->Instance->RLR, IWDG_RLR_RL, hiwdg->Init.Reload);
 
  /* Change IWDG peripheral state */
  hiwdg->State = HAL_IWDG_STATE_READY;
 8000570:	7361      	strb	r1, [r4, #13]
  
  /* Return function status */
  return HAL_OK;
 8000572:	bd10      	pop	{r4, pc}
  assert_param(IS_IWDG_PRESCALER(hiwdg->Init.Prescaler));
  assert_param(IS_IWDG_RELOAD(hiwdg->Init.Reload)); 
  
  /* Check pending flag, if previous update not done, return error */
  if((__HAL_IWDG_GET_FLAG(hiwdg, IWDG_FLAG_PVU) != RESET)
     &&(__HAL_IWDG_GET_FLAG(hiwdg, IWDG_FLAG_RVU) != RESET))
 8000574:	68da      	ldr	r2, [r3, #12]
 8000576:	0792      	lsls	r2, r2, #30
 8000578:	d5e0      	bpl.n	800053c <HAL_IWDG_Init+0xc>
HAL_StatusTypeDef HAL_IWDG_Init(IWDG_HandleTypeDef *hiwdg)
{
  /* Check the IWDG handle allocation */
  if(hiwdg == NULL)
  {
    return HAL_ERROR;
 800057a:	2001      	movs	r0, #1
  /* Change IWDG peripheral state */
  hiwdg->State = HAL_IWDG_STATE_READY;
  
  /* Return function status */
  return HAL_OK;
}
 800057c:	bd10      	pop	{r4, pc}
  }
    
  if(hiwdg->State == HAL_IWDG_STATE_RESET)
  {  
    /* Allocate lock resource and initialize it */
    hiwdg->Lock = HAL_UNLOCKED;
 800057e:	7301      	strb	r1, [r0, #12]
    
    /* Init the low level hardware */
    HAL_IWDG_MspInit(hiwdg);
 8000580:	f003 fd82 	bl	8004088 <HAL_IWDG_MspInit>
 8000584:	6823      	ldr	r3, [r4, #0]
 8000586:	e7de      	b.n	8000546 <HAL_IWDG_Init+0x16>

08000588 <SystemInit>:
  */
void SystemInit (void)
{
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000588:	4b10      	ldr	r3, [pc, #64]	; (80005cc <SystemInit+0x44>)
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 800058a:	b410      	push	{r4}
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800058c:	6819      	ldr	r1, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#if !defined(STM32F105xC) && !defined(STM32F107xC)
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 800058e:	4a10      	ldr	r2, [pc, #64]	; (80005d0 <SystemInit+0x48>)
  */
void SystemInit (void)
{
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000590:	f041 0101 	orr.w	r1, r1, #1
 8000594:	6019      	str	r1, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#if !defined(STM32F105xC) && !defined(STM32F107xC)
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 8000596:	6859      	ldr	r1, [r3, #4]
#endif 

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 8000598:	480e      	ldr	r0, [pc, #56]	; (80005d4 <SystemInit+0x4c>)
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#if !defined(STM32F105xC) && !defined(STM32F107xC)
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 800059a:	400a      	ands	r2, r1
 800059c:	605a      	str	r2, [r3, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F105xC */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800059e:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 80005a0:	f44f 041f 	mov.w	r4, #10420224	; 0x9f0000
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F105xC */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80005a4:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 80005a8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80005ac:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80005ae:	681a      	ldr	r2, [r3, #0]
#endif 

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 80005b0:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80005b4:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80005b8:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 80005ba:	685a      	ldr	r2, [r3, #4]
 80005bc:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 80005c0:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 80005c2:	609c      	str	r4, [r3, #8]
#endif 

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 80005c4:	6081      	str	r1, [r0, #8]
#endif 
}
 80005c6:	bc10      	pop	{r4}
 80005c8:	4770      	bx	lr
 80005ca:	bf00      	nop
 80005cc:	40021000 	.word	0x40021000
 80005d0:	f8ff0000 	.word	0xf8ff0000
 80005d4:	e000ed00 	.word	0xe000ed00

080005d8 <HAL_RCC_OscConfig>:
  * @note   The PLL is not disabled when used as system clock.
  * @note   The PLL is not disabled when USB OTG FS clock is enabled (specific to devices with USB FS)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80005d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80005dc:	6803      	ldr	r3, [r0, #0]
  * @note   The PLL is not disabled when used as system clock.
  * @note   The PLL is not disabled when USB OTG FS clock is enabled (specific to devices with USB FS)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80005de:	b082      	sub	sp, #8
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80005e0:	07df      	lsls	r7, r3, #31
  * @note   The PLL is not disabled when used as system clock.
  * @note   The PLL is not disabled when USB OTG FS clock is enabled (specific to devices with USB FS)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80005e2:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80005e4:	d565      	bpl.n	80006b2 <HAL_RCC_OscConfig+0xda>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
        
    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 80005e6:	49be      	ldr	r1, [pc, #760]	; (80008e0 <HAL_RCC_OscConfig+0x308>)
 80005e8:	684a      	ldr	r2, [r1, #4]
 80005ea:	f002 020c 	and.w	r2, r2, #12
 80005ee:	2a04      	cmp	r2, #4
 80005f0:	f000 8125 	beq.w	800083e <HAL_RCC_OscConfig+0x266>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80005f4:	684a      	ldr	r2, [r1, #4]
 80005f6:	f002 020c 	and.w	r2, r2, #12
 80005fa:	2a08      	cmp	r2, #8
 80005fc:	f000 811b 	beq.w	8000836 <HAL_RCC_OscConfig+0x25e>
      }
    }
    else
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 8000600:	4bb7      	ldr	r3, [pc, #732]	; (80008e0 <HAL_RCC_OscConfig+0x308>)
 8000602:	f44f 3700 	mov.w	r7, #131072	; 0x20000
 8000606:	681a      	ldr	r2, [r3, #0]
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000608:	461d      	mov	r5, r3
      }
    }
    else
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 800060a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800060e:	601a      	str	r2, [r3, #0]
 8000610:	681a      	ldr	r2, [r3, #0]
 8000612:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000616:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000618:	f7ff fece 	bl	80003b8 <HAL_GetTick>
 800061c:	4606      	mov	r6, r0
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800061e:	e005      	b.n	800062c <HAL_RCC_OscConfig+0x54>
      {
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000620:	f7ff feca 	bl	80003b8 <HAL_GetTick>
 8000624:	1b80      	subs	r0, r0, r6
 8000626:	2864      	cmp	r0, #100	; 0x64
 8000628:	f200 811f 	bhi.w	800086a <HAL_RCC_OscConfig+0x292>
 800062c:	fa97 f3a7 	rbit	r3, r7
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000630:	49ab      	ldr	r1, [pc, #684]	; (80008e0 <HAL_RCC_OscConfig+0x308>)
 8000632:	682a      	ldr	r2, [r5, #0]
 8000634:	fa97 f3a7 	rbit	r3, r7
 8000638:	fab3 f383 	clz	r3, r3
 800063c:	f003 031f 	and.w	r3, r3, #31
 8000640:	fa22 f303 	lsr.w	r3, r2, r3
 8000644:	07d8      	lsls	r0, r3, #31
 8000646:	d4eb      	bmi.n	8000620 <HAL_RCC_OscConfig+0x48>
          return HAL_TIMEOUT;
        }
      }
      
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000648:	6863      	ldr	r3, [r4, #4]
 800064a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800064e:	d011      	beq.n	8000674 <HAL_RCC_OscConfig+0x9c>
 8000650:	2b00      	cmp	r3, #0
 8000652:	f000 81b6 	beq.w	80009c2 <HAL_RCC_OscConfig+0x3ea>
 8000656:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 800065a:	680b      	ldr	r3, [r1, #0]
 800065c:	d007      	beq.n	800066e <HAL_RCC_OscConfig+0x96>
 800065e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000662:	600b      	str	r3, [r1, #0]
 8000664:	680b      	ldr	r3, [r1, #0]
 8000666:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800066a:	600b      	str	r3, [r1, #0]
 800066c:	e006      	b.n	800067c <HAL_RCC_OscConfig+0xa4>
 800066e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000672:	600b      	str	r3, [r1, #0]
 8000674:	680b      	ldr	r3, [r1, #0]
 8000676:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800067a:	600b      	str	r3, [r1, #0]

       /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800067c:	f7ff fe9c 	bl	80003b8 <HAL_GetTick>
 8000680:	f44f 3700 	mov.w	r7, #131072	; 0x20000
 8000684:	4606      	mov	r6, r0
        
        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000686:	4d96      	ldr	r5, [pc, #600]	; (80008e0 <HAL_RCC_OscConfig+0x308>)
 8000688:	e005      	b.n	8000696 <HAL_RCC_OscConfig+0xbe>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800068a:	f7ff fe95 	bl	80003b8 <HAL_GetTick>
 800068e:	1b80      	subs	r0, r0, r6
 8000690:	2864      	cmp	r0, #100	; 0x64
 8000692:	f200 80ea 	bhi.w	800086a <HAL_RCC_OscConfig+0x292>
 8000696:	fa97 f3a7 	rbit	r3, r7
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800069a:	682a      	ldr	r2, [r5, #0]
 800069c:	fa97 f3a7 	rbit	r3, r7
 80006a0:	fab3 f383 	clz	r3, r3
 80006a4:	f003 031f 	and.w	r3, r3, #31
 80006a8:	fa22 f303 	lsr.w	r3, r2, r3
 80006ac:	07da      	lsls	r2, r3, #31
 80006ae:	d5ec      	bpl.n	800068a <HAL_RCC_OscConfig+0xb2>
 80006b0:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80006b2:	0798      	lsls	r0, r3, #30
 80006b4:	d542      	bpl.n	800073c <HAL_RCC_OscConfig+0x164>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 80006b6:	4a8a      	ldr	r2, [pc, #552]	; (80008e0 <HAL_RCC_OscConfig+0x308>)
 80006b8:	6851      	ldr	r1, [r2, #4]
 80006ba:	f011 0f0c 	tst.w	r1, #12
 80006be:	f000 80a4 	beq.w	800080a <HAL_RCC_OscConfig+0x232>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 80006c2:	6851      	ldr	r1, [r2, #4]
 80006c4:	f001 010c 	and.w	r1, r1, #12
 80006c8:	2908      	cmp	r1, #8
 80006ca:	f000 809a 	beq.w	8000802 <HAL_RCC_OscConfig+0x22a>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80006ce:	6922      	ldr	r2, [r4, #16]
 80006d0:	2a00      	cmp	r2, #0
 80006d2:	f000 8150 	beq.w	8000976 <HAL_RCC_OscConfig+0x39e>
 80006d6:	2201      	movs	r2, #1
 80006d8:	fa92 f3a2 	rbit	r3, r2
      {
       /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80006dc:	fab3 f383 	clz	r3, r3
 80006e0:	009b      	lsls	r3, r3, #2
 80006e2:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 80006e6:	f503 0384 	add.w	r3, r3, #4325376	; 0x420000
 80006ea:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80006ec:	f7ff fe64 	bl	80003b8 <HAL_GetTick>
 80006f0:	2702      	movs	r7, #2
 80006f2:	4606      	mov	r6, r0
        
        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80006f4:	4d7a      	ldr	r5, [pc, #488]	; (80008e0 <HAL_RCC_OscConfig+0x308>)
 80006f6:	e005      	b.n	8000704 <HAL_RCC_OscConfig+0x12c>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80006f8:	f7ff fe5e 	bl	80003b8 <HAL_GetTick>
 80006fc:	1b80      	subs	r0, r0, r6
 80006fe:	2802      	cmp	r0, #2
 8000700:	f200 80b3 	bhi.w	800086a <HAL_RCC_OscConfig+0x292>
 8000704:	fa97 f3a7 	rbit	r3, r7
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000708:	4975      	ldr	r1, [pc, #468]	; (80008e0 <HAL_RCC_OscConfig+0x308>)
 800070a:	682a      	ldr	r2, [r5, #0]
 800070c:	fa97 f3a7 	rbit	r3, r7
 8000710:	fab3 f383 	clz	r3, r3
 8000714:	f003 031f 	and.w	r3, r3, #31
 8000718:	fa22 f303 	lsr.w	r3, r2, r3
 800071c:	07db      	lsls	r3, r3, #31
 800071e:	d5eb      	bpl.n	80006f8 <HAL_RCC_OscConfig+0x120>
            return HAL_TIMEOUT;
          }
        }
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8000720:	680b      	ldr	r3, [r1, #0]
 8000722:	22f8      	movs	r2, #248	; 0xf8
 8000724:	fa92 f2a2 	rbit	r2, r2
 8000728:	fab2 f282 	clz	r2, r2
 800072c:	6960      	ldr	r0, [r4, #20]
 800072e:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8000732:	fa00 f202 	lsl.w	r2, r0, r2
 8000736:	4313      	orrs	r3, r2
 8000738:	600b      	str	r3, [r1, #0]
 800073a:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800073c:	0719      	lsls	r1, r3, #28
 800073e:	d436      	bmi.n	80007ae <HAL_RCC_OscConfig+0x1d6>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8000740:	075d      	lsls	r5, r3, #29
 8000742:	f100 80d1 	bmi.w	80008e8 <HAL_RCC_OscConfig+0x310>

#endif /* RCC_CR_PLL2ON */
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8000746:	69e3      	ldr	r3, [r4, #28]
 8000748:	b36b      	cbz	r3, 80007a6 <HAL_RCC_OscConfig+0x1ce>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800074a:	4d65      	ldr	r5, [pc, #404]	; (80008e0 <HAL_RCC_OscConfig+0x308>)
 800074c:	686a      	ldr	r2, [r5, #4]
 800074e:	f002 020c 	and.w	r2, r2, #12
 8000752:	2a08      	cmp	r2, #8
 8000754:	d06b      	beq.n	800082e <HAL_RCC_OscConfig+0x256>
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8000756:	2b02      	cmp	r3, #2
 8000758:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800075c:	f000 8154 	beq.w	8000a08 <HAL_RCC_OscConfig+0x430>
 8000760:	fa93 f3a3 	rbit	r3, r3
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8000764:	fab3 f383 	clz	r3, r3
 8000768:	009b      	lsls	r3, r3, #2
 800076a:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 800076e:	f503 0384 	add.w	r3, r3, #4325376	; 0x420000
 8000772:	2200      	movs	r2, #0
 8000774:	601a      	str	r2, [r3, #0]
 
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000776:	f7ff fe1f 	bl	80003b8 <HAL_GetTick>
 800077a:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
 800077e:	4606      	mov	r6, r0
        
        /* Wait till PLL is disabled */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000780:	e004      	b.n	800078c <HAL_RCC_OscConfig+0x1b4>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000782:	f7ff fe19 	bl	80003b8 <HAL_GetTick>
 8000786:	1b80      	subs	r0, r0, r6
 8000788:	2802      	cmp	r0, #2
 800078a:	d86e      	bhi.n	800086a <HAL_RCC_OscConfig+0x292>
 800078c:	fa94 f3a4 	rbit	r3, r4
 
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is disabled */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000790:	682a      	ldr	r2, [r5, #0]
 8000792:	fa94 f3a4 	rbit	r3, r4
 8000796:	fab3 f383 	clz	r3, r3
 800079a:	f003 031f 	and.w	r3, r3, #31
 800079e:	fa22 f303 	lsr.w	r3, r2, r3
 80007a2:	07db      	lsls	r3, r3, #31
 80007a4:	d4ed      	bmi.n	8000782 <HAL_RCC_OscConfig+0x1aa>
    {
      return HAL_ERROR;
    }
  }
  
  return HAL_OK;
 80007a6:	2000      	movs	r0, #0
}
 80007a8:	b002      	add	sp, #8
 80007aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    
    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 80007ae:	69a2      	ldr	r2, [r4, #24]
 80007b0:	2a00      	cmp	r2, #0
 80007b2:	d05e      	beq.n	8000872 <HAL_RCC_OscConfig+0x29a>
 80007b4:	2201      	movs	r2, #1
 80007b6:	fa92 f3a2 	rbit	r3, r2
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 80007ba:	fab3 f383 	clz	r3, r3
 80007be:	4949      	ldr	r1, [pc, #292]	; (80008e4 <HAL_RCC_OscConfig+0x30c>)
 80007c0:	2702      	movs	r7, #2
 80007c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 80007c6:	f7ff fdf7 	bl	80003b8 <HAL_GetTick>
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80007ca:	4d45      	ldr	r5, [pc, #276]	; (80008e0 <HAL_RCC_OscConfig+0x308>)
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 80007cc:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80007ce:	e004      	b.n	80007da <HAL_RCC_OscConfig+0x202>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80007d0:	f7ff fdf2 	bl	80003b8 <HAL_GetTick>
 80007d4:	1b80      	subs	r0, r0, r6
 80007d6:	2802      	cmp	r0, #2
 80007d8:	d847      	bhi.n	800086a <HAL_RCC_OscConfig+0x292>
 80007da:	fa97 f3a7 	rbit	r3, r7
 80007de:	fa97 f3a7 	rbit	r3, r7
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80007e2:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 80007e4:	fa97 f3a7 	rbit	r3, r7
 80007e8:	fab3 f383 	clz	r3, r3
 80007ec:	f003 031f 	and.w	r3, r3, #31
 80007f0:	fa22 f303 	lsr.w	r3, r2, r3
 80007f4:	07da      	lsls	r2, r3, #31
 80007f6:	d5eb      	bpl.n	80007d0 <HAL_RCC_OscConfig+0x1f8>
          return HAL_TIMEOUT;
        }
      }
      /*  To have a fully stabilized clock in the specified range, a software temporization of 1ms 
          should be added.*/
      HAL_Delay(1);
 80007f8:	2001      	movs	r0, #1
 80007fa:	f7ff fde3 	bl	80003c4 <HAL_Delay>
 80007fe:	6823      	ldr	r3, [r4, #0]
 8000800:	e79e      	b.n	8000740 <HAL_RCC_OscConfig+0x168>
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 8000802:	6852      	ldr	r2, [r2, #4]
 8000804:	03d1      	lsls	r1, r2, #15
 8000806:	f53f af62 	bmi.w	80006ce <HAL_RCC_OscConfig+0xf6>
 800080a:	2202      	movs	r2, #2
 800080c:	fa92 f1a2 	rbit	r1, r2
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8000810:	4933      	ldr	r1, [pc, #204]	; (80008e0 <HAL_RCC_OscConfig+0x308>)
 8000812:	6809      	ldr	r1, [r1, #0]
 8000814:	fa92 f2a2 	rbit	r2, r2
 8000818:	fab2 f282 	clz	r2, r2
 800081c:	f002 021f 	and.w	r2, r2, #31
 8000820:	fa21 f202 	lsr.w	r2, r1, r2
 8000824:	07d2      	lsls	r2, r2, #31
 8000826:	d548      	bpl.n	80008ba <HAL_RCC_OscConfig+0x2e2>
 8000828:	6922      	ldr	r2, [r4, #16]
 800082a:	2a01      	cmp	r2, #1
 800082c:	d045      	beq.n	80008ba <HAL_RCC_OscConfig+0x2e2>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
      {
        return HAL_ERROR;
 800082e:	2001      	movs	r0, #1
      return HAL_ERROR;
    }
  }
  
  return HAL_OK;
}
 8000830:	b002      	add	sp, #8
 8000832:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
        
    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8000836:	684a      	ldr	r2, [r1, #4]
 8000838:	03d6      	lsls	r6, r2, #15
 800083a:	f57f aee1 	bpl.w	8000600 <HAL_RCC_OscConfig+0x28>
 800083e:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8000842:	fa92 f1a2 	rbit	r1, r2
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8000846:	4926      	ldr	r1, [pc, #152]	; (80008e0 <HAL_RCC_OscConfig+0x308>)
 8000848:	6809      	ldr	r1, [r1, #0]
 800084a:	fa92 f2a2 	rbit	r2, r2
 800084e:	fab2 f282 	clz	r2, r2
 8000852:	f002 021f 	and.w	r2, r2, #31
 8000856:	fa21 f202 	lsr.w	r2, r1, r2
 800085a:	07d5      	lsls	r5, r2, #31
 800085c:	f57f af29 	bpl.w	80006b2 <HAL_RCC_OscConfig+0xda>
 8000860:	6862      	ldr	r2, [r4, #4]
 8000862:	2a00      	cmp	r2, #0
 8000864:	f47f af25 	bne.w	80006b2 <HAL_RCC_OscConfig+0xda>
 8000868:	e7e1      	b.n	800082e <HAL_RCC_OscConfig+0x256>
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
        {
          return HAL_TIMEOUT;
 800086a:	2003      	movs	r0, #3
      return HAL_ERROR;
    }
  }
  
  return HAL_OK;
}
 800086c:	b002      	add	sp, #8
 800086e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000872:	2301      	movs	r3, #1
 8000874:	fa93 f3a3 	rbit	r3, r3
      HAL_Delay(1);
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8000878:	fab3 f383 	clz	r3, r3
 800087c:	4919      	ldr	r1, [pc, #100]	; (80008e4 <HAL_RCC_OscConfig+0x30c>)
 800087e:	2702      	movs	r7, #2
 8000880:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000884:	f7ff fd98 	bl	80003b8 <HAL_GetTick>
      
      /* Wait till LSI is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8000888:	4d15      	ldr	r5, [pc, #84]	; (80008e0 <HAL_RCC_OscConfig+0x308>)
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800088a:	4606      	mov	r6, r0
      
      /* Wait till LSI is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800088c:	e004      	b.n	8000898 <HAL_RCC_OscConfig+0x2c0>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800088e:	f7ff fd93 	bl	80003b8 <HAL_GetTick>
 8000892:	1b80      	subs	r0, r0, r6
 8000894:	2802      	cmp	r0, #2
 8000896:	d8e8      	bhi.n	800086a <HAL_RCC_OscConfig+0x292>
 8000898:	fa97 f3a7 	rbit	r3, r7
 800089c:	fa97 f3a7 	rbit	r3, r7
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80008a0:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 80008a2:	fa97 f3a7 	rbit	r3, r7
 80008a6:	fab3 f383 	clz	r3, r3
 80008aa:	f003 031f 	and.w	r3, r3, #31
 80008ae:	fa22 f303 	lsr.w	r3, r2, r3
 80008b2:	07db      	lsls	r3, r3, #31
 80008b4:	d4eb      	bmi.n	800088e <HAL_RCC_OscConfig+0x2b6>
 80008b6:	6823      	ldr	r3, [r4, #0]
 80008b8:	e742      	b.n	8000740 <HAL_RCC_OscConfig+0x168>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80008ba:	4d09      	ldr	r5, [pc, #36]	; (80008e0 <HAL_RCC_OscConfig+0x308>)
 80008bc:	22f8      	movs	r2, #248	; 0xf8
 80008be:	6829      	ldr	r1, [r5, #0]
 80008c0:	fa92 f2a2 	rbit	r2, r2
 80008c4:	fab2 f282 	clz	r2, r2
 80008c8:	6960      	ldr	r0, [r4, #20]
 80008ca:	f021 01f8 	bic.w	r1, r1, #248	; 0xf8
 80008ce:	fa00 f202 	lsl.w	r2, r0, r2
 80008d2:	430a      	orrs	r2, r1
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80008d4:	0719      	lsls	r1, r3, #28
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80008d6:	602a      	str	r2, [r5, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80008d8:	f57f af32 	bpl.w	8000740 <HAL_RCC_OscConfig+0x168>
 80008dc:	e767      	b.n	80007ae <HAL_RCC_OscConfig+0x1d6>
 80008de:	bf00      	nop
 80008e0:	40021000 	.word	0x40021000
 80008e4:	42420480 	.word	0x42420480
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 80008e8:	4aaf      	ldr	r2, [pc, #700]	; (8000ba8 <HAL_RCC_OscConfig+0x5d0>)
    
    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR, PWR_CR_DBP);
 80008ea:	4bb0      	ldr	r3, [pc, #704]	; (8000bac <HAL_RCC_OscConfig+0x5d4>)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 80008ec:	69d1      	ldr	r1, [r2, #28]
    SET_BIT(PWR->CR, PWR_CR_DBP);

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 80008ee:	461d      	mov	r5, r3
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 80008f0:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 80008f4:	61d1      	str	r1, [r2, #28]
 80008f6:	69d2      	ldr	r2, [r2, #28]
 80008f8:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 80008fc:	9201      	str	r2, [sp, #4]
 80008fe:	9a01      	ldr	r2, [sp, #4]
    
    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR, PWR_CR_DBP);
 8000900:	681a      	ldr	r2, [r3, #0]
 8000902:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000906:	601a      	str	r2, [r3, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8000908:	f7ff fd56 	bl	80003b8 <HAL_GetTick>
 800090c:	4606      	mov	r6, r0
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 800090e:	e004      	b.n	800091a <HAL_RCC_OscConfig+0x342>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8000910:	f7ff fd52 	bl	80003b8 <HAL_GetTick>
 8000914:	1b80      	subs	r0, r0, r6
 8000916:	2864      	cmp	r0, #100	; 0x64
 8000918:	d8a7      	bhi.n	800086a <HAL_RCC_OscConfig+0x292>
    SET_BIT(PWR->CR, PWR_CR_DBP);

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 800091a:	682b      	ldr	r3, [r5, #0]
 800091c:	05d8      	lsls	r0, r3, #23
 800091e:	d5f7      	bpl.n	8000910 <HAL_RCC_OscConfig+0x338>
        return HAL_TIMEOUT;
      }      
    }
    
    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 8000920:	4ba1      	ldr	r3, [pc, #644]	; (8000ba8 <HAL_RCC_OscConfig+0x5d0>)
 8000922:	f04f 0802 	mov.w	r8, #2
 8000926:	6a1a      	ldr	r2, [r3, #32]
    
    /* Get Start Tick */
    tickstart = HAL_GetTick();
    
    /* Wait till LSE is disabled */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000928:	461d      	mov	r5, r3
        return HAL_TIMEOUT;
      }      
    }
    
    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 800092a:	f022 0201 	bic.w	r2, r2, #1
 800092e:	621a      	str	r2, [r3, #32]
 8000930:	6a1a      	ldr	r2, [r3, #32]
    tickstart = HAL_GetTick();
    
    /* Wait till LSE is disabled */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
    {
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000932:	f241 3788 	movw	r7, #5000	; 0x1388
        return HAL_TIMEOUT;
      }      
    }
    
    /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 8000936:	f022 0204 	bic.w	r2, r2, #4
 800093a:	621a      	str	r2, [r3, #32]
    
    /* Get Start Tick */
    tickstart = HAL_GetTick();
 800093c:	f7ff fd3c 	bl	80003b8 <HAL_GetTick>
 8000940:	4606      	mov	r6, r0
    
    /* Wait till LSE is disabled */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000942:	e010      	b.n	8000966 <HAL_RCC_OscConfig+0x38e>
 8000944:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8000946:	fa98 f3a8 	rbit	r3, r8
 800094a:	fab3 f383 	clz	r3, r3
 800094e:	f003 031f 	and.w	r3, r3, #31
 8000952:	fa22 f303 	lsr.w	r3, r2, r3
 8000956:	07d9      	lsls	r1, r3, #31
 8000958:	f140 80af 	bpl.w	8000aba <HAL_RCC_OscConfig+0x4e2>
    {
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800095c:	f7ff fd2c 	bl	80003b8 <HAL_GetTick>
 8000960:	1b80      	subs	r0, r0, r6
 8000962:	42b8      	cmp	r0, r7
 8000964:	d881      	bhi.n	800086a <HAL_RCC_OscConfig+0x292>
 8000966:	fa98 f3a8 	rbit	r3, r8
 800096a:	fa98 f3a8 	rbit	r3, r8
    
    /* Get Start Tick */
    tickstart = HAL_GetTick();
    
    /* Wait till LSE is disabled */  
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800096e:	2b00      	cmp	r3, #0
 8000970:	d0e8      	beq.n	8000944 <HAL_RCC_OscConfig+0x36c>
 8000972:	6a2a      	ldr	r2, [r5, #32]
 8000974:	e7e7      	b.n	8000946 <HAL_RCC_OscConfig+0x36e>
 8000976:	2301      	movs	r3, #1
 8000978:	fa93 f3a3 	rbit	r3, r3
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800097c:	fab3 f383 	clz	r3, r3
 8000980:	009b      	lsls	r3, r3, #2
 8000982:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8000986:	f503 0384 	add.w	r3, r3, #4325376	; 0x420000
 800098a:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800098c:	f7ff fd14 	bl	80003b8 <HAL_GetTick>
 8000990:	2702      	movs	r7, #2
 8000992:	4606      	mov	r6, r0
        
        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8000994:	4d84      	ldr	r5, [pc, #528]	; (8000ba8 <HAL_RCC_OscConfig+0x5d0>)
 8000996:	e005      	b.n	80009a4 <HAL_RCC_OscConfig+0x3cc>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8000998:	f7ff fd0e 	bl	80003b8 <HAL_GetTick>
 800099c:	1b80      	subs	r0, r0, r6
 800099e:	2802      	cmp	r0, #2
 80009a0:	f63f af63 	bhi.w	800086a <HAL_RCC_OscConfig+0x292>
 80009a4:	fa97 f3a7 	rbit	r3, r7
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80009a8:	682a      	ldr	r2, [r5, #0]
 80009aa:	fa97 f3a7 	rbit	r3, r7
 80009ae:	fab3 f383 	clz	r3, r3
 80009b2:	f003 031f 	and.w	r3, r3, #31
 80009b6:	fa22 f303 	lsr.w	r3, r2, r3
 80009ba:	07d8      	lsls	r0, r3, #31
 80009bc:	d4ec      	bmi.n	8000998 <HAL_RCC_OscConfig+0x3c0>
 80009be:	6823      	ldr	r3, [r4, #0]
 80009c0:	e6bc      	b.n	800073c <HAL_RCC_OscConfig+0x164>
          return HAL_TIMEOUT;
        }
      }
      
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80009c2:	680b      	ldr	r3, [r1, #0]
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80009c4:	460d      	mov	r5, r1
          return HAL_TIMEOUT;
        }
      }
      
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80009c6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80009ca:	600b      	str	r3, [r1, #0]
 80009cc:	680b      	ldr	r3, [r1, #0]
 80009ce:	f44f 3700 	mov.w	r7, #131072	; 0x20000
 80009d2:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80009d6:	600b      	str	r3, [r1, #0]
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80009d8:	f7ff fcee 	bl	80003b8 <HAL_GetTick>
 80009dc:	4606      	mov	r6, r0
        
        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80009de:	e005      	b.n	80009ec <HAL_RCC_OscConfig+0x414>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80009e0:	f7ff fcea 	bl	80003b8 <HAL_GetTick>
 80009e4:	1b80      	subs	r0, r0, r6
 80009e6:	2864      	cmp	r0, #100	; 0x64
 80009e8:	f63f af3f 	bhi.w	800086a <HAL_RCC_OscConfig+0x292>
 80009ec:	fa97 f3a7 	rbit	r3, r7
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80009f0:	682a      	ldr	r2, [r5, #0]
 80009f2:	fa97 f3a7 	rbit	r3, r7
 80009f6:	fab3 f383 	clz	r3, r3
 80009fa:	f003 031f 	and.w	r3, r3, #31
 80009fe:	fa22 f303 	lsr.w	r3, r2, r3
 8000a02:	07db      	lsls	r3, r3, #31
 8000a04:	d4ec      	bmi.n	80009e0 <HAL_RCC_OscConfig+0x408>
 8000a06:	e653      	b.n	80006b0 <HAL_RCC_OscConfig+0xd8>
 8000a08:	fa93 f3a3 	rbit	r3, r3
        /* Check the parameters */
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
  
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8000a0c:	fab3 f383 	clz	r3, r3
 8000a10:	009b      	lsls	r3, r3, #2
 8000a12:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8000a16:	f503 0384 	add.w	r3, r3, #4325376	; 0x420000
 8000a1a:	2200      	movs	r2, #0
 8000a1c:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000a1e:	f7ff fccb 	bl	80003b8 <HAL_GetTick>
 8000a22:	f04f 7700 	mov.w	r7, #33554432	; 0x2000000
 8000a26:	4606      	mov	r6, r0
        
        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000a28:	e005      	b.n	8000a36 <HAL_RCC_OscConfig+0x45e>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000a2a:	f7ff fcc5 	bl	80003b8 <HAL_GetTick>
 8000a2e:	1b80      	subs	r0, r0, r6
 8000a30:	2802      	cmp	r0, #2
 8000a32:	f63f af1a 	bhi.w	800086a <HAL_RCC_OscConfig+0x292>
 8000a36:	fa97 f3a7 	rbit	r3, r7
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8000a3a:	495b      	ldr	r1, [pc, #364]	; (8000ba8 <HAL_RCC_OscConfig+0x5d0>)
 8000a3c:	682a      	ldr	r2, [r5, #0]
 8000a3e:	fa97 f3a7 	rbit	r3, r7
 8000a42:	fab3 f383 	clz	r3, r3
 8000a46:	f003 031f 	and.w	r3, r3, #31
 8000a4a:	fa22 f303 	lsr.w	r3, r2, r3
 8000a4e:	07d8      	lsls	r0, r3, #31
 8000a50:	d4eb      	bmi.n	8000a2a <HAL_RCC_OscConfig+0x452>
          }
        }

        /* Configure the HSE prediv factor --------------------------------*/
        /* It can be written only when the PLL is disabled. Not used in PLL source is different than HSE */
        if(RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
 8000a52:	6a20      	ldr	r0, [r4, #32]
 8000a54:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 8000a58:	f000 8096 	beq.w	8000b88 <HAL_RCC_OscConfig+0x5b0>
          /* Set PREDIV1 Value */
          __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
        }

        /* Configure the main PLL clock source and multiplication factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8000a5c:	4d52      	ldr	r5, [pc, #328]	; (8000ba8 <HAL_RCC_OscConfig+0x5d0>)
 8000a5e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8000a60:	686b      	ldr	r3, [r5, #4]
 8000a62:	4302      	orrs	r2, r0
 8000a64:	f423 1374 	bic.w	r3, r3, #3997696	; 0x3d0000
 8000a68:	4313      	orrs	r3, r2
 8000a6a:	606b      	str	r3, [r5, #4]
 8000a6c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8000a70:	fa93 f3a3 	rbit	r3, r3
                             RCC_OscInitStruct->PLL.PLLMUL);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8000a74:	fab3 f383 	clz	r3, r3
 8000a78:	009b      	lsls	r3, r3, #2
 8000a7a:	f103 4384 	add.w	r3, r3, #1107296256	; 0x42000000
 8000a7e:	f503 0384 	add.w	r3, r3, #4325376	; 0x420000
 8000a82:	2201      	movs	r2, #1
 8000a84:	601a      	str	r2, [r3, #0]
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8000a86:	f7ff fc97 	bl	80003b8 <HAL_GetTick>
 8000a8a:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
 8000a8e:	4606      	mov	r6, r0
        
        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8000a90:	e005      	b.n	8000a9e <HAL_RCC_OscConfig+0x4c6>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8000a92:	f7ff fc91 	bl	80003b8 <HAL_GetTick>
 8000a96:	1b80      	subs	r0, r0, r6
 8000a98:	2802      	cmp	r0, #2
 8000a9a:	f63f aee6 	bhi.w	800086a <HAL_RCC_OscConfig+0x292>
 8000a9e:	fa94 f3a4 	rbit	r3, r4
        
        /* Get Start Tick */
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8000aa2:	682a      	ldr	r2, [r5, #0]
 8000aa4:	fa94 f3a4 	rbit	r3, r4
 8000aa8:	fab3 f383 	clz	r3, r3
 8000aac:	f003 031f 	and.w	r3, r3, #31
 8000ab0:	fa22 f303 	lsr.w	r3, r2, r3
 8000ab4:	07da      	lsls	r2, r3, #31
 8000ab6:	d5ec      	bpl.n	8000a92 <HAL_RCC_OscConfig+0x4ba>
 8000ab8:	e675      	b.n	80007a6 <HAL_RCC_OscConfig+0x1ce>
        return HAL_TIMEOUT;
      }
    }
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000aba:	68e3      	ldr	r3, [r4, #12]
 8000abc:	2b01      	cmp	r3, #1
 8000abe:	d05d      	beq.n	8000b7c <HAL_RCC_OscConfig+0x5a4>
 8000ac0:	b36b      	cbz	r3, 8000b1e <HAL_RCC_OscConfig+0x546>
 8000ac2:	2b05      	cmp	r3, #5
 8000ac4:	4b38      	ldr	r3, [pc, #224]	; (8000ba8 <HAL_RCC_OscConfig+0x5d0>)
 8000ac6:	6a1a      	ldr	r2, [r3, #32]
 8000ac8:	d065      	beq.n	8000b96 <HAL_RCC_OscConfig+0x5be>
 8000aca:	f022 0201 	bic.w	r2, r2, #1
 8000ace:	621a      	str	r2, [r3, #32]
 8000ad0:	6a1a      	ldr	r2, [r3, #32]
 8000ad2:	f022 0204 	bic.w	r2, r2, #4
 8000ad6:	621a      	str	r2, [r3, #32]
    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000ad8:	f7ff fc6e 	bl	80003b8 <HAL_GetTick>
 8000adc:	f04f 0802 	mov.w	r8, #2
 8000ae0:	4607      	mov	r7, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000ae2:	4d31      	ldr	r5, [pc, #196]	; (8000ba8 <HAL_RCC_OscConfig+0x5d0>)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000ae4:	f241 3688 	movw	r6, #5000	; 0x1388
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000ae8:	e011      	b.n	8000b0e <HAL_RCC_OscConfig+0x536>
 8000aea:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8000aec:	fa98 f3a8 	rbit	r3, r8
 8000af0:	fab3 f383 	clz	r3, r3
 8000af4:	f003 031f 	and.w	r3, r3, #31
 8000af8:	fa22 f303 	lsr.w	r3, r2, r3
 8000afc:	07da      	lsls	r2, r3, #31
 8000afe:	f53f ae22 	bmi.w	8000746 <HAL_RCC_OscConfig+0x16e>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000b02:	f7ff fc59 	bl	80003b8 <HAL_GetTick>
 8000b06:	1bc0      	subs	r0, r0, r7
 8000b08:	42b0      	cmp	r0, r6
 8000b0a:	f63f aeae 	bhi.w	800086a <HAL_RCC_OscConfig+0x292>
 8000b0e:	fa98 f3a8 	rbit	r3, r8
 8000b12:	fa98 f3a8 	rbit	r3, r8
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000b16:	2b00      	cmp	r3, #0
 8000b18:	d0e7      	beq.n	8000aea <HAL_RCC_OscConfig+0x512>
 8000b1a:	6a2a      	ldr	r2, [r5, #32]
 8000b1c:	e7e6      	b.n	8000aec <HAL_RCC_OscConfig+0x514>
        return HAL_TIMEOUT;
      }
    }
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000b1e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8000b22:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 8000b26:	6a1a      	ldr	r2, [r3, #32]
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000b28:	461d      	mov	r5, r3
        return HAL_TIMEOUT;
      }
    }
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000b2a:	f022 0201 	bic.w	r2, r2, #1
 8000b2e:	621a      	str	r2, [r3, #32]
 8000b30:	6a1a      	ldr	r2, [r3, #32]
 8000b32:	f04f 0802 	mov.w	r8, #2
 8000b36:	f022 0204 	bic.w	r2, r2, #4
 8000b3a:	621a      	str	r2, [r3, #32]
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000b3c:	f7ff fc3c 	bl	80003b8 <HAL_GetTick>
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000b40:	f241 3788 	movw	r7, #5000	; 0x1388
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000b44:	4606      	mov	r6, r0
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000b46:	e011      	b.n	8000b6c <HAL_RCC_OscConfig+0x594>
 8000b48:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8000b4a:	fa98 f3a8 	rbit	r3, r8
 8000b4e:	fab3 f383 	clz	r3, r3
 8000b52:	f003 031f 	and.w	r3, r3, #31
 8000b56:	fa22 f303 	lsr.w	r3, r2, r3
 8000b5a:	07db      	lsls	r3, r3, #31
 8000b5c:	f57f adf3 	bpl.w	8000746 <HAL_RCC_OscConfig+0x16e>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000b60:	f7ff fc2a 	bl	80003b8 <HAL_GetTick>
 8000b64:	1b80      	subs	r0, r0, r6
 8000b66:	42b8      	cmp	r0, r7
 8000b68:	f63f ae7f 	bhi.w	800086a <HAL_RCC_OscConfig+0x292>
 8000b6c:	fa98 f3a8 	rbit	r3, r8
 8000b70:	fa98 f3a8 	rbit	r3, r8
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8000b74:	2b00      	cmp	r3, #0
 8000b76:	d0e7      	beq.n	8000b48 <HAL_RCC_OscConfig+0x570>
 8000b78:	6a2a      	ldr	r2, [r5, #32]
 8000b7a:	e7e6      	b.n	8000b4a <HAL_RCC_OscConfig+0x572>
        return HAL_TIMEOUT;
      }
    }
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000b7c:	4a0a      	ldr	r2, [pc, #40]	; (8000ba8 <HAL_RCC_OscConfig+0x5d0>)
 8000b7e:	6a13      	ldr	r3, [r2, #32]
 8000b80:	f043 0301 	orr.w	r3, r3, #1
 8000b84:	6213      	str	r3, [r2, #32]
 8000b86:	e7a7      	b.n	8000ad8 <HAL_RCC_OscConfig+0x500>
          /* Set PREDIV1 source */
          SET_BIT(RCC->CFGR2, RCC_OscInitStruct->Prediv1Source);
#endif /* RCC_CFGR2_PREDIV1SRC */

          /* Set PREDIV1 Value */
          __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
 8000b88:	684a      	ldr	r2, [r1, #4]
 8000b8a:	68a3      	ldr	r3, [r4, #8]
 8000b8c:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 8000b90:	4313      	orrs	r3, r2
 8000b92:	604b      	str	r3, [r1, #4]
 8000b94:	e762      	b.n	8000a5c <HAL_RCC_OscConfig+0x484>
        return HAL_TIMEOUT;
      }
    }
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000b96:	f042 0204 	orr.w	r2, r2, #4
 8000b9a:	621a      	str	r2, [r3, #32]
 8000b9c:	6a1a      	ldr	r2, [r3, #32]
 8000b9e:	f042 0201 	orr.w	r2, r2, #1
 8000ba2:	621a      	str	r2, [r3, #32]
 8000ba4:	e798      	b.n	8000ad8 <HAL_RCC_OscConfig+0x500>
 8000ba6:	bf00      	nop
 8000ba8:	40021000 	.word	0x40021000
 8000bac:	40007000 	.word	0x40007000

08000bb0 <HAL_RCC_ClockConfig>:
  must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) of the device. */

#if defined(FLASH_ACR_LATENCY)
  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8000bb0:	4a76      	ldr	r2, [pc, #472]	; (8000d8c <HAL_RCC_ClockConfig+0x1dc>)
  *         You can use @ref HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8000bb2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) of the device. */

#if defined(FLASH_ACR_LATENCY)
  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8000bb6:	6813      	ldr	r3, [r2, #0]
  *         You can use @ref HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8000bb8:	460c      	mov	r4, r1
  must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) of the device. */

#if defined(FLASH_ACR_LATENCY)
  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8000bba:	f003 0307 	and.w	r3, r3, #7
 8000bbe:	428b      	cmp	r3, r1
  *         You can use @ref HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8000bc0:	4605      	mov	r5, r0
  must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) of the device. */

#if defined(FLASH_ACR_LATENCY)
  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8000bc2:	d20c      	bcs.n	8000bde <HAL_RCC_ClockConfig+0x2e>
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000bc4:	6813      	ldr	r3, [r2, #0]
 8000bc6:	f023 0307 	bic.w	r3, r3, #7
 8000bca:	430b      	orrs	r3, r1
 8000bcc:	6013      	str	r3, [r2, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8000bce:	6813      	ldr	r3, [r2, #0]
 8000bd0:	f003 0307 	and.w	r3, r3, #7
 8000bd4:	4299      	cmp	r1, r3
 8000bd6:	d065      	beq.n	8000ca4 <HAL_RCC_ClockConfig+0xf4>
    {
      return HAL_ERROR;
 8000bd8:	2001      	movs	r0, #1
 8000bda:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  /* Decreasing the CPU frequency */
  else
  {
    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8000bde:	6803      	ldr	r3, [r0, #0]
 8000be0:	079e      	lsls	r6, r3, #30
 8000be2:	d506      	bpl.n	8000bf2 <HAL_RCC_ClockConfig+0x42>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8000be4:	486a      	ldr	r0, [pc, #424]	; (8000d90 <HAL_RCC_ClockConfig+0x1e0>)
 8000be6:	68aa      	ldr	r2, [r5, #8]
 8000be8:	6841      	ldr	r1, [r0, #4]
 8000bea:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 8000bee:	430a      	orrs	r2, r1
 8000bf0:	6042      	str	r2, [r0, #4]
    }
    
    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8000bf2:	07d8      	lsls	r0, r3, #31
 8000bf4:	d531      	bpl.n	8000c5a <HAL_RCC_ClockConfig+0xaa>
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000bf6:	686a      	ldr	r2, [r5, #4]
 8000bf8:	2a01      	cmp	r2, #1
 8000bfa:	f000 80b2 	beq.w	8000d62 <HAL_RCC_ClockConfig+0x1b2>
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000bfe:	2a02      	cmp	r2, #2
 8000c00:	bf0c      	ite	eq
 8000c02:	f04f 7300 	moveq.w	r3, #33554432	; 0x2000000
 8000c06:	2302      	movne	r3, #2
 8000c08:	fa93 f1a3 	rbit	r1, r3
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000c0c:	4960      	ldr	r1, [pc, #384]	; (8000d90 <HAL_RCC_ClockConfig+0x1e0>)
 8000c0e:	6809      	ldr	r1, [r1, #0]
 8000c10:	fa93 f3a3 	rbit	r3, r3
 8000c14:	fab3 f383 	clz	r3, r3
 8000c18:	f003 031f 	and.w	r3, r3, #31
 8000c1c:	fa21 f303 	lsr.w	r3, r1, r3
 8000c20:	07d9      	lsls	r1, r3, #31
 8000c22:	d5d9      	bpl.n	8000bd8 <HAL_RCC_ClockConfig+0x28>
        {
          return HAL_ERROR;
        }
      }
      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8000c24:	4e5a      	ldr	r6, [pc, #360]	; (8000d90 <HAL_RCC_ClockConfig+0x1e0>)
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000c26:	f241 3888 	movw	r8, #5000	; 0x1388
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
        {
          return HAL_ERROR;
        }
      }
      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8000c2a:	6873      	ldr	r3, [r6, #4]
 8000c2c:	f023 0303 	bic.w	r3, r3, #3
 8000c30:	431a      	orrs	r2, r3
 8000c32:	6072      	str	r2, [r6, #4]
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000c34:	f7ff fbc0 	bl	80003b8 <HAL_GetTick>
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000c38:	686b      	ldr	r3, [r5, #4]
        }
      }
      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
      
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000c3a:	4607      	mov	r7, r0
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000c3c:	2b01      	cmp	r3, #1
 8000c3e:	d074      	beq.n	8000d2a <HAL_RCC_ClockConfig+0x17a>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000c40:	2b02      	cmp	r3, #2
 8000c42:	d106      	bne.n	8000c52 <HAL_RCC_ClockConfig+0xa2>
 8000c44:	e07c      	b.n	8000d40 <HAL_RCC_ClockConfig+0x190>
      }
      else
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000c46:	f7ff fbb7 	bl	80003b8 <HAL_GetTick>
 8000c4a:	1bc0      	subs	r0, r0, r7
 8000c4c:	4540      	cmp	r0, r8
 8000c4e:	f200 808b 	bhi.w	8000d68 <HAL_RCC_ClockConfig+0x1b8>
          }
        }
      }
      else
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8000c52:	6873      	ldr	r3, [r6, #4]
 8000c54:	f013 0f0c 	tst.w	r3, #12
 8000c58:	d1f5      	bne.n	8000c46 <HAL_RCC_ClockConfig+0x96>
        }
      }      
    } 
    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8000c5a:	4a4c      	ldr	r2, [pc, #304]	; (8000d8c <HAL_RCC_ClockConfig+0x1dc>)
 8000c5c:	6813      	ldr	r3, [r2, #0]
 8000c5e:	f023 0307 	bic.w	r3, r3, #7
 8000c62:	4323      	orrs	r3, r4
 8000c64:	6013      	str	r3, [r2, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8000c66:	6813      	ldr	r3, [r2, #0]
 8000c68:	f003 0307 	and.w	r3, r3, #7
 8000c6c:	429c      	cmp	r4, r3
 8000c6e:	d1b3      	bne.n	8000bd8 <HAL_RCC_ClockConfig+0x28>
 8000c70:	682b      	ldr	r3, [r5, #0]
    }
  }
#endif /* FLASH_ACR_LATENCY */
  
  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8000c72:	075a      	lsls	r2, r3, #29
 8000c74:	d506      	bpl.n	8000c84 <HAL_RCC_ClockConfig+0xd4>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8000c76:	4846      	ldr	r0, [pc, #280]	; (8000d90 <HAL_RCC_ClockConfig+0x1e0>)
 8000c78:	68ea      	ldr	r2, [r5, #12]
 8000c7a:	6841      	ldr	r1, [r0, #4]
 8000c7c:	f421 61e0 	bic.w	r1, r1, #1792	; 0x700
 8000c80:	430a      	orrs	r2, r1
 8000c82:	6042      	str	r2, [r0, #4]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8000c84:	071b      	lsls	r3, r3, #28
 8000c86:	d507      	bpl.n	8000c98 <HAL_RCC_ClockConfig+0xe8>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8000c88:	4a41      	ldr	r2, [pc, #260]	; (8000d90 <HAL_RCC_ClockConfig+0x1e0>)
 8000c8a:	6929      	ldr	r1, [r5, #16]
 8000c8c:	6853      	ldr	r3, [r2, #4]
 8000c8e:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8000c92:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8000c96:	6053      	str	r3, [r2, #4]
  }
 
  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8000c98:	200f      	movs	r0, #15
 8000c9a:	f7ff fb5f 	bl	800035c <HAL_InitTick>
  
  return HAL_OK;
 8000c9e:	2000      	movs	r0, #0
}
 8000ca0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return HAL_ERROR;
    }
    
#endif /* FLASH_ACR_LATENCY */
    /*-------------------------- HCLK Configuration --------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8000ca4:	6803      	ldr	r3, [r0, #0]
 8000ca6:	0799      	lsls	r1, r3, #30
 8000ca8:	d506      	bpl.n	8000cb8 <HAL_RCC_ClockConfig+0x108>
    {
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8000caa:	4839      	ldr	r0, [pc, #228]	; (8000d90 <HAL_RCC_ClockConfig+0x1e0>)
 8000cac:	68aa      	ldr	r2, [r5, #8]
 8000cae:	6841      	ldr	r1, [r0, #4]
 8000cb0:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
 8000cb4:	430a      	orrs	r2, r1
 8000cb6:	6042      	str	r2, [r0, #4]
    }

    /*------------------------- SYSCLK Configuration ---------------------------*/ 
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8000cb8:	07da      	lsls	r2, r3, #31
 8000cba:	d5da      	bpl.n	8000c72 <HAL_RCC_ClockConfig+0xc2>
    {    
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
      
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000cbc:	686a      	ldr	r2, [r5, #4]
 8000cbe:	2a01      	cmp	r2, #1
 8000cc0:	d060      	beq.n	8000d84 <HAL_RCC_ClockConfig+0x1d4>
        {
          return HAL_ERROR;
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000cc2:	2a02      	cmp	r2, #2
 8000cc4:	bf0c      	ite	eq
 8000cc6:	f04f 7300 	moveq.w	r3, #33554432	; 0x2000000
 8000cca:	2302      	movne	r3, #2
 8000ccc:	fa93 f1a3 	rbit	r1, r3
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */  
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8000cd0:	492f      	ldr	r1, [pc, #188]	; (8000d90 <HAL_RCC_ClockConfig+0x1e0>)
 8000cd2:	6809      	ldr	r1, [r1, #0]
 8000cd4:	fa93 f3a3 	rbit	r3, r3
 8000cd8:	fab3 f383 	clz	r3, r3
 8000cdc:	f003 031f 	and.w	r3, r3, #31
 8000ce0:	fa21 f303 	lsr.w	r3, r1, r3
 8000ce4:	07df      	lsls	r7, r3, #31
 8000ce6:	f57f af77 	bpl.w	8000bd8 <HAL_RCC_ClockConfig+0x28>
        {
          return HAL_ERROR;
        }
      }
      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8000cea:	4c29      	ldr	r4, [pc, #164]	; (8000d90 <HAL_RCC_ClockConfig+0x1e0>)
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000cec:	f241 3788 	movw	r7, #5000	; 0x1388
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
        {
          return HAL_ERROR;
        }
      }
      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8000cf0:	6863      	ldr	r3, [r4, #4]
 8000cf2:	f023 0303 	bic.w	r3, r3, #3
 8000cf6:	431a      	orrs	r2, r3
 8000cf8:	6062      	str	r2, [r4, #4]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000cfa:	f7ff fb5d 	bl	80003b8 <HAL_GetTick>
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000cfe:	686b      	ldr	r3, [r5, #4]
        }
      }
      __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8000d00:	4606      	mov	r6, r0
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8000d02:	2b01      	cmp	r3, #1
 8000d04:	d027      	beq.n	8000d56 <HAL_RCC_ClockConfig+0x1a6>
          {
            return HAL_TIMEOUT;
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8000d06:	2b02      	cmp	r3, #2
 8000d08:	d105      	bne.n	8000d16 <HAL_RCC_ClockConfig+0x166>
 8000d0a:	e035      	b.n	8000d78 <HAL_RCC_ClockConfig+0x1c8>
      }
      else
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000d0c:	f7ff fb54 	bl	80003b8 <HAL_GetTick>
 8000d10:	1b80      	subs	r0, r0, r6
 8000d12:	42b8      	cmp	r0, r7
 8000d14:	d828      	bhi.n	8000d68 <HAL_RCC_ClockConfig+0x1b8>
          }
        }
      }
      else
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8000d16:	6863      	ldr	r3, [r4, #4]
 8000d18:	f013 0f0c 	tst.w	r3, #12
 8000d1c:	d1f6      	bne.n	8000d0c <HAL_RCC_ClockConfig+0x15c>
 8000d1e:	e7a7      	b.n	8000c70 <HAL_RCC_ClockConfig+0xc0>
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000d20:	f7ff fb4a 	bl	80003b8 <HAL_GetTick>
 8000d24:	1bc0      	subs	r0, r0, r7
 8000d26:	4540      	cmp	r0, r8
 8000d28:	d81e      	bhi.n	8000d68 <HAL_RCC_ClockConfig+0x1b8>
      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8000d2a:	6873      	ldr	r3, [r6, #4]
 8000d2c:	f003 030c 	and.w	r3, r3, #12
 8000d30:	2b04      	cmp	r3, #4
 8000d32:	d1f5      	bne.n	8000d20 <HAL_RCC_ClockConfig+0x170>
 8000d34:	e791      	b.n	8000c5a <HAL_RCC_ClockConfig+0xaa>
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000d36:	f7ff fb3f 	bl	80003b8 <HAL_GetTick>
 8000d3a:	1bc0      	subs	r0, r0, r7
 8000d3c:	4540      	cmp	r0, r8
 8000d3e:	d813      	bhi.n	8000d68 <HAL_RCC_ClockConfig+0x1b8>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8000d40:	6873      	ldr	r3, [r6, #4]
 8000d42:	f003 030c 	and.w	r3, r3, #12
 8000d46:	2b08      	cmp	r3, #8
 8000d48:	d1f5      	bne.n	8000d36 <HAL_RCC_ClockConfig+0x186>
 8000d4a:	e786      	b.n	8000c5a <HAL_RCC_ClockConfig+0xaa>
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000d4c:	f7ff fb34 	bl	80003b8 <HAL_GetTick>
 8000d50:	1b80      	subs	r0, r0, r6
 8000d52:	42b8      	cmp	r0, r7
 8000d54:	d808      	bhi.n	8000d68 <HAL_RCC_ClockConfig+0x1b8>
      /* Get Start Tick */
      tickstart = HAL_GetTick();
      
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8000d56:	6863      	ldr	r3, [r4, #4]
 8000d58:	f003 030c 	and.w	r3, r3, #12
 8000d5c:	2b04      	cmp	r3, #4
 8000d5e:	d1f5      	bne.n	8000d4c <HAL_RCC_ClockConfig+0x19c>
 8000d60:	e786      	b.n	8000c70 <HAL_RCC_ClockConfig+0xc0>
 8000d62:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8000d66:	e74f      	b.n	8000c08 <HAL_RCC_ClockConfig+0x58>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
          {
            return HAL_TIMEOUT;
 8000d68:	2003      	movs	r0, #3
 8000d6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8000d6e:	f7ff fb23 	bl	80003b8 <HAL_GetTick>
 8000d72:	1b80      	subs	r0, r0, r6
 8000d74:	42b8      	cmp	r0, r7
 8000d76:	d8f7      	bhi.n	8000d68 <HAL_RCC_ClockConfig+0x1b8>
          }
        }
      }
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
      {
        while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8000d78:	6863      	ldr	r3, [r4, #4]
 8000d7a:	f003 030c 	and.w	r3, r3, #12
 8000d7e:	2b08      	cmp	r3, #8
 8000d80:	d1f5      	bne.n	8000d6e <HAL_RCC_ClockConfig+0x1be>
 8000d82:	e775      	b.n	8000c70 <HAL_RCC_ClockConfig+0xc0>
 8000d84:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8000d88:	e7a0      	b.n	8000ccc <HAL_RCC_ClockConfig+0x11c>
 8000d8a:	bf00      	nop
 8000d8c:	40022000 	.word	0x40022000
 8000d90:	40021000 	.word	0x40021000

08000d94 <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *         
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8000d94:	b430      	push	{r4, r5}
#if   defined(RCC_CFGR2_PREDIV1SRC)
  const uint8_t aPLLMULFactorTable[12] = {0, 0, 4,  5,  6,  7,  8,  9, 0, 0, 0, 13};
  const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
#else
  const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 16};
 8000d96:	4d20      	ldr	r5, [pc, #128]	; (8000e18 <HAL_RCC_GetSysClockFreq+0x84>)
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *         
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8000d98:	b086      	sub	sp, #24
#if   defined(RCC_CFGR2_PREDIV1SRC)
  const uint8_t aPLLMULFactorTable[12] = {0, 0, 4,  5,  6,  7,  8,  9, 0, 0, 0, 13};
  const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
#else
  const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 16};
 8000d9a:	6869      	ldr	r1, [r5, #4]
 8000d9c:	68aa      	ldr	r2, [r5, #8]
 8000d9e:	68eb      	ldr	r3, [r5, #12]
 8000da0:	6828      	ldr	r0, [r5, #0]
 8000da2:	ac02      	add	r4, sp, #8
 8000da4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
#if defined(RCC_CFGR2_PREDIV1)
  const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
#else
  const uint8_t aPredivFactorTable[2] = { 1, 2};
 8000da6:	8a2d      	ldrh	r5, [r5, #16]
  uint32_t sysclockfreq = 0;
#if defined(RCC_CFGR2_PREDIV1SRC)
  uint32_t prediv2 = 0, pll2mul = 0;
#endif /*RCC_CFGR2_PREDIV1SRC*/
  
  tmpreg = RCC->CFGR;
 8000da8:	491c      	ldr	r1, [pc, #112]	; (8000e1c <HAL_RCC_GetSysClockFreq+0x88>)
#else
  const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 16};
#if defined(RCC_CFGR2_PREDIV1)
  const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
#else
  const uint8_t aPredivFactorTable[2] = { 1, 2};
 8000daa:	f8ad 5004 	strh.w	r5, [sp, #4]
  uint32_t sysclockfreq = 0;
#if defined(RCC_CFGR2_PREDIV1SRC)
  uint32_t prediv2 = 0, pll2mul = 0;
#endif /*RCC_CFGR2_PREDIV1SRC*/
  
  tmpreg = RCC->CFGR;
 8000dae:	684b      	ldr	r3, [r1, #4]
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 8000db0:	f003 020c 	and.w	r2, r3, #12
 8000db4:	2a08      	cmp	r2, #8
 8000db6:	d114      	bne.n	8000de2 <HAL_RCC_GetSysClockFreq+0x4e>
 8000db8:	f44f 1270 	mov.w	r2, #3932160	; 0x3c0000
 8000dbc:	fa92 f2a2 	rbit	r2, r2
      sysclockfreq = HSE_VALUE;
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> POSITION_VAL(RCC_CFGR_PLLMULL)];
 8000dc0:	fab2 f082 	clz	r0, r2
 8000dc4:	f403 1270 	and.w	r2, r3, #3932160	; 0x3c0000
 8000dc8:	40c2      	lsrs	r2, r0
 8000dca:	a806      	add	r0, sp, #24
 8000dcc:	4402      	add	r2, r0
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 8000dce:	03db      	lsls	r3, r3, #15
      sysclockfreq = HSE_VALUE;
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> POSITION_VAL(RCC_CFGR_PLLMULL)];
 8000dd0:	f812 2c10 	ldrb.w	r2, [r2, #-16]
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 8000dd4:	d409      	bmi.n	8000dea <HAL_RCC_GetSysClockFreq+0x56>
#endif /*RCC_CFGR2_PREDIV1SRC*/
      }
      else
      {
        /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
        pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
 8000dd6:	4812      	ldr	r0, [pc, #72]	; (8000e20 <HAL_RCC_GetSysClockFreq+0x8c>)
 8000dd8:	fb00 f002 	mul.w	r0, r0, r2
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8000ddc:	b006      	add	sp, #24
 8000dde:	bc30      	pop	{r4, r5}
 8000de0:	4770      	bx	lr
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
  {
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 8000de2:	4810      	ldr	r0, [pc, #64]	; (8000e24 <HAL_RCC_GetSysClockFreq+0x90>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8000de4:	b006      	add	sp, #24
 8000de6:	bc30      	pop	{r4, r5}
 8000de8:	4770      	bx	lr
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
      {
#if defined(RCC_CFGR2_PREDIV1)
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> POSITION_VAL(RCC_CFGR2_PREDIV1)];
#else
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> POSITION_VAL(RCC_CFGR_PLLXTPRE)];
 8000dea:	6849      	ldr	r1, [r1, #4]
 8000dec:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8000df0:	fa93 f3a3 	rbit	r3, r3
 8000df4:	fab3 f083 	clz	r0, r3
 8000df8:	f401 3300 	and.w	r3, r1, #131072	; 0x20000
 8000dfc:	40c3      	lsrs	r3, r0
 8000dfe:	a906      	add	r1, sp, #24
 8000e00:	440b      	add	r3, r1
        {
            pllclk = pllclk / 2;
        }
#else
        /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
        pllclk = (uint32_t)((HSE_VALUE / prediv) * pllmul);
 8000e02:	f813 0c14 	ldrb.w	r0, [r3, #-20]
 8000e06:	4b07      	ldr	r3, [pc, #28]	; (8000e24 <HAL_RCC_GetSysClockFreq+0x90>)
 8000e08:	fbb3 f0f0 	udiv	r0, r3, r0
 8000e0c:	fb02 f000 	mul.w	r0, r2, r0
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8000e10:	b006      	add	sp, #24
 8000e12:	bc30      	pop	{r4, r5}
 8000e14:	4770      	bx	lr
 8000e16:	bf00      	nop
 8000e18:	080061c4 	.word	0x080061c4
 8000e1c:	40021000 	.word	0x40021000
 8000e20:	003d0900 	.word	0x003d0900
 8000e24:	007a1200 	.word	0x007a1200

08000e28 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8000e28:	b508      	push	{r3, lr}
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> aAPBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8000e2a:	f7ff ffb3 	bl	8000d94 <HAL_RCC_GetSysClockFreq>
 8000e2e:	4a09      	ldr	r2, [pc, #36]	; (8000e54 <HAL_RCC_GetHCLKFreq+0x2c>)
 8000e30:	23f0      	movs	r3, #240	; 0xf0
 8000e32:	6852      	ldr	r2, [r2, #4]
 8000e34:	fa93 f3a3 	rbit	r3, r3
 8000e38:	fab3 f383 	clz	r3, r3
 8000e3c:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8000e40:	4905      	ldr	r1, [pc, #20]	; (8000e58 <HAL_RCC_GetHCLKFreq+0x30>)
 8000e42:	fa22 f303 	lsr.w	r3, r2, r3
 8000e46:	440b      	add	r3, r1
 8000e48:	7d1a      	ldrb	r2, [r3, #20]
 8000e4a:	4b04      	ldr	r3, [pc, #16]	; (8000e5c <HAL_RCC_GetHCLKFreq+0x34>)
 8000e4c:	40d0      	lsrs	r0, r2
 8000e4e:	6018      	str	r0, [r3, #0]
  return SystemCoreClock;
}
 8000e50:	bd08      	pop	{r3, pc}
 8000e52:	bf00      	nop
 8000e54:	40021000 	.word	0x40021000
 8000e58:	080061c4 	.word	0x080061c4
 8000e5c:	20000000 	.word	0x20000000

08000e60 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8000e60:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> aAPBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 8000e62:	f7ff ffe1 	bl	8000e28 <HAL_RCC_GetHCLKFreq>
 8000e66:	4a08      	ldr	r2, [pc, #32]	; (8000e88 <HAL_RCC_GetPCLK2Freq+0x28>)
 8000e68:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000e6c:	6852      	ldr	r2, [r2, #4]
 8000e6e:	fa93 f3a3 	rbit	r3, r3
 8000e72:	fab3 f383 	clz	r3, r3
 8000e76:	f402 5260 	and.w	r2, r2, #14336	; 0x3800
 8000e7a:	4904      	ldr	r1, [pc, #16]	; (8000e8c <HAL_RCC_GetPCLK2Freq+0x2c>)
 8000e7c:	fa22 f303 	lsr.w	r3, r2, r3
 8000e80:	440b      	add	r3, r1
 8000e82:	7d1b      	ldrb	r3, [r3, #20]
} 
 8000e84:	40d8      	lsrs	r0, r3
 8000e86:	bd08      	pop	{r3, pc}
 8000e88:	40021000 	.word	0x40021000
 8000e8c:	080061c4 	.word	0x080061c4

08000e90 <ADC1_2_IRQHandler>:
  *         preserving the system state for examination by a debugger.
  * @param  None
  * @retval None  
  */
static void Default_Handler(void) 
{
 8000e90:	e7fe      	b.n	8000e90 <ADC1_2_IRQHandler>
 8000e92:	bf00      	nop

08000e94 <Default_Reset_Handler>:
  *         supplied main() routine is called. 
  * @param  None
  * @retval None
  */
void Default_Reset_Handler(void)
{
 8000e94:	b508      	push	{r3, lr}
  unsigned long *pulSrc, *pulDest;

  /* Copy the data segment initializers from flash to SRAM */
  pulSrc = &_sidata;

  for(pulDest = &_sdata; pulDest < &_edata; )
 8000e96:	4a10      	ldr	r2, [pc, #64]	; (8000ed8 <zero_loop+0x16>)
 8000e98:	4b10      	ldr	r3, [pc, #64]	; (8000edc <zero_loop+0x1a>)
 8000e9a:	429a      	cmp	r2, r3
 8000e9c:	d20d      	bcs.n	8000eba <Default_Reset_Handler+0x26>
 8000e9e:	43d0      	mvns	r0, r2
 8000ea0:	490f      	ldr	r1, [pc, #60]	; (8000ee0 <zero_loop+0x1e>)
 8000ea2:	4418      	add	r0, r3
 8000ea4:	460b      	mov	r3, r1
 8000ea6:	f020 0003 	bic.w	r0, r0, #3
 8000eaa:	3004      	adds	r0, #4
 8000eac:	4408      	add	r0, r1
  {
    *(pulDest++) = *(pulSrc++);
 8000eae:	f853 1b04 	ldr.w	r1, [r3], #4
  unsigned long *pulSrc, *pulDest;

  /* Copy the data segment initializers from flash to SRAM */
  pulSrc = &_sidata;

  for(pulDest = &_sdata; pulDest < &_edata; )
 8000eb2:	4283      	cmp	r3, r0
  {
    *(pulDest++) = *(pulSrc++);
 8000eb4:	f842 1b04 	str.w	r1, [r2], #4
  unsigned long *pulSrc, *pulDest;

  /* Copy the data segment initializers from flash to SRAM */
  pulSrc = &_sidata;

  for(pulDest = &_sdata; pulDest < &_edata; )
 8000eb8:	d1f9      	bne.n	8000eae <Default_Reset_Handler+0x1a>
    *(pulDest++) = *(pulSrc++);
  }
  
  /* Zero fill the bss segment.  This is done with inline assembly since this
     will clear the value of pulDest if it is not kept in a register. */
  __asm("  ldr     r0, =_sbss\n"
 8000eba:	480a      	ldr	r0, [pc, #40]	; (8000ee4 <zero_loop+0x22>)
 8000ebc:	490a      	ldr	r1, [pc, #40]	; (8000ee8 <zero_loop+0x26>)
 8000ebe:	f04f 0200 	mov.w	r2, #0

08000ec2 <zero_loop>:
 8000ec2:	4288      	cmp	r0, r1
 8000ec4:	bfb8      	it	lt
 8000ec6:	f840 2b04 	strlt.w	r2, [r0], #4
 8000eca:	dbfa      	blt.n	8000ec2 <zero_loop>
        "    it      lt\n"
        "    strlt   r2, [r0], #4\n"
        "    blt     zero_loop");
  
  /* Setup the microcontroller system. */
  SystemInit();
 8000ecc:	f7ff fb5c 	bl	8000588 <SystemInit>
    
  /* Call the application's entry point.*/
  main();
}
 8000ed0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  
  /* Setup the microcontroller system. */
  SystemInit();
    
  /* Call the application's entry point.*/
  main();
 8000ed4:	f000 bf7e 	b.w	8001dd4 <main>
 8000ed8:	20000000 	.word	0x20000000
 8000edc:	200009a4 	.word	0x200009a4
 8000ee0:	080062e8 	.word	0x080062e8
 8000ee4:	200009a4 	.word	0x200009a4
 8000ee8:	20002818 	.word	0x20002818

08000eec <HAL_ADC_ConfigChannel>:
  * @param  hadc: ADC handle
  * @param  sConfig: Structure of ADC channel for regular group.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{ 
 8000eec:	b4f0      	push	{r4, r5, r6, r7}
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8000eee:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
  * @param  hadc: ADC handle
  * @param  sConfig: Structure of ADC channel for regular group.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{ 
 8000ef2:	b082      	sub	sp, #8
 8000ef4:	4602      	mov	r2, r0
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8000ef6:	2b01      	cmp	r3, #1
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{ 
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  __IO uint32_t wait_loop_index = 0;
 8000ef8:	f04f 0000 	mov.w	r0, #0
 8000efc:	9001      	str	r0, [sp, #4]
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8000efe:	f000 808a 	beq.w	8001016 <HAL_ADC_ConfigChannel+0x12a>
  
  
  /* Regular sequence configuration */
  /* For Rank 1 to 6 */
  if (sConfig->Rank < 7)
 8000f02:	684b      	ldr	r3, [r1, #4]
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8000f04:	2001      	movs	r0, #1
  
  
  /* Regular sequence configuration */
  /* For Rank 1 to 6 */
  if (sConfig->Rank < 7)
 8000f06:	2b06      	cmp	r3, #6
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8000f08:	f882 0024 	strb.w	r0, [r2, #36]	; 0x24
 8000f0c:	f44f 7578 	mov.w	r5, #992	; 0x3e0
  
  /* Regular sequence configuration */
  /* For Rank 1 to 6 */
  if (sConfig->Rank < 7)
  {
    MODIFY_REG(hadc->Instance->SQR3                        ,
 8000f10:	6810      	ldr	r0, [r2, #0]
  __HAL_LOCK(hadc);
  
  
  /* Regular sequence configuration */
  /* For Rank 1 to 6 */
  if (sConfig->Rank < 7)
 8000f12:	d83f      	bhi.n	8000f94 <HAL_ADC_ConfigChannel+0xa8>
  {
    MODIFY_REG(hadc->Instance->SQR3                        ,
 8000f14:	6b47      	ldr	r7, [r0, #52]	; 0x34
 8000f16:	fa95 f6a5 	rbit	r6, r5
 8000f1a:	fab6 f686 	clz	r6, r6
 8000f1e:	3b01      	subs	r3, #1
 8000f20:	680c      	ldr	r4, [r1, #0]
 8000f22:	fa95 f5a5 	rbit	r5, r5
 8000f26:	fab5 f585 	clz	r5, r5
 8000f2a:	fb03 f606 	mul.w	r6, r3, r6
 8000f2e:	fb03 f305 	mul.w	r3, r3, r5
 8000f32:	251f      	movs	r5, #31
 8000f34:	fa05 f606 	lsl.w	r6, r5, r6
 8000f38:	fa04 f303 	lsl.w	r3, r4, r3
 8000f3c:	ea27 0706 	bic.w	r7, r7, r6
 8000f40:	433b      	orrs	r3, r7
 8000f42:	6343      	str	r3, [r0, #52]	; 0x34
  }
  
  
  /* Channel sampling time configuration */
  /* For channels 10 to 17 */
  if (sConfig->Channel >= ADC_CHANNEL_10)
 8000f44:	2c09      	cmp	r4, #9
 8000f46:	d941      	bls.n	8000fcc <HAL_ADC_ConfigChannel+0xe0>
  {
    MODIFY_REG(hadc->Instance->SMPR1                             ,
 8000f48:	68c7      	ldr	r7, [r0, #12]
 8000f4a:	2538      	movs	r5, #56	; 0x38
 8000f4c:	fa95 f6a5 	rbit	r6, r5
 8000f50:	fab6 f686 	clz	r6, r6
 8000f54:	f1a4 030a 	sub.w	r3, r4, #10
 8000f58:	fa95 f5a5 	rbit	r5, r5
 8000f5c:	fab5 f585 	clz	r5, r5
 8000f60:	fb03 f606 	mul.w	r6, r3, r6
 8000f64:	fb03 f305 	mul.w	r3, r3, r5
 8000f68:	6889      	ldr	r1, [r1, #8]
 8000f6a:	2507      	movs	r5, #7
 8000f6c:	fa05 f606 	lsl.w	r6, r5, r6
 8000f70:	fa01 f303 	lsl.w	r3, r1, r3
 8000f74:	ea27 0706 	bic.w	r7, r7, r6
 8000f78:	433b      	orrs	r3, r7
 8000f7a:	60c3      	str	r3, [r0, #12]
               ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel) );
  }
  
  /* If ADC1 Channel_16 or Channel_17 is selected, enable Temperature sensor  */
  /* and VREFINT measurement path.                                            */
  if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) ||
 8000f7c:	f1a4 0310 	sub.w	r3, r4, #16
 8000f80:	2b01      	cmp	r3, #1
 8000f82:	d93f      	bls.n	8001004 <HAL_ADC_ConfigChannel+0x118>
  * @param  sConfig: Structure of ADC channel for regular group.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{ 
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8000f84:	2300      	movs	r3, #0
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
  
  /* Return function status */
  return tmp_hal_status;
 8000f86:	4618      	mov	r0, r3
      tmp_hal_status = HAL_ERROR;
    }
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8000f88:	2100      	movs	r1, #0
 8000f8a:	f882 1024 	strb.w	r1, [r2, #36]	; 0x24
  
  /* Return function status */
  return tmp_hal_status;
}
 8000f8e:	b002      	add	sp, #8
 8000f90:	bcf0      	pop	{r4, r5, r6, r7}
 8000f92:	4770      	bx	lr
    MODIFY_REG(hadc->Instance->SQR3                        ,
               ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank)    ,
               ADC_SQR3_RK(sConfig->Channel, sConfig->Rank) );
  }
  /* For Rank 7 to 12 */
  else if (sConfig->Rank < 13)
 8000f94:	2b0c      	cmp	r3, #12
 8000f96:	d842      	bhi.n	800101e <HAL_ADC_ConfigChannel+0x132>
  {
    MODIFY_REG(hadc->Instance->SQR2                        ,
 8000f98:	6b07      	ldr	r7, [r0, #48]	; 0x30
 8000f9a:	fa95 f6a5 	rbit	r6, r5
 8000f9e:	fab6 f686 	clz	r6, r6
 8000fa2:	3b07      	subs	r3, #7
 8000fa4:	680c      	ldr	r4, [r1, #0]
 8000fa6:	fa95 f5a5 	rbit	r5, r5
 8000faa:	fab5 f585 	clz	r5, r5
 8000fae:	fb03 f606 	mul.w	r6, r3, r6
 8000fb2:	fb03 f305 	mul.w	r3, r3, r5
 8000fb6:	251f      	movs	r5, #31
 8000fb8:	fa05 f606 	lsl.w	r6, r5, r6
 8000fbc:	fa04 f303 	lsl.w	r3, r4, r3
 8000fc0:	ea27 0706 	bic.w	r7, r7, r6
 8000fc4:	433b      	orrs	r3, r7
  }
  
  
  /* Channel sampling time configuration */
  /* For channels 10 to 17 */
  if (sConfig->Channel >= ADC_CHANNEL_10)
 8000fc6:	2c09      	cmp	r4, #9
               ADC_SQR3_RK(sConfig->Channel, sConfig->Rank) );
  }
  /* For Rank 7 to 12 */
  else if (sConfig->Rank < 13)
  {
    MODIFY_REG(hadc->Instance->SQR2                        ,
 8000fc8:	6303      	str	r3, [r0, #48]	; 0x30
  }
  
  
  /* Channel sampling time configuration */
  /* For channels 10 to 17 */
  if (sConfig->Channel >= ADC_CHANNEL_10)
 8000fca:	d8bd      	bhi.n	8000f48 <HAL_ADC_ConfigChannel+0x5c>
               ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel)      ,
               ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel) );
  }
  else /* For channels 0 to 9 */
  {
    MODIFY_REG(hadc->Instance->SMPR2                             ,
 8000fcc:	6906      	ldr	r6, [r0, #16]
 8000fce:	2338      	movs	r3, #56	; 0x38
 8000fd0:	fa93 f5a3 	rbit	r5, r3
 8000fd4:	fab5 f585 	clz	r5, r5
 8000fd8:	fa93 f3a3 	rbit	r3, r3
 8000fdc:	fab3 f383 	clz	r3, r3
 8000fe0:	fb04 f505 	mul.w	r5, r4, r5
 8000fe4:	fb04 f303 	mul.w	r3, r4, r3
 8000fe8:	6889      	ldr	r1, [r1, #8]
 8000fea:	2707      	movs	r7, #7
 8000fec:	fa07 f505 	lsl.w	r5, r7, r5
 8000ff0:	fa01 f303 	lsl.w	r3, r1, r3
 8000ff4:	ea26 0505 	bic.w	r5, r6, r5
 8000ff8:	432b      	orrs	r3, r5
 8000ffa:	6103      	str	r3, [r0, #16]
               ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel) );
  }
  
  /* If ADC1 Channel_16 or Channel_17 is selected, enable Temperature sensor  */
  /* and VREFINT measurement path.                                            */
  if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) ||
 8000ffc:	f1a4 0310 	sub.w	r3, r4, #16
 8001000:	2b01      	cmp	r3, #1
 8001002:	d8bf      	bhi.n	8000f84 <HAL_ADC_ConfigChannel+0x98>
      (sConfig->Channel == ADC_CHANNEL_VREFINT)      )
  {
    /* For STM32F1 devices with several ADC: Only ADC1 can access internal    */
    /* measurement channels (VrefInt/TempSensor). If these channels are       */
    /* intended to be set on other ADC instances, an error is reported.       */
    if (hadc->Instance == ADC1)
 8001004:	4b21      	ldr	r3, [pc, #132]	; (800108c <HAL_ADC_ConfigChannel+0x1a0>)
 8001006:	4298      	cmp	r0, r3
 8001008:	d022      	beq.n	8001050 <HAL_ADC_ConfigChannel+0x164>
      }
    }
    else
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800100a:	6a91      	ldr	r1, [r2, #40]	; 0x28
      
      tmp_hal_status = HAL_ERROR;
 800100c:	2301      	movs	r3, #1
      }
    }
    else
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800100e:	f041 0120 	orr.w	r1, r1, #32
 8001012:	6291      	str	r1, [r2, #40]	; 0x28
 8001014:	e7b7      	b.n	8000f86 <HAL_ADC_ConfigChannel+0x9a>
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8001016:	2002      	movs	r0, #2
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
  
  /* Return function status */
  return tmp_hal_status;
}
 8001018:	b002      	add	sp, #8
 800101a:	bcf0      	pop	{r4, r5, r6, r7}
 800101c:	4770      	bx	lr
               ADC_SQR2_RK(sConfig->Channel, sConfig->Rank) );
  }
  /* For Rank 13 to 16 */
  else
  {
    MODIFY_REG(hadc->Instance->SQR1                        ,
 800101e:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
 8001020:	fa95 f6a5 	rbit	r6, r5
 8001024:	fab6 f686 	clz	r6, r6
 8001028:	3b0d      	subs	r3, #13
 800102a:	680c      	ldr	r4, [r1, #0]
 800102c:	fa95 f5a5 	rbit	r5, r5
 8001030:	fab5 f585 	clz	r5, r5
 8001034:	fb03 f606 	mul.w	r6, r3, r6
 8001038:	fb03 f305 	mul.w	r3, r3, r5
 800103c:	251f      	movs	r5, #31
 800103e:	fa05 f606 	lsl.w	r6, r5, r6
 8001042:	fa04 f303 	lsl.w	r3, r4, r3
 8001046:	ea27 0706 	bic.w	r7, r7, r6
 800104a:	433b      	orrs	r3, r7
 800104c:	62c3      	str	r3, [r0, #44]	; 0x2c
 800104e:	e779      	b.n	8000f44 <HAL_ADC_ConfigChannel+0x58>
    /* For STM32F1 devices with several ADC: Only ADC1 can access internal    */
    /* measurement channels (VrefInt/TempSensor). If these channels are       */
    /* intended to be set on other ADC instances, an error is reported.       */
    if (hadc->Instance == ADC1)
    {
      if (READ_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE) == RESET)
 8001050:	6883      	ldr	r3, [r0, #8]
 8001052:	021b      	lsls	r3, r3, #8
 8001054:	d496      	bmi.n	8000f84 <HAL_ADC_ConfigChannel+0x98>
      {
        SET_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE);
 8001056:	6883      	ldr	r3, [r0, #8]
        
        if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
 8001058:	2c10      	cmp	r4, #16
    /* intended to be set on other ADC instances, an error is reported.       */
    if (hadc->Instance == ADC1)
    {
      if (READ_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE) == RESET)
      {
        SET_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE);
 800105a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800105e:	6083      	str	r3, [r0, #8]
        
        if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
 8001060:	d190      	bne.n	8000f84 <HAL_ADC_ConfigChannel+0x98>
        {
          /* Delay for temperature sensor stabilization time */
          /* Compute number of CPU cycles to wait for */
          wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
 8001062:	4b0b      	ldr	r3, [pc, #44]	; (8001090 <HAL_ADC_ConfigChannel+0x1a4>)
 8001064:	490b      	ldr	r1, [pc, #44]	; (8001094 <HAL_ADC_ConfigChannel+0x1a8>)
 8001066:	681b      	ldr	r3, [r3, #0]
 8001068:	fba1 1303 	umull	r1, r3, r1, r3
 800106c:	0c9b      	lsrs	r3, r3, #18
 800106e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001072:	005b      	lsls	r3, r3, #1
 8001074:	9301      	str	r3, [sp, #4]
          while(wait_loop_index != 0)
 8001076:	9b01      	ldr	r3, [sp, #4]
 8001078:	2b00      	cmp	r3, #0
 800107a:	d083      	beq.n	8000f84 <HAL_ADC_ConfigChannel+0x98>
          {
            wait_loop_index--;
 800107c:	9b01      	ldr	r3, [sp, #4]
 800107e:	3b01      	subs	r3, #1
 8001080:	9301      	str	r3, [sp, #4]
        if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
        {
          /* Delay for temperature sensor stabilization time */
          /* Compute number of CPU cycles to wait for */
          wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
          while(wait_loop_index != 0)
 8001082:	9b01      	ldr	r3, [sp, #4]
 8001084:	2b00      	cmp	r3, #0
 8001086:	d1f9      	bne.n	800107c <HAL_ADC_ConfigChannel+0x190>
 8001088:	e77c      	b.n	8000f84 <HAL_ADC_ConfigChannel+0x98>
 800108a:	bf00      	nop
 800108c:	40012400 	.word	0x40012400
 8001090:	20000000 	.word	0x20000000
 8001094:	431bde83 	.word	0x431bde83

08001098 <ADC_ConversionStop_Disable>:
  *         stopped to disable the ADC.
  * @param  hadc: ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_ConversionStop_Disable(ADC_HandleTypeDef* hadc)
{
 8001098:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart = 0;
  
  /* Verification if ADC is not already disabled */
  if (ADC_IS_ENABLE(hadc) != RESET)
 800109a:	6803      	ldr	r3, [r0, #0]
 800109c:	689a      	ldr	r2, [r3, #8]
 800109e:	07d2      	lsls	r2, r2, #31
 80010a0:	d401      	bmi.n	80010a6 <ADC_ConversionStop_Disable+0xe>
      }
    }
  }
  
  /* Return HAL status */
  return HAL_OK;
 80010a2:	2000      	movs	r0, #0
 80010a4:	bd38      	pop	{r3, r4, r5, pc}
  
  /* Verification if ADC is not already disabled */
  if (ADC_IS_ENABLE(hadc) != RESET)
  {
    /* Disable the ADC peripheral */
    __HAL_ADC_DISABLE(hadc);
 80010a6:	689a      	ldr	r2, [r3, #8]
 80010a8:	4604      	mov	r4, r0
 80010aa:	f022 0201 	bic.w	r2, r2, #1
 80010ae:	609a      	str	r2, [r3, #8]
     
    /* Get tick count */
    tickstart = HAL_GetTick();
 80010b0:	f7ff f982 	bl	80003b8 <HAL_GetTick>
 80010b4:	4605      	mov	r5, r0
    
    /* Wait for ADC effectively disabled */
    while(ADC_IS_ENABLE(hadc) != RESET)
 80010b6:	6823      	ldr	r3, [r4, #0]
 80010b8:	689b      	ldr	r3, [r3, #8]
 80010ba:	07db      	lsls	r3, r3, #31
 80010bc:	d5f1      	bpl.n	80010a2 <ADC_ConversionStop_Disable+0xa>
    {
      if((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 80010be:	f7ff f97b 	bl	80003b8 <HAL_GetTick>
 80010c2:	1b40      	subs	r0, r0, r5
 80010c4:	2802      	cmp	r0, #2
 80010c6:	d9f6      	bls.n	80010b6 <ADC_ConversionStop_Disable+0x1e>
      {
        /* Update ADC state machine to error */
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80010c8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
        
        /* Set ADC error code to ADC IP internal error */
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80010ca:	2001      	movs	r0, #1
    while(ADC_IS_ENABLE(hadc) != RESET)
    {
      if((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
      {
        /* Update ADC state machine to error */
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80010cc:	f043 0310 	orr.w	r3, r3, #16
 80010d0:	62a3      	str	r3, [r4, #40]	; 0x28
        
        /* Set ADC error code to ADC IP internal error */
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80010d2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80010d4:	4303      	orrs	r3, r0
 80010d6:	62e3      	str	r3, [r4, #44]	; 0x2c
 80010d8:	bd38      	pop	{r3, r4, r5, pc}
 80010da:	bf00      	nop

080010dc <HAL_ADC_Init>:
  uint32_t tmp_cr1 = 0;
  uint32_t tmp_cr2 = 0;
  uint32_t tmp_sqr1 = 0;
  
  /* Check ADC handle */
  if(hadc == NULL)
 80010dc:	2800      	cmp	r0, #0
 80010de:	d06f      	beq.n	80011c0 <HAL_ADC_Init+0xe4>
  /* Refer to header of this file for more details on clock enabling          */
  /* procedure.                                                               */

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 80010e0:	6a83      	ldr	r3, [r0, #40]	; 0x28
  *         of structure "ADC_InitTypeDef".
  * @param  hadc: ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
 80010e2:	b570      	push	{r4, r5, r6, lr}
 80010e4:	4604      	mov	r4, r0
  /* Refer to header of this file for more details on clock enabling          */
  /* procedure.                                                               */

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 80010e6:	2b00      	cmp	r3, #0
 80010e8:	d04a      	beq.n	8001180 <HAL_ADC_Init+0xa4>
  /* Stop potential conversion on going, on regular and injected groups */
  /* Disable ADC peripheral */
  /* Note: In case of ADC already enabled, precaution to not launch an        */
  /*       unwanted conversion while modifying register CR2 by writing 1 to   */
  /*       bit ADON.                                                          */
  tmp_hal_status = ADC_ConversionStop_Disable(hadc);
 80010ea:	4620      	mov	r0, r4
 80010ec:	f7ff ffd4 	bl	8001098 <ADC_ConversionStop_Disable>
  
  
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed.                                                     */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
 80010f0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80010f2:	f013 0f10 	tst.w	r3, #16
      (tmp_hal_status == HAL_OK)                                  )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 80010f6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  tmp_hal_status = ADC_ConversionStop_Disable(hadc);
  
  
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed.                                                     */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
 80010f8:	d13d      	bne.n	8001176 <HAL_ADC_Init+0x9a>
 80010fa:	2800      	cmp	r0, #0
 80010fc:	d13b      	bne.n	8001176 <HAL_ADC_Init+0x9a>
      (tmp_hal_status == HAL_OK)                                  )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 80010fe:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 8001102:	f023 0302 	bic.w	r3, r3, #2
 8001106:	f043 0302 	orr.w	r3, r3, #2
    /*       HAL_ADC_Start_xxx functions because if set in this function,     */
    /*       a conversion on injected group would start a conversion also on  */
    /*       regular group after ADC enabling.                                */
    tmp_cr2 |= (hadc->Init.DataAlign                               |
                ADC_CFGR_EXTSEL(hadc, hadc->Init.ExternalTrigConv) |
                ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode)   );
 800110a:	68e5      	ldr	r5, [r4, #12]
  /* correctly completed.                                                     */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
      (tmp_hal_status == HAL_OK)                                  )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 800110c:	62a3      	str	r3, [r4, #40]	; 0x28
 800110e:	2202      	movs	r2, #2
 8001110:	fa92 f2a2 	rbit	r2, r2
    /*       HAL_ADC_Start_xxx functions because if set in this function,     */
    /*       a conversion on injected group would start a conversion also on  */
    /*       regular group after ADC enabling.                                */
    tmp_cr2 |= (hadc->Init.DataAlign                               |
                ADC_CFGR_EXTSEL(hadc, hadc->Init.ExternalTrigConv) |
                ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode)   );
 8001114:	fab2 f282 	clz	r2, r2
    /* Note: External trigger polarity (ADC_CR2_EXTTRIG) is set into          */
    /*       HAL_ADC_Start_xxx functions because if set in this function,     */
    /*       a conversion on injected group would start a conversion also on  */
    /*       regular group after ADC enabling.                                */
    tmp_cr2 |= (hadc->Init.DataAlign                               |
                ADC_CFGR_EXTSEL(hadc, hadc->Init.ExternalTrigConv) |
 8001118:	6866      	ldr	r6, [r4, #4]
 800111a:	69e3      	ldr	r3, [r4, #28]
    
    /* Configuration of ADC:                                                  */
    /*  - scan mode                                                           */
    /*  - discontinuous mode disable/enable                                   */
    /*  - discontinuous mode number of conversions                            */
    tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
 800111c:	68a1      	ldr	r1, [r4, #8]
    /* Note: External trigger polarity (ADC_CR2_EXTTRIG) is set into          */
    /*       HAL_ADC_Start_xxx functions because if set in this function,     */
    /*       a conversion on injected group would start a conversion also on  */
    /*       regular group after ADC enabling.                                */
    tmp_cr2 |= (hadc->Init.DataAlign                               |
                ADC_CFGR_EXTSEL(hadc, hadc->Init.ExternalTrigConv) |
 800111e:	fa05 f202 	lsl.w	r2, r5, r2
 8001122:	4333      	orrs	r3, r6
    
    /* Configuration of ADC:                                                  */
    /*  - scan mode                                                           */
    /*  - discontinuous mode disable/enable                                   */
    /*  - discontinuous mode number of conversions                            */
    tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
 8001124:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
    /* Note: External trigger polarity (ADC_CR2_EXTTRIG) is set into          */
    /*       HAL_ADC_Start_xxx functions because if set in this function,     */
    /*       a conversion on injected group would start a conversion also on  */
    /*       regular group after ADC enabling.                                */
    tmp_cr2 |= (hadc->Init.DataAlign                               |
                ADC_CFGR_EXTSEL(hadc, hadc->Init.ExternalTrigConv) |
 8001128:	ea43 0302 	orr.w	r3, r3, r2
    
    /* Configuration of ADC:                                                  */
    /*  - scan mode                                                           */
    /*  - discontinuous mode disable/enable                                   */
    /*  - discontinuous mode number of conversions                            */
    tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
 800112c:	d02e      	beq.n	800118c <HAL_ADC_Init+0xb0>
 800112e:	2901      	cmp	r1, #1
 8001130:	d051      	beq.n	80011d6 <HAL_ADC_Init+0xfa>
    
    /* Enable discontinuous mode only if continuous mode is disabled */
    /* Note: If parameter "Init.ScanConvMode" is set to disable, parameter    */
    /*       discontinuous is set anyway, but will have no effect on ADC HW.  */
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8001132:	6962      	ldr	r2, [r4, #20]
 8001134:	2a01      	cmp	r2, #1
 8001136:	d054      	beq.n	80011e2 <HAL_ADC_Init+0x106>
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
      }
    }
    
    /* Update ADC configuration register CR1 with previous settings */
      MODIFY_REG(hadc->Instance->CR1,
 8001138:	6822      	ldr	r2, [r4, #0]
                 ADC_CR1_DISCEN  |
                 ADC_CR1_DISCNUM    ,
                 tmp_cr1             );
    
    /* Update ADC configuration register CR2 with previous settings */
      MODIFY_REG(hadc->Instance->CR2,
 800113a:	4941      	ldr	r1, [pc, #260]	; (8001240 <HAL_ADC_Init+0x164>)
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
      }
    }
    
    /* Update ADC configuration register CR1 with previous settings */
      MODIFY_REG(hadc->Instance->CR1,
 800113c:	6855      	ldr	r5, [r2, #4]
 800113e:	f425 4569 	bic.w	r5, r5, #59648	; 0xe900
 8001142:	6055      	str	r5, [r2, #4]
                 ADC_CR1_DISCEN  |
                 ADC_CR1_DISCNUM    ,
                 tmp_cr1             );
    
    /* Update ADC configuration register CR2 with previous settings */
      MODIFY_REG(hadc->Instance->CR2,
 8001144:	6895      	ldr	r5, [r2, #8]
 8001146:	4029      	ands	r1, r5
 8001148:	4319      	orrs	r1, r3
 800114a:	6091      	str	r1, [r2, #8]
    if (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode) == ADC_SCAN_ENABLE)
    {
      tmp_sqr1 = ADC_SQR1_L_SHIFT(hadc->Init.NbrOfConversion);
    }
      
    MODIFY_REG(hadc->Instance->SQR1,
 800114c:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
    /* ensure of no potential problem of ADC core IP clocking.                */
    /* Check through register CR2 (excluding bits set in other functions:     */
    /* execution control bits (ADON, JSWSTART, SWSTART), regular group bits   */
    /* (DMA), injected group bits (JEXTTRIG and JEXTSEL), channel internal    */
    /* measurement path bit (TSVREFE).                                        */
    if (READ_BIT(hadc->Instance->CR2, ~(ADC_CR2_ADON | ADC_CR2_DMA |
 800114e:	493d      	ldr	r1, [pc, #244]	; (8001244 <HAL_ADC_Init+0x168>)
    if (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode) == ADC_SCAN_ENABLE)
    {
      tmp_sqr1 = ADC_SQR1_L_SHIFT(hadc->Init.NbrOfConversion);
    }
      
    MODIFY_REG(hadc->Instance->SQR1,
 8001150:	f425 0570 	bic.w	r5, r5, #15728640	; 0xf00000
 8001154:	4328      	orrs	r0, r5
 8001156:	62d0      	str	r0, [r2, #44]	; 0x2c
    /* ensure of no potential problem of ADC core IP clocking.                */
    /* Check through register CR2 (excluding bits set in other functions:     */
    /* execution control bits (ADON, JSWSTART, SWSTART), regular group bits   */
    /* (DMA), injected group bits (JEXTTRIG and JEXTSEL), channel internal    */
    /* measurement path bit (TSVREFE).                                        */
    if (READ_BIT(hadc->Instance->CR2, ~(ADC_CR2_ADON | ADC_CR2_DMA |
 8001158:	6892      	ldr	r2, [r2, #8]
 800115a:	4011      	ands	r1, r2
 800115c:	428b      	cmp	r3, r1
 800115e:	d031      	beq.n	80011c4 <HAL_ADC_Init+0xe8>
                        HAL_ADC_STATE_READY);
    }
    else
    {
      /* Update ADC state machine to error */
      ADC_STATE_CLR_SET(hadc->State,
 8001160:	6aa3      	ldr	r3, [r4, #40]	; 0x28
                        HAL_ADC_STATE_ERROR_INTERNAL);
      
      /* Set ADC error code to ADC IP internal error */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
      
      tmp_hal_status = HAL_ERROR;
 8001162:	2001      	movs	r0, #1
                        HAL_ADC_STATE_READY);
    }
    else
    {
      /* Update ADC state machine to error */
      ADC_STATE_CLR_SET(hadc->State,
 8001164:	f023 0312 	bic.w	r3, r3, #18
 8001168:	f043 0310 	orr.w	r3, r3, #16
 800116c:	62a3      	str	r3, [r4, #40]	; 0x28
                        HAL_ADC_STATE_BUSY_INTERNAL,
                        HAL_ADC_STATE_ERROR_INTERNAL);
      
      /* Set ADC error code to ADC IP internal error */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800116e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001170:	4303      	orrs	r3, r0
 8001172:	62e3      	str	r3, [r4, #44]	; 0x2c
 8001174:	bd70      	pop	{r4, r5, r6, pc}
  
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001176:	f043 0310 	orr.w	r3, r3, #16
        
    tmp_hal_status = HAL_ERROR;
 800117a:	2001      	movs	r0, #1
  
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800117c:	62a3      	str	r3, [r4, #40]	; 0x28
 800117e:	bd70      	pop	{r4, r5, r6, pc}
  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
  {
    /* Initialize ADC error code */
    ADC_CLEAR_ERRORCODE(hadc);
 8001180:	62c3      	str	r3, [r0, #44]	; 0x2c
    
    /* Allocate lock resource and initialize it */
    hadc->Lock = HAL_UNLOCKED;
 8001182:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8001186:	f002 ff2d 	bl	8003fe4 <HAL_ADC_MspInit>
 800118a:	e7ae      	b.n	80010ea <HAL_ADC_Init+0xe>
    tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
    
    /* Enable discontinuous mode only if continuous mode is disabled */
    /* Note: If parameter "Init.ScanConvMode" is set to disable, parameter    */
    /*       discontinuous is set anyway, but will have no effect on ADC HW.  */
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 800118c:	6962      	ldr	r2, [r4, #20]
 800118e:	2a01      	cmp	r2, #1
 8001190:	d052      	beq.n	8001238 <HAL_ADC_Init+0x15c>
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
      }
    }
    
    /* Update ADC configuration register CR1 with previous settings */
      MODIFY_REG(hadc->Instance->CR1,
 8001192:	6822      	ldr	r2, [r4, #0]
                 ADC_CR1_DISCEN  |
                 ADC_CR1_DISCNUM    ,
                 tmp_cr1             );
    
    /* Update ADC configuration register CR2 with previous settings */
      MODIFY_REG(hadc->Instance->CR2,
 8001194:	492a      	ldr	r1, [pc, #168]	; (8001240 <HAL_ADC_Init+0x164>)
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
      }
    }
    
    /* Update ADC configuration register CR1 with previous settings */
      MODIFY_REG(hadc->Instance->CR1,
 8001196:	6850      	ldr	r0, [r2, #4]
 8001198:	f420 4069 	bic.w	r0, r0, #59648	; 0xe900
 800119c:	f440 7080 	orr.w	r0, r0, #256	; 0x100
 80011a0:	6050      	str	r0, [r2, #4]
                 ADC_CR1_DISCEN  |
                 ADC_CR1_DISCNUM    ,
                 tmp_cr1             );
    
    /* Update ADC configuration register CR2 with previous settings */
      MODIFY_REG(hadc->Instance->CR2,
 80011a2:	6890      	ldr	r0, [r2, #8]
 80011a4:	4001      	ands	r1, r0
 80011a6:	4319      	orrs	r1, r3
 80011a8:	6091      	str	r1, [r2, #8]
 80011aa:	f44f 0070 	mov.w	r0, #15728640	; 0xf00000
 80011ae:	fa90 f0a0 	rbit	r0, r0
    /*   conversions is forced to 0x00 for alignment over all STM32 devices.  */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion"                                          */
    if (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode) == ADC_SCAN_ENABLE)
    {
      tmp_sqr1 = ADC_SQR1_L_SHIFT(hadc->Init.NbrOfConversion);
 80011b2:	fab0 f080 	clz	r0, r0
 80011b6:	6921      	ldr	r1, [r4, #16]
 80011b8:	3901      	subs	r1, #1
 80011ba:	fa01 f000 	lsl.w	r0, r1, r0
 80011be:	e7c5      	b.n	800114c <HAL_ADC_Init+0x70>
  uint32_t tmp_sqr1 = 0;
  
  /* Check ADC handle */
  if(hadc == NULL)
  {
    return HAL_ERROR;
 80011c0:	2001      	movs	r0, #1
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Return function status */
  return tmp_hal_status;
}
 80011c2:	4770      	bx	lr
                                        ADC_CR2_JEXTTRIG | ADC_CR2_JEXTSEL |
                                        ADC_CR2_TSVREFE                     ))
         == tmp_cr2)
    {
      /* Set ADC error code to none */
      ADC_CLEAR_ERRORCODE(hadc);
 80011c4:	2000      	movs	r0, #0
 80011c6:	62e0      	str	r0, [r4, #44]	; 0x2c
      
      /* Set the ADC state */
      ADC_STATE_CLR_SET(hadc->State,
 80011c8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80011ca:	f023 0303 	bic.w	r3, r3, #3
 80011ce:	f043 0301 	orr.w	r3, r3, #1
 80011d2:	62a3      	str	r3, [r4, #40]	; 0x28
 80011d4:	bd70      	pop	{r4, r5, r6, pc}
    tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
    
    /* Enable discontinuous mode only if continuous mode is disabled */
    /* Note: If parameter "Init.ScanConvMode" is set to disable, parameter    */
    /*       discontinuous is set anyway, but will have no effect on ADC HW.  */
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 80011d6:	6962      	ldr	r2, [r4, #20]
 80011d8:	2a01      	cmp	r2, #1
    
    /* Configuration of ADC:                                                  */
    /*  - scan mode                                                           */
    /*  - discontinuous mode disable/enable                                   */
    /*  - discontinuous mode number of conversions                            */
    tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
 80011da:	bf08      	it	eq
 80011dc:	f44f 7080 	moveq.w	r0, #256	; 0x100
    
    /* Enable discontinuous mode only if continuous mode is disabled */
    /* Note: If parameter "Init.ScanConvMode" is set to disable, parameter    */
    /*       discontinuous is set anyway, but will have no effect on ADC HW.  */
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 80011e0:	d1d7      	bne.n	8001192 <HAL_ADC_Init+0xb6>
    {
      if (hadc->Init.ContinuousConvMode == DISABLE)
 80011e2:	b1e5      	cbz	r5, 800121e <HAL_ADC_Init+0x142>
      {
        /* ADC regular group settings continuous and sequencer discontinuous*/
        /* cannot be enabled simultaneously.                                */
        
        /* Update ADC state machine to error */
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80011e4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80011e6:	f042 0220 	orr.w	r2, r2, #32
 80011ea:	62a2      	str	r2, [r4, #40]	; 0x28
        
        /* Set ADC error code to ADC IP internal error */
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80011ec:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80011ee:	f042 0201 	orr.w	r2, r2, #1
 80011f2:	62e2      	str	r2, [r4, #44]	; 0x2c
      }
    }
    
    /* Update ADC configuration register CR1 with previous settings */
      MODIFY_REG(hadc->Instance->CR1,
 80011f4:	6822      	ldr	r2, [r4, #0]
                 ADC_CR1_DISCEN  |
                 ADC_CR1_DISCNUM    ,
                 tmp_cr1             );
    
    /* Update ADC configuration register CR2 with previous settings */
      MODIFY_REG(hadc->Instance->CR2,
 80011f6:	4d12      	ldr	r5, [pc, #72]	; (8001240 <HAL_ADC_Init+0x164>)
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
      }
    }
    
    /* Update ADC configuration register CR1 with previous settings */
      MODIFY_REG(hadc->Instance->CR1,
 80011f8:	6856      	ldr	r6, [r2, #4]
    /*   Note: Scan mode is present by hardware on this device and, if        */
    /*   disabled, discards automatically nb of conversions. Anyway, nb of    */
    /*   conversions is forced to 0x00 for alignment over all STM32 devices.  */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion"                                          */
    if (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode) == ADC_SCAN_ENABLE)
 80011fa:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
      }
    }
    
    /* Update ADC configuration register CR1 with previous settings */
      MODIFY_REG(hadc->Instance->CR1,
 80011fe:	f426 4669 	bic.w	r6, r6, #59648	; 0xe900
 8001202:	ea40 0006 	orr.w	r0, r0, r6
 8001206:	6050      	str	r0, [r2, #4]
                 ADC_CR1_DISCEN  |
                 ADC_CR1_DISCNUM    ,
                 tmp_cr1             );
    
    /* Update ADC configuration register CR2 with previous settings */
      MODIFY_REG(hadc->Instance->CR2,
 8001208:	6890      	ldr	r0, [r2, #8]
 800120a:	ea05 0500 	and.w	r5, r5, r0
 800120e:	ea45 0503 	orr.w	r5, r5, r3
 8001212:	6095      	str	r5, [r2, #8]
    /*   Note: Scan mode is present by hardware on this device and, if        */
    /*   disabled, discards automatically nb of conversions. Anyway, nb of    */
    /*   conversions is forced to 0x00 for alignment over all STM32 devices.  */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion"                                          */
    if (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode) == ADC_SCAN_ENABLE)
 8001214:	d0c9      	beq.n	80011aa <HAL_ADC_Init+0xce>
 8001216:	2901      	cmp	r1, #1
 8001218:	d0c7      	beq.n	80011aa <HAL_ADC_Init+0xce>
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmp_cr1 = 0;
  uint32_t tmp_cr2 = 0;
  uint32_t tmp_sqr1 = 0;
 800121a:	2000      	movs	r0, #0
 800121c:	e796      	b.n	800114c <HAL_ADC_Init+0x70>
 800121e:	f44f 4260 	mov.w	r2, #57344	; 0xe000
 8001222:	fa92 f2a2 	rbit	r2, r2
    {
      if (hadc->Init.ContinuousConvMode == DISABLE)
      {
        /* Enable the selected ADC regular discontinuous mode */
        /* Set the number of channels to be converted in discontinuous mode */
        SET_BIT(tmp_cr1, ADC_CR1_DISCEN                                            |
 8001226:	fab2 f582 	clz	r5, r2
 800122a:	69a2      	ldr	r2, [r4, #24]
 800122c:	f440 6000 	orr.w	r0, r0, #2048	; 0x800
 8001230:	3a01      	subs	r2, #1
 8001232:	40aa      	lsls	r2, r5
 8001234:	4310      	orrs	r0, r2
 8001236:	e7dd      	b.n	80011f4 <HAL_ADC_Init+0x118>
    
    /* Configuration of ADC:                                                  */
    /*  - scan mode                                                           */
    /*  - discontinuous mode disable/enable                                   */
    /*  - discontinuous mode number of conversions                            */
    tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
 8001238:	4608      	mov	r0, r1
    /* Enable discontinuous mode only if continuous mode is disabled */
    /* Note: If parameter "Init.ScanConvMode" is set to disable, parameter    */
    /*       discontinuous is set anyway, but will have no effect on ADC HW.  */
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
    {
      if (hadc->Init.ContinuousConvMode == DISABLE)
 800123a:	2d00      	cmp	r5, #0
 800123c:	d1d2      	bne.n	80011e4 <HAL_ADC_Init+0x108>
 800123e:	e7ee      	b.n	800121e <HAL_ADC_Init+0x142>
 8001240:	ffe1f7fd 	.word	0xffe1f7fd
 8001244:	ff1f0efe 	.word	0xff1f0efe

08001248 <HAL_PCD_Init>:
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
  uint32_t index = 0;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 8001248:	2800      	cmp	r0, #0
 800124a:	d069      	beq.n	8001320 <HAL_PCD_Init+0xd8>
  *         parameters in the PCD_InitTypeDef and create the associated handle.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 800124c:	b5f0      	push	{r4, r5, r6, r7, lr}
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  if(hpcd->State == HAL_PCD_STATE_RESET)
 800124e:	f890 33e9 	ldrb.w	r3, [r0, #1001]	; 0x3e9
  *         parameters in the PCD_InitTypeDef and create the associated handle.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 8001252:	b087      	sub	sp, #28
 8001254:	4604      	mov	r4, r0
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  if(hpcd->State == HAL_PCD_STATE_RESET)
 8001256:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800125a:	2b00      	cmp	r3, #0
 800125c:	d05b      	beq.n	8001316 <HAL_PCD_Init+0xce>
  
  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
  
  /*Init the Core (common init.) */
  USB_CoreInit(hpcd->Instance, hpcd->Init);
 800125e:	4625      	mov	r5, r4

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
  }
  
  hpcd->State = HAL_PCD_STATE_BUSY;
 8001260:	2303      	movs	r3, #3
 8001262:	f884 33e9 	strb.w	r3, [r4, #1001]	; 0x3e9
  
  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 8001266:	6820      	ldr	r0, [r4, #0]
 8001268:	f001 f910 	bl	800248c <USB_DisableGlobalInt>
  
  /*Init the Core (common init.) */
  USB_CoreInit(hpcd->Instance, hpcd->Init);
 800126c:	f855 eb10 	ldr.w	lr, [r5], #16
 8001270:	466f      	mov	r7, sp
 8001272:	462e      	mov	r6, r5
 8001274:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8001276:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 8001278:	6833      	ldr	r3, [r6, #0]
 800127a:	1d26      	adds	r6, r4, #4
 800127c:	603b      	str	r3, [r7, #0]
 800127e:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
 8001282:	4670      	mov	r0, lr
 8001284:	f001 f8f0 	bl	8002468 <USB_CoreInit>
 
  /* Force Device Mode*/
  USB_SetCurrentMode(hpcd->Instance , USB_DEVICE_MODE);
 8001288:	2100      	movs	r1, #0
 800128a:	6820      	ldr	r0, [r4, #0]
 800128c:	f001 f908 	bl	80024a0 <USB_SetCurrentMode>
 
  /* Init endpoints structures */
  for (index = 0; index < 15 ; index++)
 8001290:	2100      	movs	r1, #0
    /* Init ep structure */
    hpcd->IN_ep[index].is_in = 1;
    hpcd->IN_ep[index].num = index;
    hpcd->IN_ep[index].tx_fifo_num = index;
    /* Control until ep is actvated */
    hpcd->IN_ep[index].type = EP_TYPE_CTRL;
 8001292:	4608      	mov	r0, r1
 8001294:	4623      	mov	r3, r4
  
  /*Init the Core (common init.) */
  USB_CoreInit(hpcd->Instance, hpcd->Init);
 
  /* Force Device Mode*/
  USB_SetCurrentMode(hpcd->Instance , USB_DEVICE_MODE);
 8001296:	4622      	mov	r2, r4
 
  /* Init endpoints structures */
  for (index = 0; index < 15 ; index++)
  {
    /* Init ep structure */
    hpcd->IN_ep[index].is_in = 1;
 8001298:	2701      	movs	r7, #1
    hpcd->IN_ep[index].num = index;
 800129a:	f882 1028 	strb.w	r1, [r2, #40]	; 0x28
    hpcd->IN_ep[index].tx_fifo_num = index;
 800129e:	8691      	strh	r1, [r2, #52]	; 0x34
 
  /* Force Device Mode*/
  USB_SetCurrentMode(hpcd->Instance , USB_DEVICE_MODE);
 
  /* Init endpoints structures */
  for (index = 0; index < 15 ; index++)
 80012a0:	3101      	adds	r1, #1
 80012a2:	290f      	cmp	r1, #15
  {
    /* Init ep structure */
    hpcd->IN_ep[index].is_in = 1;
 80012a4:	f882 7029 	strb.w	r7, [r2, #41]	; 0x29
    hpcd->IN_ep[index].num = index;
    hpcd->IN_ep[index].tx_fifo_num = index;
    /* Control until ep is actvated */
    hpcd->IN_ep[index].type = EP_TYPE_CTRL;
 80012a8:	f882 002b 	strb.w	r0, [r2, #43]	; 0x2b
    hpcd->IN_ep[index].maxpacket =  0;
 80012ac:	6390      	str	r0, [r2, #56]	; 0x38
    hpcd->IN_ep[index].xfer_buff = 0;
 80012ae:	63d0      	str	r0, [r2, #60]	; 0x3c
    hpcd->IN_ep[index].xfer_len = 0;
 80012b0:	6410      	str	r0, [r2, #64]	; 0x40
 80012b2:	f102 0220 	add.w	r2, r2, #32
 
  /* Force Device Mode*/
  USB_SetCurrentMode(hpcd->Instance , USB_DEVICE_MODE);
 
  /* Init endpoints structures */
  for (index = 0; index < 15 ; index++)
 80012b6:	d1f0      	bne.n	800129a <HAL_PCD_Init+0x52>
 80012b8:	2200      	movs	r2, #0
    hpcd->IN_ep[index].xfer_len = 0;
  }
  
  for (index = 0; index < 15 ; index++)
  {
    hpcd->OUT_ep[index].is_in = 0;
 80012ba:	4611      	mov	r1, r2
    hpcd->OUT_ep[index].num = index;
 80012bc:	f883 2208 	strb.w	r2, [r3, #520]	; 0x208
    hpcd->IN_ep[index].tx_fifo_num = index;
 80012c0:	869a      	strh	r2, [r3, #52]	; 0x34
    hpcd->IN_ep[index].maxpacket =  0;
    hpcd->IN_ep[index].xfer_buff = 0;
    hpcd->IN_ep[index].xfer_len = 0;
  }
  
  for (index = 0; index < 15 ; index++)
 80012c2:	3201      	adds	r2, #1
 80012c4:	2a0f      	cmp	r2, #15
  {
    hpcd->OUT_ep[index].is_in = 0;
 80012c6:	f883 1209 	strb.w	r1, [r3, #521]	; 0x209
    hpcd->OUT_ep[index].num = index;
    hpcd->IN_ep[index].tx_fifo_num = index;
    /* Control until ep is activated */
    hpcd->OUT_ep[index].type = EP_TYPE_CTRL;
 80012ca:	f883 120b 	strb.w	r1, [r3, #523]	; 0x20b
    hpcd->OUT_ep[index].maxpacket = 0;
 80012ce:	f8c3 1218 	str.w	r1, [r3, #536]	; 0x218
    hpcd->OUT_ep[index].xfer_buff = 0;
 80012d2:	f8c3 121c 	str.w	r1, [r3, #540]	; 0x21c
    hpcd->OUT_ep[index].xfer_len = 0;
 80012d6:	f8c3 1220 	str.w	r1, [r3, #544]	; 0x220
    hpcd->IN_ep[index].xfer_len = 0;
  }
  
  for (index = 0; index < 15 ; index++)
  {
    hpcd->OUT_ep[index].is_in = 0;
 80012da:	f04f 0700 	mov.w	r7, #0
 80012de:	f103 0320 	add.w	r3, r3, #32
    hpcd->IN_ep[index].maxpacket =  0;
    hpcd->IN_ep[index].xfer_buff = 0;
    hpcd->IN_ep[index].xfer_len = 0;
  }
  
  for (index = 0; index < 15 ; index++)
 80012e2:	d1eb      	bne.n	80012bc <HAL_PCD_Init+0x74>
    hpcd->OUT_ep[index].xfer_buff = 0;
    hpcd->OUT_ep[index].xfer_len = 0;
  }
  
  /* Init Device */
  USB_DevInit(hpcd->Instance, hpcd->Init);
 80012e4:	46ee      	mov	lr, sp
 80012e6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80012e8:	f8d4 c000 	ldr.w	ip, [r4]
 80012ec:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 80012f0:	682b      	ldr	r3, [r5, #0]
 80012f2:	4660      	mov	r0, ip
 80012f4:	f8ce 3000 	str.w	r3, [lr]
 80012f8:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
 80012fc:	f001 f8d2 	bl	80024a4 <USB_DevInit>
  
  hpcd->USB_Address = 0;
  hpcd->State= HAL_PCD_STATE_READY;
 8001300:	2301      	movs	r3, #1
  }
  
  /* Init Device */
  USB_DevInit(hpcd->Instance, hpcd->Init);
  
  hpcd->USB_Address = 0;
 8001302:	f884 7024 	strb.w	r7, [r4, #36]	; 0x24
  hpcd->State= HAL_PCD_STATE_READY;
  
  USB_DevDisconnect (hpcd->Instance);  
 8001306:	6820      	ldr	r0, [r4, #0]
  
  /* Init Device */
  USB_DevInit(hpcd->Instance, hpcd->Init);
  
  hpcd->USB_Address = 0;
  hpcd->State= HAL_PCD_STATE_READY;
 8001308:	f884 33e9 	strb.w	r3, [r4, #1001]	; 0x3e9
  
  USB_DevDisconnect (hpcd->Instance);  
 800130c:	f001 fd3a 	bl	8002d84 <USB_DevDisconnect>
  return HAL_OK;
 8001310:	4638      	mov	r0, r7
}
 8001312:	b007      	add	sp, #28
 8001314:	bdf0      	pop	{r4, r5, r6, r7, pc}
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  if(hpcd->State == HAL_PCD_STATE_RESET)
  {  
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 8001316:	f880 23e8 	strb.w	r2, [r0, #1000]	; 0x3e8

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 800131a:	f002 fce9 	bl	8003cf0 <HAL_PCD_MspInit>
 800131e:	e79e      	b.n	800125e <HAL_PCD_Init+0x16>
  uint32_t index = 0;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
  {
    return HAL_ERROR;
 8001320:	2001      	movs	r0, #1
 8001322:	4770      	bx	lr

08001324 <HAL_PCD_Start>:
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
  __HAL_LOCK(hpcd);
 8001324:	f890 23e8 	ldrb.w	r2, [r0, #1000]	; 0x3e8
 8001328:	2a01      	cmp	r2, #1
 800132a:	d101      	bne.n	8001330 <HAL_PCD_Start+0xc>
 800132c:	2002      	movs	r0, #2
 800132e:	4770      	bx	lr
  * @brief  Start The USB Device.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
 8001330:	b510      	push	{r4, lr}
 8001332:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd);
 8001334:	2101      	movs	r1, #1
 8001336:	f880 13e8 	strb.w	r1, [r0, #1000]	; 0x3e8
  HAL_PCDEx_SetConnectionState (hpcd, 1);
 800133a:	f002 fdd3 	bl	8003ee4 <HAL_PCDEx_SetConnectionState>
  USB_DevConnect (hpcd->Instance);
 800133e:	6820      	ldr	r0, [r4, #0]
 8001340:	f001 fd1e 	bl	8002d80 <USB_DevConnect>
  __HAL_PCD_ENABLE(hpcd);
 8001344:	6820      	ldr	r0, [r4, #0]
 8001346:	f001 f897 	bl	8002478 <USB_EnableGlobalInt>
  __HAL_UNLOCK(hpcd);
 800134a:	2000      	movs	r0, #0
 800134c:	f884 03e8 	strb.w	r0, [r4, #1000]	; 0x3e8
  return HAL_OK;
 8001350:	bd10      	pop	{r4, pc}
 8001352:	bf00      	nop

08001354 <HAL_PCD_SetAddress>:
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
  __HAL_LOCK(hpcd);
 8001354:	f890 23e8 	ldrb.w	r2, [r0, #1000]	; 0x3e8
 8001358:	2a01      	cmp	r2, #1
 800135a:	d101      	bne.n	8001360 <HAL_PCD_SetAddress+0xc>
 800135c:	2002      	movs	r0, #2
 800135e:	4770      	bx	lr
  * @param  hpcd: PCD handle
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 8001360:	b510      	push	{r4, lr}
 8001362:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd);
 8001364:	2201      	movs	r2, #1
  hpcd->USB_Address = address;
 8001366:	f884 1024 	strb.w	r1, [r4, #36]	; 0x24
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
  __HAL_LOCK(hpcd);
 800136a:	f880 23e8 	strb.w	r2, [r0, #1000]	; 0x3e8
  hpcd->USB_Address = address;
  USB_SetDevAddress(hpcd->Instance, address);
 800136e:	6800      	ldr	r0, [r0, #0]
 8001370:	f001 fd00 	bl	8002d74 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 8001374:	2000      	movs	r0, #0
 8001376:	f884 03e8 	strb.w	r0, [r4, #1000]	; 0x3e8
 800137a:	bd10      	pop	{r4, pc}

0800137c <HAL_PCD_EP_Open>:
  * @param  ep_mps: endpoint max packet size
  * @param  ep_type: endpoint type   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
{
 800137c:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef  ret = HAL_OK;
  PCD_EPTypeDef *ep = NULL;
  
  if ((ep_addr & 0x80) == 0x80)
 800137e:	b2cc      	uxtb	r4, r1
 8001380:	0625      	lsls	r5, r4, #24
 8001382:	d41a      	bmi.n	80013ba <HAL_PCD_EP_Open+0x3e>
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8001384:	460d      	mov	r5, r1
 8001386:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 800138a:	f501 7102 	add.w	r1, r1, #520	; 0x208
  }
  ep->num   = ep_addr & 0x7F;
  
  ep->is_in = (0x80 & ep_addr) != 0;
 800138e:	09e4      	lsrs	r4, r4, #7
 8001390:	704c      	strb	r4, [r1, #1]
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
 8001392:	700d      	strb	r5, [r1, #0]
  
  ep->is_in = (0x80 & ep_addr) != 0;
  ep->maxpacket = ep_mps;
  ep->type = ep_type;
 8001394:	70cb      	strb	r3, [r1, #3]
    
  __HAL_LOCK(hpcd);
 8001396:	f890 33e8 	ldrb.w	r3, [r0, #1000]	; 0x3e8
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
  
  ep->is_in = (0x80 & ep_addr) != 0;
  ep->maxpacket = ep_mps;
 800139a:	610a      	str	r2, [r1, #16]
  ep->type = ep_type;
    
  __HAL_LOCK(hpcd);
 800139c:	2b01      	cmp	r3, #1
 800139e:	d101      	bne.n	80013a4 <HAL_PCD_EP_Open+0x28>
 80013a0:	2002      	movs	r0, #2
  USB_ActivateEndpoint(hpcd->Instance , ep);
  __HAL_UNLOCK(hpcd);
  return ret;
}
 80013a2:	bd38      	pop	{r3, r4, r5, pc}
 80013a4:	4604      	mov	r4, r0
  
  ep->is_in = (0x80 & ep_addr) != 0;
  ep->maxpacket = ep_mps;
  ep->type = ep_type;
    
  __HAL_LOCK(hpcd);
 80013a6:	2301      	movs	r3, #1
 80013a8:	f880 33e8 	strb.w	r3, [r0, #1000]	; 0x3e8
  USB_ActivateEndpoint(hpcd->Instance , ep);
 80013ac:	6800      	ldr	r0, [r0, #0]
 80013ae:	f001 f88d 	bl	80024cc <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 80013b2:	2000      	movs	r0, #0
 80013b4:	f884 03e8 	strb.w	r0, [r4, #1000]	; 0x3e8
  return ret;
 80013b8:	bd38      	pop	{r3, r4, r5, pc}
 80013ba:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  HAL_StatusTypeDef  ret = HAL_OK;
  PCD_EPTypeDef *ep = NULL;
  
  if ((ep_addr & 0x80) == 0x80)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 80013be:	eb00 1145 	add.w	r1, r0, r5, lsl #5
 80013c2:	3128      	adds	r1, #40	; 0x28
 80013c4:	e7e3      	b.n	800138e <HAL_PCD_EP_Open+0x12>
 80013c6:	bf00      	nop

080013c8 <HAL_PCD_EP_Close>:
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{  
  PCD_EPTypeDef *ep = NULL;
  
  if ((ep_addr & 0x80) == 0x80)
 80013c8:	b2cb      	uxtb	r3, r1
 80013ca:	061a      	lsls	r2, r3, #24
 80013cc:	d419      	bmi.n	8001402 <HAL_PCD_EP_Close+0x3a>
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 80013ce:	460a      	mov	r2, r1
 80013d0:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 80013d4:	f501 7102 	add.w	r1, r1, #520	; 0x208
  }
  ep->num   = ep_addr & 0x7F;
  
  ep->is_in = (0x80 & ep_addr) != 0;
 80013d8:	09db      	lsrs	r3, r3, #7
 80013da:	704b      	strb	r3, [r1, #1]
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  }
  ep->num   = ep_addr & 0x7F;
 80013dc:	700a      	strb	r2, [r1, #0]
  
  ep->is_in = (0x80 & ep_addr) != 0;
  
  __HAL_LOCK(hpcd);
 80013de:	f890 33e8 	ldrb.w	r3, [r0, #1000]	; 0x3e8
 80013e2:	2b01      	cmp	r3, #1
 80013e4:	d101      	bne.n	80013ea <HAL_PCD_EP_Close+0x22>
 80013e6:	2002      	movs	r0, #2
 80013e8:	4770      	bx	lr
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{  
 80013ea:	b510      	push	{r4, lr}
 80013ec:	4604      	mov	r4, r0
  }
  ep->num   = ep_addr & 0x7F;
  
  ep->is_in = (0x80 & ep_addr) != 0;
  
  __HAL_LOCK(hpcd);
 80013ee:	2301      	movs	r3, #1
 80013f0:	f880 33e8 	strb.w	r3, [r0, #1000]	; 0x3e8
  USB_DeactivateEndpoint(hpcd->Instance , ep);
 80013f4:	6800      	ldr	r0, [r0, #0]
 80013f6:	f001 fa0f 	bl	8002818 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 80013fa:	2000      	movs	r0, #0
 80013fc:	f884 03e8 	strb.w	r0, [r4, #1000]	; 0x3e8
  return HAL_OK;
 8001400:	bd10      	pop	{r4, pc}
 8001402:	f001 027f 	and.w	r2, r1, #127	; 0x7f
{  
  PCD_EPTypeDef *ep = NULL;
  
  if ((ep_addr & 0x80) == 0x80)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001406:	eb00 1142 	add.w	r1, r0, r2, lsl #5
 800140a:	3128      	adds	r1, #40	; 0x28
 800140c:	e7e4      	b.n	80013d8 <HAL_PCD_EP_Close+0x10>
 800140e:	bf00      	nop

08001410 <HAL_PCD_EP_Receive>:
  * @param  pBuf: pointer to the reception buffer
  * @param  len: amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8001410:	b570      	push	{r4, r5, r6, lr}
 8001412:	f001 067f 	and.w	r6, r1, #127	; 0x7f
  PCD_EPTypeDef *ep = NULL;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8001416:	0175      	lsls	r5, r6, #5
 8001418:	1944      	adds	r4, r0, r5
  ep->xfer_len = len;
  ep->xfer_count = 0;
 800141a:	2100      	movs	r1, #0
  PCD_EPTypeDef *ep = NULL;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 800141c:	f8c4 221c 	str.w	r2, [r4, #540]	; 0x21c
  ep->xfer_len = len;
 8001420:	f8c4 3220 	str.w	r3, [r4, #544]	; 0x220
  ep->xfer_count = 0;
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
 8001424:	f884 6208 	strb.w	r6, [r4, #520]	; 0x208
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
  ep->xfer_len = len;
  ep->xfer_count = 0;
 8001428:	f8c4 1224 	str.w	r1, [r4, #548]	; 0x224
  ep->is_in = 0;
 800142c:	f884 1209 	strb.w	r1, [r4, #521]	; 0x209
  ep->num = ep_addr & 0x7F;
  
  __HAL_LOCK(hpcd);
 8001430:	f890 33e8 	ldrb.w	r3, [r0, #1000]	; 0x3e8
 8001434:	2b01      	cmp	r3, #1
 8001436:	d00d      	beq.n	8001454 <HAL_PCD_EP_Receive+0x44>
 8001438:	4604      	mov	r4, r0
 800143a:	2301      	movs	r3, #1
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  PCD_EPTypeDef *ep = NULL;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 800143c:	f505 7502 	add.w	r5, r5, #520	; 0x208
 8001440:	1941      	adds	r1, r0, r5
  ep->xfer_len = len;
  ep->xfer_count = 0;
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
  
  __HAL_LOCK(hpcd);
 8001442:	f880 33e8 	strb.w	r3, [r0, #1000]	; 0x3e8
  
  if ((ep_addr & 0x7F) == 0 )
  {
    USB_EP0StartXfer(hpcd->Instance , ep);
 8001446:	6800      	ldr	r0, [r0, #0]
  }
  else
  {
    USB_EPStartXfer(hpcd->Instance , ep);
 8001448:	f001 fad0 	bl	80029ec <USB_EPStartXfer>
  }
  __HAL_UNLOCK(hpcd);
 800144c:	2000      	movs	r0, #0
 800144e:	f884 03e8 	strb.w	r0, [r4, #1000]	; 0x3e8
  
  return HAL_OK;
 8001452:	bd70      	pop	{r4, r5, r6, pc}
  ep->xfer_len = len;
  ep->xfer_count = 0;
  ep->is_in = 0;
  ep->num = ep_addr & 0x7F;
  
  __HAL_LOCK(hpcd);
 8001454:	2002      	movs	r0, #2
    USB_EPStartXfer(hpcd->Instance , ep);
  }
  __HAL_UNLOCK(hpcd);
  
  return HAL_OK;
}
 8001456:	bd70      	pop	{r4, r5, r6, pc}

08001458 <HAL_PCD_EP_GetRxCount>:
  * @param  ep_addr: endpoint address
  * @retval Data Size
  */
uint16_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  return hpcd->OUT_ep[ep_addr & 0x7F].xfer_count;
 8001458:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 800145c:	eb00 1041 	add.w	r0, r0, r1, lsl #5
}
 8001460:	f8b0 0224 	ldrh.w	r0, [r0, #548]	; 0x224
 8001464:	4770      	bx	lr
 8001466:	bf00      	nop

08001468 <HAL_PCD_EP_Transmit>:
  * @param  pBuf: pointer to the transmission buffer
  * @param  len: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8001468:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800146a:	f001 067f 	and.w	r6, r1, #127	; 0x7f
  PCD_EPTypeDef *ep = NULL;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 800146e:	0175      	lsls	r5, r6, #5
 8001470:	1944      	adds	r4, r0, r5
  ep->xfer_len = len;
  ep->xfer_count = 0;
  ep->is_in = 1;
 8001472:	2701      	movs	r7, #1
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
  ep->xfer_len = len;
  ep->xfer_count = 0;
 8001474:	2100      	movs	r1, #0
  PCD_EPTypeDef *ep = NULL;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8001476:	63e2      	str	r2, [r4, #60]	; 0x3c
  ep->xfer_len = len;
 8001478:	6423      	str	r3, [r4, #64]	; 0x40
  ep->xfer_count = 0;
  ep->is_in = 1;
  ep->num = ep_addr & 0x7F;
 800147a:	f884 6028 	strb.w	r6, [r4, #40]	; 0x28
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
  ep->xfer_len = len;
  ep->xfer_count = 0;
 800147e:	6461      	str	r1, [r4, #68]	; 0x44
  ep->is_in = 1;
 8001480:	f884 7029 	strb.w	r7, [r4, #41]	; 0x29
  ep->num = ep_addr & 0x7F;
  
  __HAL_LOCK(hpcd);
 8001484:	f890 33e8 	ldrb.w	r3, [r0, #1000]	; 0x3e8
 8001488:	42bb      	cmp	r3, r7
 800148a:	d00b      	beq.n	80014a4 <HAL_PCD_EP_Transmit+0x3c>
 800148c:	4604      	mov	r4, r0
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
  PCD_EPTypeDef *ep = NULL;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
 800148e:	3528      	adds	r5, #40	; 0x28
 8001490:	1941      	adds	r1, r0, r5
  ep->xfer_len = len;
  ep->xfer_count = 0;
  ep->is_in = 1;
  ep->num = ep_addr & 0x7F;
  
  __HAL_LOCK(hpcd);
 8001492:	f880 73e8 	strb.w	r7, [r0, #1000]	; 0x3e8
  
  if ((ep_addr & 0x7F) == 0 )
  {
    USB_EP0StartXfer(hpcd->Instance , ep);
 8001496:	6800      	ldr	r0, [r0, #0]
  }
  else
  {
    USB_EPStartXfer(hpcd->Instance , ep);
 8001498:	f001 faa8 	bl	80029ec <USB_EPStartXfer>
  }
  
  __HAL_UNLOCK(hpcd);
 800149c:	2000      	movs	r0, #0
 800149e:	f884 03e8 	strb.w	r0, [r4, #1000]	; 0x3e8
  
  return HAL_OK;
 80014a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  ep->xfer_len = len;
  ep->xfer_count = 0;
  ep->is_in = 1;
  ep->num = ep_addr & 0x7F;
  
  __HAL_LOCK(hpcd);
 80014a4:	2002      	movs	r0, #2
  }
  
  __HAL_UNLOCK(hpcd);
  
  return HAL_OK;
}
 80014a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080014a8 <HAL_PCD_IRQHandler>:
  * @brief  This function handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 80014a8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80014ac:	4604      	mov	r4, r0
 80014ae:	b083      	sub	sp, #12
  uint32_t wInterrupt_Mask = 0;
  
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_CTR))
 80014b0:	6800      	ldr	r0, [r0, #0]
 80014b2:	f001 fc69 	bl	8002d88 <USB_ReadInterrupts>
 80014b6:	0401      	lsls	r1, r0, #16
 80014b8:	d444      	bmi.n	8001544 <HAL_PCD_IRQHandler+0x9c>
 80014ba:	6820      	ldr	r0, [r4, #0]
    /* servicing of the endpoint correct transfer interrupt */
    /* clear of the CTR flag into the sub */
    PCD_EP_ISR_Handler(hpcd);
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_RESET))
 80014bc:	f001 fc64 	bl	8002d88 <USB_ReadInterrupts>
 80014c0:	0546      	lsls	r6, r0, #21
 80014c2:	f100 8202 	bmi.w	80018ca <HAL_PCD_IRQHandler+0x422>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
    HAL_PCD_ResetCallback(hpcd);
    HAL_PCD_SetAddress(hpcd, 0);
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_PMAOVR))
 80014c6:	6820      	ldr	r0, [r4, #0]
 80014c8:	f001 fc5e 	bl	8002d88 <USB_ReadInterrupts>
 80014cc:	f410 4f80 	tst.w	r0, #16384	; 0x4000
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_PMAOVR);    
 80014d0:	6820      	ldr	r0, [r4, #0]
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
    HAL_PCD_ResetCallback(hpcd);
    HAL_PCD_SetAddress(hpcd, 0);
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_PMAOVR))
 80014d2:	d007      	beq.n	80014e4 <HAL_PCD_IRQHandler+0x3c>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_PMAOVR);    
 80014d4:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 80014d8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80014dc:	041b      	lsls	r3, r3, #16
 80014de:	0c1b      	lsrs	r3, r3, #16
 80014e0:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
  }
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_ERR))
 80014e4:	f001 fc50 	bl	8002d88 <USB_ReadInterrupts>
 80014e8:	f410 5f00 	tst.w	r0, #8192	; 0x2000
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR); 
 80014ec:	6820      	ldr	r0, [r4, #0]

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_PMAOVR))
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_PMAOVR);    
  }
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_ERR))
 80014ee:	d007      	beq.n	8001500 <HAL_PCD_IRQHandler+0x58>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR); 
 80014f0:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 80014f4:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80014f8:	041b      	lsls	r3, r3, #16
 80014fa:	0c1b      	lsrs	r3, r3, #16
 80014fc:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_WKUP))
 8001500:	f001 fc42 	bl	8002d88 <USB_ReadInterrupts>
 8001504:	04c5      	lsls	r5, r0, #19
 8001506:	f100 81c6 	bmi.w	8001896 <HAL_PCD_IRQHandler+0x3ee>
 800150a:	6820      	ldr	r0, [r4, #0]
    HAL_PCD_ResumeCallback(hpcd);
    
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_WKUP);     
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_SUSP))
 800150c:	f001 fc3c 	bl	8002d88 <USB_ReadInterrupts>
 8001510:	0500      	lsls	r0, r0, #20
 8001512:	f100 819f 	bmi.w	8001854 <HAL_PCD_IRQHandler+0x3ac>
    {
      HAL_PCD_SuspendCallback(hpcd);
    }
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_SOF))
 8001516:	6820      	ldr	r0, [r4, #0]
 8001518:	f001 fc36 	bl	8002d88 <USB_ReadInterrupts>
 800151c:	0582      	lsls	r2, r0, #22
 800151e:	f100 818c 	bmi.w	800183a <HAL_PCD_IRQHandler+0x392>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF); 
    HAL_PCD_SOFCallback(hpcd);
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_ESOF))
 8001522:	6820      	ldr	r0, [r4, #0]
 8001524:	f001 fc30 	bl	8002d88 <USB_ReadInterrupts>
 8001528:	05c3      	lsls	r3, r0, #23
 800152a:	d508      	bpl.n	800153e <HAL_PCD_IRQHandler+0x96>
  {
    /* clear ESOF flag in ISTR */
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ESOF); 
 800152c:	6822      	ldr	r2, [r4, #0]
 800152e:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 8001532:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001536:	041b      	lsls	r3, r3, #16
 8001538:	0c1b      	lsrs	r3, r3, #16
 800153a:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
  }
}
 800153e:	b003      	add	sp, #12
 8001540:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
static HAL_StatusTypeDef PCD_EP_ISR_Handler(PCD_HandleTypeDef *hpcd)
{
  PCD_EPTypeDef *ep = NULL;
  uint16_t count = 0;
  uint8_t epindex = 0;
  __IO uint16_t wIstr = 0;  
 8001544:	2300      	movs	r3, #0
 8001546:	6820      	ldr	r0, [r4, #0]
 8001548:	f8ad 3004 	strh.w	r3, [sp, #4]
        
        if ((wEPVal & USB_EP_SETUP) != 0)
        {
          /* Get SETUP Packet*/
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
          USB_ReadPMA(hpcd->Instance, (uint8_t*)hpcd->Setup ,ep->pmaadress , ep->xfer_count);       
 800154c:	f504 767b 	add.w	r6, r4, #1004	; 0x3ec
{
  PCD_EPTypeDef *ep = NULL;
  uint16_t count = 0;
  uint8_t epindex = 0;
  __IO uint16_t wIstr = 0;  
  __IO uint16_t wEPVal = 0;
 8001550:	f8ad 3006 	strh.w	r3, [sp, #6]
  
  /* stay in loop while pending interrupts */
  while (((wIstr = hpcd->Instance->ISTR) & USB_ISTR_CTR) != 0)
 8001554:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 8001558:	b29b      	uxth	r3, r3
 800155a:	041f      	lsls	r7, r3, #16
 800155c:	f8ad 3004 	strh.w	r3, [sp, #4]
 8001560:	d5ac      	bpl.n	80014bc <HAL_PCD_IRQHandler+0x14>
  {
    /* extract highest priority endpoint number */
    epindex = (uint8_t)(wIstr & USB_ISTR_EP_ID);
 8001562:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    
    if (epindex == 0)
 8001566:	f012 070f 	ands.w	r7, r2, #15
 800156a:	d15a      	bne.n	8001622 <HAL_PCD_IRQHandler+0x17a>
    {
      /* Decode and service control endpoint interrupt */
      
      /* DIR bit = origin of the interrupt */   
      if ((wIstr & USB_ISTR_DIR) == 0)
 800156c:	f8bd 1004 	ldrh.w	r1, [sp, #4]
      {
        /* DIR = 0 */
        
        /* DIR = 0      => IN  int */
        /* DIR = 0 implies that (EP_CTR_TX = 1) always  */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8001570:	8803      	ldrh	r3, [r0, #0]
    if (epindex == 0)
    {
      /* Decode and service control endpoint interrupt */
      
      /* DIR bit = origin of the interrupt */   
      if ((wIstr & USB_ISTR_DIR) == 0)
 8001572:	f001 0110 	and.w	r1, r1, #16
 8001576:	b289      	uxth	r1, r1
 8001578:	2900      	cmp	r1, #0
 800157a:	f000 809f 	beq.w	80016bc <HAL_PCD_IRQHandler+0x214>
        /* DIR = 1 */
        
        /* DIR = 1 & CTR_RX       => SETUP or OUT int */
        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */
        ep = &hpcd->OUT_ep[0];
        wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);
 800157e:	b29b      	uxth	r3, r3
 8001580:	f8ad 3006 	strh.w	r3, [sp, #6]
        
        if ((wEPVal & USB_EP_SETUP) != 0)
 8001584:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8001588:	051a      	lsls	r2, r3, #20
 800158a:	f100 8136 	bmi.w	80017fa <HAL_PCD_IRQHandler+0x352>
          
          /* Process SETUP Packet*/
          HAL_PCD_SetupStageCallback(hpcd);
        }
        
        else if ((wEPVal & USB_EP_CTR_RX) != 0)
 800158e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8001592:	041b      	lsls	r3, r3, #16
 8001594:	d5de      	bpl.n	8001554 <HAL_PCD_IRQHandler+0xac>
        {
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8001596:	8803      	ldrh	r3, [r0, #0]
 8001598:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800159c:	051b      	lsls	r3, r3, #20
 800159e:	0d1b      	lsrs	r3, r3, #20
 80015a0:	8003      	strh	r3, [r0, #0]
          /* Get Control Data OUT Packet*/
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 80015a2:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 80015a6:	f894 2208 	ldrb.w	r2, [r4, #520]	; 0x208
 80015aa:	b29b      	uxth	r3, r3
 80015ac:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80015b0:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 80015b4:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
 80015b8:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80015bc:	f8c4 3224 	str.w	r3, [r4, #548]	; 0x224
          
          if (ep->xfer_count != 0)
 80015c0:	2b00      	cmp	r3, #0
 80015c2:	f040 820b 	bne.w	80019dc <HAL_PCD_IRQHandler+0x534>
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, ep->xfer_count);
            ep->xfer_buff+=ep->xfer_count;
          }
          
          /* Process Control Data OUT Packet*/
           HAL_PCD_DataOutStageCallback(hpcd, 0);
 80015c6:	2100      	movs	r1, #0
 80015c8:	4620      	mov	r0, r4
 80015ca:	f002 fbb7 	bl	8003d3c <HAL_PCD_DataOutStageCallback>
          
          PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket);
 80015ce:	6820      	ldr	r0, [r4, #0]
 80015d0:	f8d4 5218 	ldr.w	r5, [r4, #536]	; 0x218
 80015d4:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 80015d8:	2d3e      	cmp	r5, #62	; 0x3e
 80015da:	b29b      	uxth	r3, r3
 80015dc:	f500 6180 	add.w	r1, r0, #1024	; 0x400
 80015e0:	f103 0306 	add.w	r3, r3, #6
 80015e4:	f240 81d3 	bls.w	800198e <HAL_PCD_IRQHandler+0x4e6>
 80015e8:	f3c5 124f 	ubfx	r2, r5, #5, #16
 80015ec:	06ef      	lsls	r7, r5, #27
 80015ee:	bf04      	itt	eq
 80015f0:	f102 32ff 	addeq.w	r2, r2, #4294967295
 80015f4:	b292      	uxtheq	r2, r2
 80015f6:	ea6f 62c2 	mvn.w	r2, r2, lsl #27
 80015fa:	ea6f 4252 	mvn.w	r2, r2, lsr #17
 80015fe:	b292      	uxth	r2, r2
 8001600:	f841 2013 	str.w	r2, [r1, r3, lsl #1]
          PCD_SET_EP_RX_STATUS(hpcd->Instance, PCD_ENDP0, USB_EP_RX_VALID);
 8001604:	8803      	ldrh	r3, [r0, #0]
 8001606:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800160a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800160e:	041b      	lsls	r3, r3, #16
 8001610:	0c1b      	lsrs	r3, r3, #16
 8001612:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8001616:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800161a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800161e:	8003      	strh	r3, [r0, #0]
 8001620:	e798      	b.n	8001554 <HAL_PCD_IRQHandler+0xac>
    else
    {
      /* Decode and service non control endpoints interrupt  */
	  
      /* process related endpoint register */
      wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, epindex);
 8001622:	f830 3027 	ldrh.w	r3, [r0, r7, lsl #2]
 8001626:	b29b      	uxth	r3, r3
 8001628:	f8ad 3006 	strh.w	r3, [sp, #6]
      if ((wEPVal & USB_EP_CTR_RX) != 0)
 800162c:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8001630:	0419      	lsls	r1, r3, #16
 8001632:	d471      	bmi.n	8001718 <HAL_PCD_IRQHandler+0x270>
          HAL_PCD_EP_Receive(hpcd, ep->num, ep->xfer_buff, ep->xfer_len);
        }
        
      } /* if((wEPVal & EP_CTR_RX) */
      
      if ((wEPVal & USB_EP_CTR_TX) != 0)
 8001634:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8001638:	061a      	lsls	r2, r3, #24
 800163a:	d58b      	bpl.n	8001554 <HAL_PCD_IRQHandler+0xac>
      {
        ep = &hpcd->IN_ep[epindex];
        
        /* clear int flag */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, epindex);
 800163c:	f830 3027 	ldrh.w	r3, [r0, r7, lsl #2]
        
        /* IN double Buffering*/
        if (ep->doublebuffer == 0)
 8001640:	017d      	lsls	r5, r7, #5
      if ((wEPVal & USB_EP_CTR_TX) != 0)
      {
        ep = &hpcd->IN_ep[epindex];
        
        /* clear int flag */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, epindex);
 8001642:	f423 43e1 	bic.w	r3, r3, #28800	; 0x7080
 8001646:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800164a:	041b      	lsls	r3, r3, #16
 800164c:	0c1b      	lsrs	r3, r3, #16
 800164e:	f820 3027 	strh.w	r3, [r0, r7, lsl #2]
        
        /* IN double Buffering*/
        if (ep->doublebuffer == 0)
 8001652:	eb04 0e05 	add.w	lr, r4, r5
 8001656:	f89e 3032 	ldrb.w	r3, [lr, #50]	; 0x32
 800165a:	2b00      	cmp	r3, #0
 800165c:	f040 80aa 	bne.w	80017b4 <HAL_PCD_IRQHandler+0x30c>
        {
          ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 8001660:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8001664:	f89e 2028 	ldrb.w	r2, [lr, #40]	; 0x28
 8001668:	b29b      	uxth	r3, r3
 800166a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800166e:	3302      	adds	r3, #2
 8001670:	f500 6180 	add.w	r1, r0, #1024	; 0x400
 8001674:	f851 3013 	ldr.w	r3, [r1, r3, lsl #1]
 8001678:	eb04 1247 	add.w	r2, r4, r7, lsl #5
 800167c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8001680:	6453      	str	r3, [r2, #68]	; 0x44
          if (ep->xfer_count != 0)
 8001682:	2b00      	cmp	r3, #0
 8001684:	f040 8179 	bne.w	800197a <HAL_PCD_IRQHandler+0x4d2>
            }
          }
          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_IN);  
        }
        /*multi-packet on the NON control IN endpoint*/
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 8001688:	4425      	add	r5, r4
 800168a:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 800168e:	f895 2028 	ldrb.w	r2, [r5, #40]	; 0x28
 8001692:	b29b      	uxth	r3, r3
 8001694:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8001698:	3302      	adds	r3, #2
 800169a:	f851 1013 	ldr.w	r1, [r1, r3, lsl #1]
        ep->xfer_buff+=ep->xfer_count;
 800169e:	6bea      	ldr	r2, [r5, #60]	; 0x3c
            }
          }
          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_IN);  
        }
        /*multi-packet on the NON control IN endpoint*/
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 80016a0:	f3c1 0109 	ubfx	r1, r1, #0, #10
        ep->xfer_buff+=ep->xfer_count;
       
        /* Zero Length Packet? */
        if (ep->xfer_len == 0)
 80016a4:	6c2b      	ldr	r3, [r5, #64]	; 0x40
          }
          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_IN);  
        }
        /*multi-packet on the NON control IN endpoint*/
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
        ep->xfer_buff+=ep->xfer_count;
 80016a6:	440a      	add	r2, r1
            }
          }
          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_IN);  
        }
        /*multi-packet on the NON control IN endpoint*/
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 80016a8:	6469      	str	r1, [r5, #68]	; 0x44
        ep->xfer_buff+=ep->xfer_count;
 80016aa:	63ea      	str	r2, [r5, #60]	; 0x3c
       
        /* Zero Length Packet? */
        if (ep->xfer_len == 0)
        {
          /* TX COMPLETE */
          HAL_PCD_DataInStageCallback(hpcd, ep->num);
 80016ac:	f895 1028 	ldrb.w	r1, [r5, #40]	; 0x28
 80016b0:	4620      	mov	r0, r4
        /*multi-packet on the NON control IN endpoint*/
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
        ep->xfer_buff+=ep->xfer_count;
       
        /* Zero Length Packet? */
        if (ep->xfer_len == 0)
 80016b2:	bb6b      	cbnz	r3, 8001710 <HAL_PCD_IRQHandler+0x268>
        {
          /* TX COMPLETE */
          HAL_PCD_DataInStageCallback(hpcd, ep->num);
 80016b4:	f002 fb4a 	bl	8003d4c <HAL_PCD_DataInStageCallback>
 80016b8:	6820      	ldr	r0, [r4, #0]
 80016ba:	e74b      	b.n	8001554 <HAL_PCD_IRQHandler+0xac>
      {
        /* DIR = 0 */
        
        /* DIR = 0      => IN  int */
        /* DIR = 0 implies that (EP_CTR_TX = 1) always  */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 80016bc:	f423 43e1 	bic.w	r3, r3, #28800	; 0x7080
 80016c0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80016c4:	041b      	lsls	r3, r3, #16
 80016c6:	0c1b      	lsrs	r3, r3, #16
        ep = &hpcd->IN_ep[0];
        
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
        ep->xfer_buff += ep->xfer_count;
 80016c8:	6be2      	ldr	r2, [r4, #60]	; 0x3c
      {
        /* DIR = 0 */
        
        /* DIR = 0      => IN  int */
        /* DIR = 0 implies that (EP_CTR_TX = 1) always  */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 80016ca:	8003      	strh	r3, [r0, #0]
        ep = &hpcd->IN_ep[0];
        
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 80016cc:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 80016d0:	f894 5028 	ldrb.w	r5, [r4, #40]	; 0x28
 80016d4:	b29b      	uxth	r3, r3
 80016d6:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 80016da:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 80016de:	f8d0 3404 	ldr.w	r3, [r0, #1028]	; 0x404
        ep->xfer_buff += ep->xfer_count;
 
        /* TX COMPLETE */
        HAL_PCD_DataInStageCallback(hpcd, 0);
 80016e2:	4620      	mov	r0, r4
        /* DIR = 0      => IN  int */
        /* DIR = 0 implies that (EP_CTR_TX = 1) always  */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
        ep = &hpcd->IN_ep[0];
        
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 80016e4:	f3c3 0309 	ubfx	r3, r3, #0, #10
        ep->xfer_buff += ep->xfer_count;
 80016e8:	441a      	add	r2, r3
        /* DIR = 0      => IN  int */
        /* DIR = 0 implies that (EP_CTR_TX = 1) always  */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
        ep = &hpcd->IN_ep[0];
        
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 80016ea:	6463      	str	r3, [r4, #68]	; 0x44
        ep->xfer_buff += ep->xfer_count;
 80016ec:	63e2      	str	r2, [r4, #60]	; 0x3c
 
        /* TX COMPLETE */
        HAL_PCD_DataInStageCallback(hpcd, 0);
 80016ee:	f002 fb2d 	bl	8003d4c <HAL_PCD_DataInStageCallback>
        
        
        if((hpcd->USB_Address > 0)&& ( ep->xfer_len == 0))
 80016f2:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 80016f6:	b16b      	cbz	r3, 8001714 <HAL_PCD_IRQHandler+0x26c>
 80016f8:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80016fa:	b95b      	cbnz	r3, 8001714 <HAL_PCD_IRQHandler+0x26c>
        {
          hpcd->Instance->DADDR = (hpcd->USB_Address | USB_DADDR_EF);
 80016fc:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
 8001700:	6820      	ldr	r0, [r4, #0]
 8001702:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8001706:	f8a0 204c 	strh.w	r2, [r0, #76]	; 0x4c
          hpcd->USB_Address = 0;
 800170a:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
 800170e:	e721      	b.n	8001554 <HAL_PCD_IRQHandler+0xac>
          /* TX COMPLETE */
          HAL_PCD_DataInStageCallback(hpcd, ep->num);
        }
        else
        {
          HAL_PCD_EP_Transmit(hpcd, ep->num, ep->xfer_buff, ep->xfer_len);
 8001710:	f7ff feaa 	bl	8001468 <HAL_PCD_EP_Transmit>
 8001714:	6820      	ldr	r0, [r4, #0]
 8001716:	e71d      	b.n	8001554 <HAL_PCD_IRQHandler+0xac>
      /* process related endpoint register */
      wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, epindex);
      if ((wEPVal & USB_EP_CTR_RX) != 0)
      {  
        /* clear int flag */
        PCD_CLEAR_RX_EP_CTR(hpcd->Instance, epindex);
 8001718:	f830 3027 	ldrh.w	r3, [r0, r7, lsl #2]
        ep = &hpcd->OUT_ep[epindex];
        
        /* OUT double Buffering*/
        if (ep->doublebuffer == 0)
 800171c:	017d      	lsls	r5, r7, #5
      /* process related endpoint register */
      wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, epindex);
      if ((wEPVal & USB_EP_CTR_RX) != 0)
      {  
        /* clear int flag */
        PCD_CLEAR_RX_EP_CTR(hpcd->Instance, epindex);
 800171e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8001722:	051b      	lsls	r3, r3, #20
 8001724:	0d1b      	lsrs	r3, r3, #20
 8001726:	f820 3027 	strh.w	r3, [r0, r7, lsl #2]
        ep = &hpcd->OUT_ep[epindex];
        
        /* OUT double Buffering*/
        if (ep->doublebuffer == 0)
 800172a:	eb04 0905 	add.w	r9, r4, r5
 800172e:	f899 3212 	ldrb.w	r3, [r9, #530]	; 0x212
 8001732:	2b00      	cmp	r3, #0
 8001734:	f000 80e7 	beq.w	8001906 <HAL_PCD_IRQHandler+0x45e>
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, count);
          }
        }
        else
        {
          if (PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_RX)
 8001738:	f899 3208 	ldrb.w	r3, [r9, #520]	; 0x208
 800173c:	f830 1023 	ldrh.w	r1, [r0, r3, lsl #2]
 8001740:	eb00 0283 	add.w	r2, r0, r3, lsl #2
 8001744:	f411 4f80 	tst.w	r1, #16384	; 0x4000
          {
            /*read from endpoint BUF0Addr buffer*/
            count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8001748:	f8b0 1050 	ldrh.w	r1, [r0, #80]	; 0x50
 800174c:	b289      	uxth	r1, r1
 800174e:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 8001752:	eb00 0343 	add.w	r3, r0, r3, lsl #1
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, count);
          }
        }
        else
        {
          if (PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_RX)
 8001756:	f000 8125 	beq.w	80019a4 <HAL_PCD_IRQHandler+0x4fc>
          {
            /*read from endpoint BUF0Addr buffer*/
            count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800175a:	f8d3 3404 	ldr.w	r3, [r3, #1028]	; 0x404
 800175e:	f3c3 0809 	ubfx	r8, r3, #0, #10
            if (count != 0)
 8001762:	f1b8 0f00 	cmp.w	r8, #0
 8001766:	f040 8151 	bne.w	8001a0c <HAL_PCD_IRQHandler+0x564>
            if (count != 0)
            {
              USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
            }
          }
          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_OUT);  
 800176a:	8813      	ldrh	r3, [r2, #0]
 800176c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8001770:	051b      	lsls	r3, r3, #20
 8001772:	0d1b      	lsrs	r3, r3, #20
 8001774:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001778:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800177c:	8013      	strh	r3, [r2, #0]
 800177e:	1961      	adds	r1, r4, r5
        }
        /*multi-packet on the NON control OUT endpoint*/
        ep->xfer_count+=count;
 8001780:	f8d1 0224 	ldr.w	r0, [r1, #548]	; 0x224
        ep->xfer_buff+=count;
 8001784:	f8d1 221c 	ldr.w	r2, [r1, #540]	; 0x21c
       
        if ((ep->xfer_len == 0) || (count < ep->maxpacket))
 8001788:	f8d1 3220 	ldr.w	r3, [r1, #544]	; 0x220
            }
          }
          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_OUT);  
        }
        /*multi-packet on the NON control OUT endpoint*/
        ep->xfer_count+=count;
 800178c:	4440      	add	r0, r8
        ep->xfer_buff+=count;
 800178e:	4442      	add	r2, r8
            }
          }
          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_OUT);  
        }
        /*multi-packet on the NON control OUT endpoint*/
        ep->xfer_count+=count;
 8001790:	f8c1 0224 	str.w	r0, [r1, #548]	; 0x224
        ep->xfer_buff+=count;
 8001794:	f8c1 221c 	str.w	r2, [r1, #540]	; 0x21c
       
        if ((ep->xfer_len == 0) || (count < ep->maxpacket))
 8001798:	b123      	cbz	r3, 80017a4 <HAL_PCD_IRQHandler+0x2fc>
 800179a:	f8d1 0218 	ldr.w	r0, [r1, #536]	; 0x218
 800179e:	4580      	cmp	r8, r0
 80017a0:	f080 8115 	bcs.w	80019ce <HAL_PCD_IRQHandler+0x526>
        {
          /* RX COMPLETE */
          HAL_PCD_DataOutStageCallback(hpcd, ep->num);
 80017a4:	4425      	add	r5, r4
 80017a6:	4620      	mov	r0, r4
 80017a8:	f895 1208 	ldrb.w	r1, [r5, #520]	; 0x208
 80017ac:	f002 fac6 	bl	8003d3c <HAL_PCD_DataOutStageCallback>
 80017b0:	6820      	ldr	r0, [r4, #0]
 80017b2:	e73f      	b.n	8001634 <HAL_PCD_IRQHandler+0x18c>
            USB_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, ep->xfer_count);
          }
        }
        else
        {
          if (PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_TX)
 80017b4:	f89e c028 	ldrb.w	ip, [lr, #40]	; 0x28
 80017b8:	f830 302c 	ldrh.w	r3, [r0, ip, lsl #2]
 80017bc:	065b      	lsls	r3, r3, #25
 80017be:	f140 80bb 	bpl.w	8001938 <HAL_PCD_IRQHandler+0x490>
          {
            /*read from endpoint BUF0Addr buffer*/
            ep->xfer_count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 80017c2:	f8b0 1050 	ldrh.w	r1, [r0, #80]	; 0x50
 80017c6:	eb04 1247 	add.w	r2, r4, r7, lsl #5
 80017ca:	b289      	uxth	r1, r1
 80017cc:	eb01 03cc 	add.w	r3, r1, ip, lsl #3
 80017d0:	3302      	adds	r3, #2
 80017d2:	f500 6180 	add.w	r1, r0, #1024	; 0x400
 80017d6:	f851 3013 	ldr.w	r3, [r1, r3, lsl #1]
 80017da:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80017de:	6453      	str	r3, [r2, #68]	; 0x44
            if (ep->xfer_count != 0)
 80017e0:	2b00      	cmp	r3, #0
 80017e2:	f000 80ba 	beq.w	800195a <HAL_PCD_IRQHandler+0x4b2>
            {
              USB_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, ep->xfer_count);
 80017e6:	f8de 103c 	ldr.w	r1, [lr, #60]	; 0x3c
 80017ea:	f8be 202e 	ldrh.w	r2, [lr, #46]	; 0x2e
 80017ee:	f001 fad1 	bl	8002d94 <USB_WritePMA>
 80017f2:	6820      	ldr	r0, [r4, #0]
 80017f4:	f500 6180 	add.w	r1, r0, #1024	; 0x400
 80017f8:	e0af      	b.n	800195a <HAL_PCD_IRQHandler+0x4b2>
        wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);
        
        if ((wEPVal & USB_EP_SETUP) != 0)
        {
          /* Get SETUP Packet*/
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 80017fa:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 80017fe:	f894 2208 	ldrb.w	r2, [r4, #520]	; 0x208
 8001802:	b29b      	uxth	r3, r3
 8001804:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8001808:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 800180c:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
          USB_ReadPMA(hpcd->Instance, (uint8_t*)hpcd->Setup ,ep->pmaadress , ep->xfer_count);       
 8001810:	f8b4 220c 	ldrh.w	r2, [r4, #524]	; 0x20c
        wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);
        
        if ((wEPVal & USB_EP_SETUP) != 0)
        {
          /* Get SETUP Packet*/
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 8001814:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8001818:	f8c4 3224 	str.w	r3, [r4, #548]	; 0x224
          USB_ReadPMA(hpcd->Instance, (uint8_t*)hpcd->Setup ,ep->pmaadress , ep->xfer_count);       
 800181c:	4631      	mov	r1, r6
 800181e:	f001 facb 	bl	8002db8 <USB_ReadPMA>
          /* SETUP bit kept frozen while CTR_RX = 1*/ 
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0); 
 8001822:	6822      	ldr	r2, [r4, #0]
          
          /* Process SETUP Packet*/
          HAL_PCD_SetupStageCallback(hpcd);
 8001824:	4620      	mov	r0, r4
        {
          /* Get SETUP Packet*/
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
          USB_ReadPMA(hpcd->Instance, (uint8_t*)hpcd->Setup ,ep->pmaadress , ep->xfer_count);       
          /* SETUP bit kept frozen while CTR_RX = 1*/ 
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0); 
 8001826:	8813      	ldrh	r3, [r2, #0]
 8001828:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800182c:	051b      	lsls	r3, r3, #20
 800182e:	0d1b      	lsrs	r3, r3, #20
 8001830:	8013      	strh	r3, [r2, #0]
          
          /* Process SETUP Packet*/
          HAL_PCD_SetupStageCallback(hpcd);
 8001832:	f002 fa7d 	bl	8003d30 <HAL_PCD_SetupStageCallback>
 8001836:	6820      	ldr	r0, [r4, #0]
 8001838:	e68c      	b.n	8001554 <HAL_PCD_IRQHandler+0xac>
    }
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_SOF))
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF); 
 800183a:	6822      	ldr	r2, [r4, #0]
    HAL_PCD_SOFCallback(hpcd);
 800183c:	4620      	mov	r0, r4
    }
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_SOF))
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF); 
 800183e:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 8001842:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8001846:	041b      	lsls	r3, r3, #16
 8001848:	0c1b      	lsrs	r3, r3, #16
 800184a:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
    HAL_PCD_SOFCallback(hpcd);
 800184e:	f002 fa85 	bl	8003d5c <HAL_PCD_SOFCallback>
 8001852:	e666      	b.n	8001522 <HAL_PCD_IRQHandler+0x7a>
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_SUSP))
  {
    /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SUSP);  
 8001854:	6823      	ldr	r3, [r4, #0]
 8001856:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
    
    /* Force low-power mode in the macrocell */
    hpcd->Instance->CNTR |= USB_CNTR_FSUSP;
    hpcd->Instance->CNTR |= USB_CNTR_LP_MODE;
    if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_WKUP) == 0)
 800185a:	4618      	mov	r0, r3
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_SUSP))
  {
    /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SUSP);  
 800185c:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8001860:	0412      	lsls	r2, r2, #16
 8001862:	0c12      	lsrs	r2, r2, #16
 8001864:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    
    /* Force low-power mode in the macrocell */
    hpcd->Instance->CNTR |= USB_CNTR_FSUSP;
 8001868:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 800186c:	b292      	uxth	r2, r2
 800186e:	f042 0208 	orr.w	r2, r2, #8
 8001872:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    hpcd->Instance->CNTR |= USB_CNTR_LP_MODE;
 8001876:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 800187a:	b292      	uxth	r2, r2
 800187c:	f042 0204 	orr.w	r2, r2, #4
 8001880:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_WKUP) == 0)
 8001884:	f001 fa80 	bl	8002d88 <USB_ReadInterrupts>
 8001888:	04c1      	lsls	r1, r0, #19
 800188a:	f53f ae44 	bmi.w	8001516 <HAL_PCD_IRQHandler+0x6e>
    {
      HAL_PCD_SuspendCallback(hpcd);
 800188e:	4620      	mov	r0, r4
 8001890:	f002 fa76 	bl	8003d80 <HAL_PCD_SuspendCallback>
 8001894:	e63f      	b.n	8001516 <HAL_PCD_IRQHandler+0x6e>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR); 
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_WKUP))
  {  
    hpcd->Instance->CNTR &= ~(USB_CNTR_LP_MODE);
 8001896:	6822      	ldr	r2, [r4, #0]
    /*set wInterrupt_Mask global variable*/
    wInterrupt_Mask = USB_CNTR_CTRM  | USB_CNTR_WKUPM | USB_CNTR_SUSPM | USB_CNTR_ERRM \
      | USB_CNTR_ESOFM | USB_CNTR_RESETM;
    
    /*Set interrupt mask*/
    hpcd->Instance->CNTR = wInterrupt_Mask;
 8001898:	f44f 413d 	mov.w	r1, #48384	; 0xbd00
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR); 
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_WKUP))
  {  
    hpcd->Instance->CNTR &= ~(USB_CNTR_LP_MODE);
 800189c:	f8b2 3040 	ldrh.w	r3, [r2, #64]	; 0x40
      | USB_CNTR_ESOFM | USB_CNTR_RESETM;
    
    /*Set interrupt mask*/
    hpcd->Instance->CNTR = wInterrupt_Mask;
    
    HAL_PCD_ResumeCallback(hpcd);
 80018a0:	4620      	mov	r0, r4
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR); 
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_WKUP))
  {  
    hpcd->Instance->CNTR &= ~(USB_CNTR_LP_MODE);
 80018a2:	f023 0304 	bic.w	r3, r3, #4
 80018a6:	041b      	lsls	r3, r3, #16
 80018a8:	0c1b      	lsrs	r3, r3, #16
 80018aa:	f8a2 3040 	strh.w	r3, [r2, #64]	; 0x40
    /*set wInterrupt_Mask global variable*/
    wInterrupt_Mask = USB_CNTR_CTRM  | USB_CNTR_WKUPM | USB_CNTR_SUSPM | USB_CNTR_ERRM \
      | USB_CNTR_ESOFM | USB_CNTR_RESETM;
    
    /*Set interrupt mask*/
    hpcd->Instance->CNTR = wInterrupt_Mask;
 80018ae:	f8a2 1040 	strh.w	r1, [r2, #64]	; 0x40
    
    HAL_PCD_ResumeCallback(hpcd);
 80018b2:	f002 fa75 	bl	8003da0 <HAL_PCD_ResumeCallback>
    
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_WKUP);     
 80018b6:	6820      	ldr	r0, [r4, #0]
 80018b8:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 80018bc:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80018c0:	041b      	lsls	r3, r3, #16
 80018c2:	0c1b      	lsrs	r3, r3, #16
 80018c4:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
 80018c8:	e620      	b.n	800150c <HAL_PCD_IRQHandler+0x64>
    PCD_EP_ISR_Handler(hpcd);
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_RESET))
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
 80018ca:	6822      	ldr	r2, [r4, #0]
    HAL_PCD_ResetCallback(hpcd);
 80018cc:	4620      	mov	r0, r4
    PCD_EP_ISR_Handler(hpcd);
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_RESET))
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
 80018ce:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 80018d2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80018d6:	041b      	lsls	r3, r3, #16
 80018d8:	0c1b      	lsrs	r3, r3, #16
 80018da:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
    HAL_PCD_ResetCallback(hpcd);
 80018de:	f002 fa41 	bl	8003d64 <HAL_PCD_ResetCallback>
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
  __HAL_LOCK(hpcd);
 80018e2:	f894 33e8 	ldrb.w	r3, [r4, #1000]	; 0x3e8
 80018e6:	2b01      	cmp	r3, #1
 80018e8:	f43f aded 	beq.w	80014c6 <HAL_PCD_IRQHandler+0x1e>
  hpcd->USB_Address = address;
 80018ec:	2500      	movs	r5, #0
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
  __HAL_LOCK(hpcd);
 80018ee:	2301      	movs	r3, #1
 80018f0:	f884 33e8 	strb.w	r3, [r4, #1000]	; 0x3e8
  hpcd->USB_Address = address;
 80018f4:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
  USB_SetDevAddress(hpcd->Instance, address);
 80018f8:	4629      	mov	r1, r5
 80018fa:	6820      	ldr	r0, [r4, #0]
 80018fc:	f001 fa3a 	bl	8002d74 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 8001900:	f884 53e8 	strb.w	r5, [r4, #1000]	; 0x3e8
 8001904:	e5df      	b.n	80014c6 <HAL_PCD_IRQHandler+0x1e>
        ep = &hpcd->OUT_ep[epindex];
        
        /* OUT double Buffering*/
        if (ep->doublebuffer == 0)
        {
          count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 8001906:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 800190a:	f899 2208 	ldrb.w	r2, [r9, #520]	; 0x208
 800190e:	b29b      	uxth	r3, r3
 8001910:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8001914:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 8001918:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
 800191c:	f3c3 0809 	ubfx	r8, r3, #0, #10
          if (count != 0)
 8001920:	f1b8 0f00 	cmp.w	r8, #0
 8001924:	f43f af2b 	beq.w	800177e <HAL_PCD_IRQHandler+0x2d6>
          {
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, count);
 8001928:	4643      	mov	r3, r8
 800192a:	f8b9 220c 	ldrh.w	r2, [r9, #524]	; 0x20c
 800192e:	f8d9 121c 	ldr.w	r1, [r9, #540]	; 0x21c
 8001932:	f001 fa41 	bl	8002db8 <USB_ReadPMA>
 8001936:	e722      	b.n	800177e <HAL_PCD_IRQHandler+0x2d6>
            }
          }
          else
          {
            /*read from endpoint BUF1Addr buffer*/
            ep->xfer_count = PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 8001938:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 800193c:	f500 6180 	add.w	r1, r0, #1024	; 0x400
 8001940:	b29b      	uxth	r3, r3
 8001942:	eb03 03cc 	add.w	r3, r3, ip, lsl #3
 8001946:	3306      	adds	r3, #6
 8001948:	f851 3013 	ldr.w	r3, [r1, r3, lsl #1]
 800194c:	eb04 1247 	add.w	r2, r4, r7, lsl #5
 8001950:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8001954:	6453      	str	r3, [r2, #68]	; 0x44
            if (ep->xfer_count != 0)
 8001956:	2b00      	cmp	r3, #0
 8001958:	d14e      	bne.n	80019f8 <HAL_PCD_IRQHandler+0x550>
            {
              USB_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, ep->xfer_count);
            }
          }
          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_IN);  
 800195a:	1963      	adds	r3, r4, r5
 800195c:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
 8001960:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8001964:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8001968:	051b      	lsls	r3, r3, #20
 800196a:	0d1b      	lsrs	r3, r3, #20
 800196c:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8001970:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001974:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
 8001978:	e686      	b.n	8001688 <HAL_PCD_IRQHandler+0x1e0>
        if (ep->doublebuffer == 0)
        {
          ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
          if (ep->xfer_count != 0)
          {
            USB_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, ep->xfer_count);
 800197a:	f8de 103c 	ldr.w	r1, [lr, #60]	; 0x3c
 800197e:	f8be 202c 	ldrh.w	r2, [lr, #44]	; 0x2c
 8001982:	f001 fa07 	bl	8002d94 <USB_WritePMA>
 8001986:	6820      	ldr	r0, [r4, #0]
 8001988:	f500 6180 	add.w	r1, r0, #1024	; 0x400
 800198c:	e67c      	b.n	8001688 <HAL_PCD_IRQHandler+0x1e0>
          }
          
          /* Process Control Data OUT Packet*/
           HAL_PCD_DataOutStageCallback(hpcd, 0);
          
          PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket);
 800198e:	f3c5 024f 	ubfx	r2, r5, #1, #16
 8001992:	07ed      	lsls	r5, r5, #31
 8001994:	bf44      	itt	mi
 8001996:	3201      	addmi	r2, #1
 8001998:	b292      	uxthmi	r2, r2
 800199a:	0292      	lsls	r2, r2, #10
 800199c:	b292      	uxth	r2, r2
 800199e:	f841 2013 	str.w	r2, [r1, r3, lsl #1]
 80019a2:	e62f      	b.n	8001604 <HAL_PCD_IRQHandler+0x15c>
            }
          }
          else
          {
            /*read from endpoint BUF1Addr buffer*/
            count = PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 80019a4:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
 80019a8:	f3c3 0809 	ubfx	r8, r3, #0, #10
            if (count != 0)
 80019ac:	f1b8 0f00 	cmp.w	r8, #0
 80019b0:	f43f aedb 	beq.w	800176a <HAL_PCD_IRQHandler+0x2c2>
            {
              USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 80019b4:	4643      	mov	r3, r8
 80019b6:	f8b9 2210 	ldrh.w	r2, [r9, #528]	; 0x210
 80019ba:	f8d9 121c 	ldr.w	r1, [r9, #540]	; 0x21c
 80019be:	f001 f9fb 	bl	8002db8 <USB_ReadPMA>
 80019c2:	f899 2208 	ldrb.w	r2, [r9, #520]	; 0x208
 80019c6:	6823      	ldr	r3, [r4, #0]
 80019c8:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 80019cc:	e6cd      	b.n	800176a <HAL_PCD_IRQHandler+0x2c2>
          /* RX COMPLETE */
          HAL_PCD_DataOutStageCallback(hpcd, ep->num);
        }
        else
        {
          HAL_PCD_EP_Receive(hpcd, ep->num, ep->xfer_buff, ep->xfer_len);
 80019ce:	f891 1208 	ldrb.w	r1, [r1, #520]	; 0x208
 80019d2:	4620      	mov	r0, r4
 80019d4:	f7ff fd1c 	bl	8001410 <HAL_PCD_EP_Receive>
 80019d8:	6820      	ldr	r0, [r4, #0]
 80019da:	e62b      	b.n	8001634 <HAL_PCD_IRQHandler+0x18c>
          /* Get Control Data OUT Packet*/
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
          
          if (ep->xfer_count != 0)
          {
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, ep->xfer_count);
 80019dc:	f8b4 220c 	ldrh.w	r2, [r4, #524]	; 0x20c
 80019e0:	f8d4 121c 	ldr.w	r1, [r4, #540]	; 0x21c
 80019e4:	f001 f9e8 	bl	8002db8 <USB_ReadPMA>
            ep->xfer_buff+=ep->xfer_count;
 80019e8:	f8d4 221c 	ldr.w	r2, [r4, #540]	; 0x21c
 80019ec:	f8d4 3224 	ldr.w	r3, [r4, #548]	; 0x224
 80019f0:	4413      	add	r3, r2
 80019f2:	f8c4 321c 	str.w	r3, [r4, #540]	; 0x21c
 80019f6:	e5e6      	b.n	80015c6 <HAL_PCD_IRQHandler+0x11e>
          {
            /*read from endpoint BUF1Addr buffer*/
            ep->xfer_count = PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
            if (ep->xfer_count != 0)
            {
              USB_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, ep->xfer_count);
 80019f8:	f8de 103c 	ldr.w	r1, [lr, #60]	; 0x3c
 80019fc:	f8be 2030 	ldrh.w	r2, [lr, #48]	; 0x30
 8001a00:	f001 f9c8 	bl	8002d94 <USB_WritePMA>
 8001a04:	6820      	ldr	r0, [r4, #0]
 8001a06:	f500 6180 	add.w	r1, r0, #1024	; 0x400
 8001a0a:	e7a6      	b.n	800195a <HAL_PCD_IRQHandler+0x4b2>
          {
            /*read from endpoint BUF0Addr buffer*/
            count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
            if (count != 0)
            {
              USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, count);
 8001a0c:	4643      	mov	r3, r8
 8001a0e:	f8b9 220e 	ldrh.w	r2, [r9, #526]	; 0x20e
 8001a12:	e7d2      	b.n	80019ba <HAL_PCD_IRQHandler+0x512>

08001a14 <HAL_PCD_EP_SetStall>:
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8001a14:	b538      	push	{r3, r4, r5, lr}
  PCD_EPTypeDef *ep = NULL;
  
  if ((0x80 & ep_addr) == 0x80)
 8001a16:	b2cb      	uxtb	r3, r1
 8001a18:	061a      	lsls	r2, r3, #24
 8001a1a:	d41a      	bmi.n	8001a52 <HAL_PCD_EP_SetStall+0x3e>
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8001a1c:	460d      	mov	r5, r1
 8001a1e:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 8001a22:	f501 7102 	add.w	r1, r1, #520	; 0x208
  }
  
  ep->is_stall = 1;
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8001a26:	09db      	lsrs	r3, r3, #7
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 1;
 8001a28:	2201      	movs	r2, #1
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8001a2a:	704b      	strb	r3, [r1, #1]
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 1;
  ep->num   = ep_addr & 0x7F;
 8001a2c:	700d      	strb	r5, [r1, #0]
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 1;
 8001a2e:	708a      	strb	r2, [r1, #2]
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
  
  __HAL_LOCK(hpcd);
 8001a30:	f890 33e8 	ldrb.w	r3, [r0, #1000]	; 0x3e8
 8001a34:	4293      	cmp	r3, r2
 8001a36:	d101      	bne.n	8001a3c <HAL_PCD_EP_SetStall+0x28>
 8001a38:	2002      	movs	r0, #2
    USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);
  }
  __HAL_UNLOCK(hpcd); 
  
  return HAL_OK;
}
 8001a3a:	bd38      	pop	{r3, r4, r5, pc}
 8001a3c:	4604      	mov	r4, r0
  
  ep->is_stall = 1;
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
  
  __HAL_LOCK(hpcd);
 8001a3e:	f880 23e8 	strb.w	r2, [r0, #1000]	; 0x3e8
  USB_EPSetStall(hpcd->Instance , ep);
 8001a42:	6800      	ldr	r0, [r0, #0]
 8001a44:	f001 f90c 	bl	8002c60 <USB_EPSetStall>
  if((ep_addr & 0x7F) == 0)
 8001a48:	b14d      	cbz	r5, 8001a5e <HAL_PCD_EP_SetStall+0x4a>
  {
    USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);
  }
  __HAL_UNLOCK(hpcd); 
 8001a4a:	2000      	movs	r0, #0
 8001a4c:	f884 03e8 	strb.w	r0, [r4, #1000]	; 0x3e8
  
  return HAL_OK;
 8001a50:	bd38      	pop	{r3, r4, r5, pc}
 8001a52:	f001 057f 	and.w	r5, r1, #127	; 0x7f
{
  PCD_EPTypeDef *ep = NULL;
  
  if ((0x80 & ep_addr) == 0x80)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001a56:	eb00 1145 	add.w	r1, r0, r5, lsl #5
 8001a5a:	3128      	adds	r1, #40	; 0x28
 8001a5c:	e7e3      	b.n	8001a26 <HAL_PCD_EP_SetStall+0x12>
  
  __HAL_LOCK(hpcd);
  USB_EPSetStall(hpcd->Instance , ep);
  if((ep_addr & 0x7F) == 0)
  {
    USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);
 8001a5e:	f504 717b 	add.w	r1, r4, #1004	; 0x3ec
 8001a62:	6820      	ldr	r0, [r4, #0]
 8001a64:	f001 f994 	bl	8002d90 <USB_EP0_OutStart>
 8001a68:	e7ef      	b.n	8001a4a <HAL_PCD_EP_SetStall+0x36>
 8001a6a:	bf00      	nop

08001a6c <HAL_PCD_EP_ClrStall>:
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8001a6c:	b538      	push	{r3, r4, r5, lr}
  PCD_EPTypeDef *ep = NULL;
  
  if ((0x80 & ep_addr) == 0x80)
 8001a6e:	b2cb      	uxtb	r3, r1
 8001a70:	061a      	lsls	r2, r3, #24
 8001a72:	d41a      	bmi.n	8001aaa <HAL_PCD_EP_ClrStall+0x3e>
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8001a74:	460a      	mov	r2, r1
 8001a76:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 8001a7a:	f501 7102 	add.w	r1, r1, #520	; 0x208
  }
  
  ep->is_stall = 0;
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8001a7e:	09db      	lsrs	r3, r3, #7
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 0;
 8001a80:	2500      	movs	r5, #0
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
 8001a82:	704b      	strb	r3, [r1, #1]
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 0;
  ep->num   = ep_addr & 0x7F;
 8001a84:	700a      	strb	r2, [r1, #0]
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 0;
 8001a86:	708d      	strb	r5, [r1, #2]
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
  
  __HAL_LOCK(hpcd); 
 8001a88:	f890 33e8 	ldrb.w	r3, [r0, #1000]	; 0x3e8
 8001a8c:	2b01      	cmp	r3, #1
 8001a8e:	d101      	bne.n	8001a94 <HAL_PCD_EP_ClrStall+0x28>
 8001a90:	2002      	movs	r0, #2
  USB_EPClearStall(hpcd->Instance , ep);
  __HAL_UNLOCK(hpcd); 
  
  return HAL_OK;
}
 8001a92:	bd38      	pop	{r3, r4, r5, pc}
 8001a94:	4604      	mov	r4, r0
  
  ep->is_stall = 0;
  ep->num   = ep_addr & 0x7F;
  ep->is_in = ((ep_addr & 0x80) == 0x80);
  
  __HAL_LOCK(hpcd); 
 8001a96:	2301      	movs	r3, #1
 8001a98:	f880 33e8 	strb.w	r3, [r0, #1000]	; 0x3e8
  USB_EPClearStall(hpcd->Instance , ep);
 8001a9c:	6800      	ldr	r0, [r0, #0]
 8001a9e:	f001 f919 	bl	8002cd4 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd); 
 8001aa2:	f884 53e8 	strb.w	r5, [r4, #1000]	; 0x3e8
  
  return HAL_OK;
 8001aa6:	4628      	mov	r0, r5
 8001aa8:	bd38      	pop	{r3, r4, r5, pc}
 8001aaa:	f001 027f 	and.w	r2, r1, #127	; 0x7f
{
  PCD_EPTypeDef *ep = NULL;
  
  if ((0x80 & ep_addr) == 0x80)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001aae:	eb00 1142 	add.w	r1, r0, r2, lsl #5
 8001ab2:	3128      	adds	r1, #40	; 0x28
 8001ab4:	e7e3      	b.n	8001a7e <HAL_PCD_EP_ClrStall+0x12>
 8001ab6:	bf00      	nop

08001ab8 <USBD_Init>:
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
 8001ab8:	b188      	cbz	r0, 8001ade <USBD_Init+0x26>
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 8001aba:	b508      	push	{r3, lr}
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
 8001abc:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8001ac0:	b113      	cbz	r3, 8001ac8 <USBD_Init+0x10>
  {
    pdev->pClass = NULL;
 8001ac2:	2300      	movs	r3, #0
 8001ac4:	f8c0 3214 	str.w	r3, [r0, #532]	; 0x214
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
 8001ac8:	b109      	cbz	r1, 8001ace <USBD_Init+0x16>
  {
    pdev->pDesc = pdesc;
 8001aca:	f8c0 1210 	str.w	r1, [r0, #528]	; 0x210
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 8001ace:	2301      	movs	r3, #1
  pdev->id = id;
 8001ad0:	7002      	strb	r2, [r0, #0]
  {
    pdev->pDesc = pdesc;
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 8001ad2:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  pdev->id = id;
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 8001ad6:	f002 f967 	bl	8003da8 <USBD_LL_Init>
  
  return USBD_OK; 
 8001ada:	2000      	movs	r0, #0
 8001adc:	bd08      	pop	{r3, pc}
{
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
  {
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
 8001ade:	2002      	movs	r0, #2
 8001ae0:	4770      	bx	lr
 8001ae2:	bf00      	nop

08001ae4 <USBD_RegisterClass>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
 8001ae4:	b119      	cbz	r1, 8001aee <USBD_RegisterClass+0xa>
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
 8001ae6:	f8c0 1214 	str.w	r1, [r0, #532]	; 0x214
    status = USBD_OK;
 8001aea:	2000      	movs	r0, #0
 8001aec:	4770      	bx	lr
  }
  else
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
 8001aee:	2002      	movs	r0, #2
  }
  
  return status;
}
 8001af0:	4770      	bx	lr
 8001af2:	bf00      	nop

08001af4 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
 8001af4:	b508      	push	{r3, lr}
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
 8001af6:	f002 f997 	bl	8003e28 <USBD_LL_Start>
  
  return USBD_OK;  
}
 8001afa:	2000      	movs	r0, #0
 8001afc:	bd08      	pop	{r3, pc}
 8001afe:	bf00      	nop

08001b00 <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8001b00:	b508      	push	{r3, lr}
  USBD_StatusTypeDef   ret = USBD_FAIL;
  
  if(pdev->pClass != NULL)
 8001b02:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8001b06:	b113      	cbz	r3, 8001b0e <USBD_SetClassConfig+0xe>
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0)
 8001b08:	681b      	ldr	r3, [r3, #0]
 8001b0a:	4798      	blx	r3
 8001b0c:	b108      	cbz	r0, 8001b12 <USBD_SetClassConfig+0x12>
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
  USBD_StatusTypeDef   ret = USBD_FAIL;
 8001b0e:	2002      	movs	r0, #2
 8001b10:	bd08      	pop	{r3, pc}
    {
      ret = USBD_OK;
    }
  }
  return ret; 
}
 8001b12:	bd08      	pop	{r3, pc}

08001b14 <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8001b14:	b508      	push	{r3, lr}
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);  
 8001b16:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8001b1a:	685b      	ldr	r3, [r3, #4]
 8001b1c:	4798      	blx	r3
  return USBD_OK;
}
 8001b1e:	2000      	movs	r0, #0
 8001b20:	bd08      	pop	{r3, pc}
 8001b22:	bf00      	nop

08001b24 <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 8001b24:	b538      	push	{r3, r4, r5, lr}
 8001b26:	4604      	mov	r4, r0

  USBD_ParseSetupRequest(&pdev->request, psetup);
 8001b28:	f500 7502 	add.w	r5, r0, #520	; 0x208
 8001b2c:	4628      	mov	r0, r5
 8001b2e:	f003 ffc9 	bl	8005ac4 <USBD_ParseSetupRequest>
  
  pdev->ep0_state = USBD_EP0_SETUP;
  pdev->ep0_data_len = pdev->request.wLength;
  
  switch (pdev->request.bmRequest & 0x1F) 
 8001b32:	f894 1208 	ldrb.w	r1, [r4, #520]	; 0x208
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{

  USBD_ParseSetupRequest(&pdev->request, psetup);
  
  pdev->ep0_state = USBD_EP0_SETUP;
 8001b36:	2001      	movs	r0, #1
  pdev->ep0_data_len = pdev->request.wLength;
 8001b38:	f8b4 220e 	ldrh.w	r2, [r4, #526]	; 0x20e
  
  switch (pdev->request.bmRequest & 0x1F) 
 8001b3c:	f001 031f 	and.w	r3, r1, #31
 8001b40:	4283      	cmp	r3, r0
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{

  USBD_ParseSetupRequest(&pdev->request, psetup);
  
  pdev->ep0_state = USBD_EP0_SETUP;
 8001b42:	f8c4 01f4 	str.w	r0, [r4, #500]	; 0x1f4
  pdev->ep0_data_len = pdev->request.wLength;
 8001b46:	f8c4 21f8 	str.w	r2, [r4, #504]	; 0x1f8
  
  switch (pdev->request.bmRequest & 0x1F) 
 8001b4a:	d015      	beq.n	8001b78 <USBD_LL_SetupStage+0x54>
 8001b4c:	d30e      	bcc.n	8001b6c <USBD_LL_SetupStage+0x48>
 8001b4e:	2b02      	cmp	r3, #2
 8001b50:	d006      	beq.n	8001b60 <USBD_LL_SetupStage+0x3c>
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
    break;
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
 8001b52:	f001 0180 	and.w	r1, r1, #128	; 0x80
 8001b56:	4620      	mov	r0, r4
 8001b58:	f002 f980 	bl	8003e5c <USBD_LL_StallEP>
    break;
  }  
  return USBD_OK;  
}
 8001b5c:	2000      	movs	r0, #0
 8001b5e:	bd38      	pop	{r3, r4, r5, pc}
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &pdev->request);
    break;
    
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
 8001b60:	4629      	mov	r1, r5
 8001b62:	4620      	mov	r0, r4
 8001b64:	f003 ff46 	bl	80059f4 <USBD_StdEPReq>
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
    break;
  }  
  return USBD_OK;  
}
 8001b68:	2000      	movs	r0, #0
 8001b6a:	bd38      	pop	{r3, r4, r5, pc}
  pdev->ep0_data_len = pdev->request.wLength;
  
  switch (pdev->request.bmRequest & 0x1F) 
  {
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &pdev->request);
 8001b6c:	4629      	mov	r1, r5
 8001b6e:	4620      	mov	r0, r4
 8001b70:	f003 fdd2 	bl	8005718 <USBD_StdDevReq>
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
    break;
  }  
  return USBD_OK;  
}
 8001b74:	2000      	movs	r0, #0
 8001b76:	bd38      	pop	{r3, r4, r5, pc}
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &pdev->request);
    break;
    
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &pdev->request);
 8001b78:	4629      	mov	r1, r5
 8001b7a:	4620      	mov	r0, r4
 8001b7c:	f003 ff1c 	bl	80059b8 <USBD_StdItfReq>
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
    break;
  }  
  return USBD_OK;  
}
 8001b80:	2000      	movs	r0, #0
 8001b82:	bd38      	pop	{r3, r4, r5, pc}

08001b84 <USBD_LL_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
 8001b84:	b510      	push	{r4, lr}
 8001b86:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
 8001b88:	b931      	cbnz	r1, 8001b98 <USBD_LL_DataOutStage+0x14>
 8001b8a:	4613      	mov	r3, r2
  {
    pep = &pdev->ep_out[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
 8001b8c:	f8d0 21f4 	ldr.w	r2, [r0, #500]	; 0x1f4
 8001b90:	2a03      	cmp	r2, #3
 8001b92:	d00c      	beq.n	8001bae <USBD_LL_DataOutStage+0x2a>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataOut(pdev, epnum); 
  }  
  return USBD_OK;
}
 8001b94:	2000      	movs	r0, #0
 8001b96:	bd10      	pop	{r4, pc}
        }
        USBD_CtlSendStatus(pdev);
      }
    }
  }
  else if((pdev->pClass->DataOut != NULL)&&
 8001b98:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8001b9c:	699b      	ldr	r3, [r3, #24]
 8001b9e:	2b00      	cmp	r3, #0
 8001ba0:	d0f8      	beq.n	8001b94 <USBD_LL_DataOutStage+0x10>
 8001ba2:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8001ba6:	2a03      	cmp	r2, #3
 8001ba8:	d1f4      	bne.n	8001b94 <USBD_LL_DataOutStage+0x10>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataOut(pdev, epnum); 
 8001baa:	4798      	blx	r3
 8001bac:	e7f2      	b.n	8001b94 <USBD_LL_DataOutStage+0x10>
  {
    pep = &pdev->ep_out[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
    {
      if(pep->rem_length > pep->maxpacket)
 8001bae:	f8d0 110c 	ldr.w	r1, [r0, #268]	; 0x10c
 8001bb2:	f8d0 2110 	ldr.w	r2, [r0, #272]	; 0x110
 8001bb6:	4291      	cmp	r1, r2
 8001bb8:	d80c      	bhi.n	8001bd4 <USBD_LL_DataOutStage+0x50>
                            pdata,
                            MIN(pep->rem_length ,pep->maxpacket));
      }
      else
      {
        if((pdev->pClass->EP0_RxReady != NULL)&&
 8001bba:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8001bbe:	691b      	ldr	r3, [r3, #16]
 8001bc0:	b11b      	cbz	r3, 8001bca <USBD_LL_DataOutStage+0x46>
 8001bc2:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8001bc6:	2a03      	cmp	r2, #3
 8001bc8:	d00f      	beq.n	8001bea <USBD_LL_DataOutStage+0x66>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
        {
          pdev->pClass->EP0_RxReady(pdev); 
        }
        USBD_CtlSendStatus(pdev);
 8001bca:	4620      	mov	r0, r4
 8001bcc:	f004 f87a 	bl	8005cc4 <USBD_CtlSendStatus>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataOut(pdev, epnum); 
  }  
  return USBD_OK;
}
 8001bd0:	2000      	movs	r0, #0
 8001bd2:	bd10      	pop	{r4, pc}
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
    {
      if(pep->rem_length > pep->maxpacket)
      {
        pep->rem_length -=  pep->maxpacket;
 8001bd4:	1a89      	subs	r1, r1, r2
       
        USBD_CtlContinueRx (pdev, 
 8001bd6:	428a      	cmp	r2, r1
 8001bd8:	bf28      	it	cs
 8001bda:	460a      	movcs	r2, r1
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
    {
      if(pep->rem_length > pep->maxpacket)
      {
        pep->rem_length -=  pep->maxpacket;
 8001bdc:	f8c0 110c 	str.w	r1, [r0, #268]	; 0x10c
       
        USBD_CtlContinueRx (pdev, 
 8001be0:	b292      	uxth	r2, r2
 8001be2:	4619      	mov	r1, r3
 8001be4:	f004 f866 	bl	8005cb4 <USBD_CtlContinueRx>
 8001be8:	e7d4      	b.n	8001b94 <USBD_LL_DataOutStage+0x10>
      else
      {
        if((pdev->pClass->EP0_RxReady != NULL)&&
           (pdev->dev_state == USBD_STATE_CONFIGURED))
        {
          pdev->pClass->EP0_RxReady(pdev); 
 8001bea:	4798      	blx	r3
 8001bec:	e7ed      	b.n	8001bca <USBD_LL_DataOutStage+0x46>
 8001bee:	bf00      	nop

08001bf0 <USBD_LL_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
 8001bf0:	b570      	push	{r4, r5, r6, lr}
 8001bf2:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
    
  if(epnum == 0) 
 8001bf4:	b951      	cbnz	r1, 8001c0c <USBD_LL_DataInStage+0x1c>
 8001bf6:	4613      	mov	r3, r2
  {
    pep = &pdev->ep_in[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
 8001bf8:	f8d0 21f4 	ldr.w	r2, [r0, #500]	; 0x1f4
 8001bfc:	2a02      	cmp	r2, #2
 8001bfe:	d015      	beq.n	8001c2c <USBD_LL_DataInStage+0x3c>
          }          
          USBD_CtlReceiveStatus(pdev);
        }
      }
    }
    if (pdev->dev_test_mode == 1)
 8001c00:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
 8001c04:	2b01      	cmp	r3, #1
 8001c06:	d00c      	beq.n	8001c22 <USBD_LL_DataInStage+0x32>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataIn(pdev, epnum); 
  }  
  return USBD_OK;
}
 8001c08:	2000      	movs	r0, #0
 8001c0a:	bd70      	pop	{r4, r5, r6, pc}
    {
      USBD_RunTestMode(pdev); 
      pdev->dev_test_mode = 0;
    }
  }
  else if((pdev->pClass->DataIn != NULL)&& 
 8001c0c:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8001c10:	695b      	ldr	r3, [r3, #20]
 8001c12:	2b00      	cmp	r3, #0
 8001c14:	d0f8      	beq.n	8001c08 <USBD_LL_DataInStage+0x18>
 8001c16:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8001c1a:	2a03      	cmp	r2, #3
 8001c1c:	d1f4      	bne.n	8001c08 <USBD_LL_DataInStage+0x18>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataIn(pdev, epnum); 
 8001c1e:	4798      	blx	r3
 8001c20:	e7f2      	b.n	8001c08 <USBD_LL_DataInStage+0x18>
      }
    }
    if (pdev->dev_test_mode == 1)
    {
      USBD_RunTestMode(pdev); 
      pdev->dev_test_mode = 0;
 8001c22:	2300      	movs	r3, #0
 8001c24:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataIn(pdev, epnum); 
  }  
  return USBD_OK;
}
 8001c28:	2000      	movs	r0, #0
 8001c2a:	bd70      	pop	{r4, r5, r6, pc}
  {
    pep = &pdev->ep_in[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
    {
      if(pep->rem_length > pep->maxpacket)
 8001c2c:	69c6      	ldr	r6, [r0, #28]
 8001c2e:	6a02      	ldr	r2, [r0, #32]
 8001c30:	4296      	cmp	r6, r2
 8001c32:	d823      	bhi.n	8001c7c <USBD_LL_DataInStage+0x8c>
                                NULL,
                                0);  
      }
      else
      { /* last packet is MPS multiple, so send ZLP packet */
        if((pep->total_length % pep->maxpacket == 0) &&
 8001c34:	6983      	ldr	r3, [r0, #24]
 8001c36:	fbb3 f5f2 	udiv	r5, r3, r2
 8001c3a:	fb02 3515 	mls	r5, r2, r5, r3
 8001c3e:	b98d      	cbnz	r5, 8001c64 <USBD_LL_DataInStage+0x74>
 8001c40:	429a      	cmp	r2, r3
 8001c42:	d80f      	bhi.n	8001c64 <USBD_LL_DataInStage+0x74>
           (pep->total_length >= pep->maxpacket) &&
 8001c44:	f8d0 21f8 	ldr.w	r2, [r0, #504]	; 0x1f8
 8001c48:	4293      	cmp	r3, r2
 8001c4a:	d20b      	bcs.n	8001c64 <USBD_LL_DataInStage+0x74>
             (pep->total_length < pdev->ep0_data_len ))
        {
          
          USBD_CtlContinueSendData(pdev , NULL, 0);
 8001c4c:	462a      	mov	r2, r5
 8001c4e:	f004 f819 	bl	8005c84 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0;
 8001c52:	f8c4 51f8 	str.w	r5, [r4, #504]	; 0x1f8
          
        /* Prepare endpoint for premature end of transfer */
        USBD_LL_PrepareReceive (pdev,
 8001c56:	462b      	mov	r3, r5
 8001c58:	462a      	mov	r2, r5
 8001c5a:	4629      	mov	r1, r5
 8001c5c:	4620      	mov	r0, r4
 8001c5e:	f002 f92d 	bl	8003ebc <USBD_LL_PrepareReceive>
 8001c62:	e7cd      	b.n	8001c00 <USBD_LL_DataInStage+0x10>
                                NULL,
                                0);
        }
        else
        {
          if((pdev->pClass->EP0_TxSent != NULL)&&
 8001c64:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8001c68:	68db      	ldr	r3, [r3, #12]
 8001c6a:	b11b      	cbz	r3, 8001c74 <USBD_LL_DataInStage+0x84>
 8001c6c:	f894 21fc 	ldrb.w	r2, [r4, #508]	; 0x1fc
 8001c70:	2a03      	cmp	r2, #3
 8001c72:	d00b      	beq.n	8001c8c <USBD_LL_DataInStage+0x9c>
             (pdev->dev_state == USBD_STATE_CONFIGURED))
          {
            pdev->pClass->EP0_TxSent(pdev); 
          }          
          USBD_CtlReceiveStatus(pdev);
 8001c74:	4620      	mov	r0, r4
 8001c76:	f004 f831 	bl	8005cdc <USBD_CtlReceiveStatus>
 8001c7a:	e7c1      	b.n	8001c00 <USBD_LL_DataInStage+0x10>
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
    {
      if(pep->rem_length > pep->maxpacket)
      {
        pep->rem_length -=  pep->maxpacket;
 8001c7c:	1ab2      	subs	r2, r6, r2
 8001c7e:	460d      	mov	r5, r1
 8001c80:	61c2      	str	r2, [r0, #28]
        
        USBD_CtlContinueSendData (pdev, 
 8001c82:	4619      	mov	r1, r3
 8001c84:	b292      	uxth	r2, r2
 8001c86:	f003 fffd 	bl	8005c84 <USBD_CtlContinueSendData>
 8001c8a:	e7e4      	b.n	8001c56 <USBD_LL_DataInStage+0x66>
        else
        {
          if((pdev->pClass->EP0_TxSent != NULL)&&
             (pdev->dev_state == USBD_STATE_CONFIGURED))
          {
            pdev->pClass->EP0_TxSent(pdev); 
 8001c8c:	4620      	mov	r0, r4
 8001c8e:	4798      	blx	r3
 8001c90:	e7f0      	b.n	8001c74 <USBD_LL_DataInStage+0x84>
 8001c92:	bf00      	nop

08001c94 <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 8001c94:	b538      	push	{r3, r4, r5, lr}
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 8001c96:	2340      	movs	r3, #64	; 0x40
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 8001c98:	4604      	mov	r4, r0
  USBD_LL_OpenEP(pdev,
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8001c9a:	461d      	mov	r5, r3
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 8001c9c:	2200      	movs	r2, #0
 8001c9e:	4611      	mov	r1, r2
 8001ca0:	f002 f8ca 	bl	8003e38 <USBD_LL_OpenEP>
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
 8001ca4:	462b      	mov	r3, r5
 8001ca6:	2200      	movs	r2, #0
  USBD_LL_OpenEP(pdev,
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8001ca8:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
 8001cac:	4620      	mov	r0, r4
 8001cae:	2180      	movs	r1, #128	; 0x80
 8001cb0:	f002 f8c2 	bl	8003e38 <USBD_LL_OpenEP>
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
  
  if (pdev->pClassData) 
 8001cb4:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8001cb8:	2201      	movs	r2, #1
  USBD_LL_OpenEP(pdev,
              0x80,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 8001cba:	6225      	str	r5, [r4, #32]
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8001cbc:	f884 21fc 	strb.w	r2, [r4, #508]	; 0x1fc
  
  if (pdev->pClassData) 
 8001cc0:	b12b      	cbz	r3, 8001cce <USBD_LL_Reset+0x3a>
    pdev->pClass->DeInit(pdev, pdev->dev_config);  
 8001cc2:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8001cc6:	7921      	ldrb	r1, [r4, #4]
 8001cc8:	685b      	ldr	r3, [r3, #4]
 8001cca:	4620      	mov	r0, r4
 8001ccc:	4798      	blx	r3
 
  
  return USBD_OK;
}
 8001cce:	2000      	movs	r0, #0
 8001cd0:	bd38      	pop	{r3, r4, r5, pc}
 8001cd2:	bf00      	nop

08001cd4 <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 8001cd4:	7401      	strb	r1, [r0, #16]
  return USBD_OK;
}
 8001cd6:	2000      	movs	r0, #0
 8001cd8:	4770      	bx	lr
 8001cda:	bf00      	nop

08001cdc <USBD_LL_Suspend>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
 8001cdc:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 8001ce0:	2304      	movs	r3, #4
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
 8001ce2:	f880 21fd 	strb.w	r2, [r0, #509]	; 0x1fd
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 8001ce6:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 8001cea:	2000      	movs	r0, #0
 8001cec:	4770      	bx	lr
 8001cee:	bf00      	nop

08001cf0 <USBD_LL_Resume>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
 8001cf0:	4603      	mov	r3, r0
  pdev->dev_state = pdev->dev_old_state;  
 8001cf2:	f890 21fd 	ldrb.w	r2, [r0, #509]	; 0x1fd
  return USBD_OK;
}
 8001cf6:	2000      	movs	r0, #0
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_state = pdev->dev_old_state;  
 8001cf8:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
  return USBD_OK;
}
 8001cfc:	4770      	bx	lr
 8001cfe:	bf00      	nop

08001d00 <USBD_LL_SOF>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
 8001d00:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8001d04:	2a03      	cmp	r2, #3
 8001d06:	d001      	beq.n	8001d0c <USBD_LL_SOF+0xc>
    {
      pdev->pClass->SOF(pdev);
    }
  }
  return USBD_OK;
}
 8001d08:	2000      	movs	r0, #0
 8001d0a:	4770      	bx	lr
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
 8001d0c:	b508      	push	{r3, lr}
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
  {
    if(pdev->pClass->SOF != NULL)
 8001d0e:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8001d12:	69db      	ldr	r3, [r3, #28]
 8001d14:	b103      	cbz	r3, 8001d18 <USBD_LL_SOF+0x18>
    {
      pdev->pClass->SOF(pdev);
 8001d16:	4798      	blx	r3
    }
  }
  return USBD_OK;
}
 8001d18:	2000      	movs	r0, #0
 8001d1a:	bd08      	pop	{r3, pc}

08001d1c <StartDefaultTask>:

/* USER CODE END 4 */

/* StartDefaultTask function */
void StartDefaultTask(void const * argument)
{
 8001d1c:	b508      	push	{r3, lr}
  /* init code for USB_DEVICE */
  MX_USB_DEVICE_Init();
 8001d1e:	f003 ffe9 	bl	8005cf4 <MX_USB_DEVICE_Init>

  /* USER CODE BEGIN 5 */
  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
 8001d22:	2001      	movs	r0, #1
 8001d24:	f002 fa6c 	bl	8004200 <osDelay>
 8001d28:	e7fb      	b.n	8001d22 <StartDefaultTask+0x6>
 8001d2a:	bf00      	nop

08001d2c <UsbWrite>:
  /* USER CODE END UsbRead */
}

/* UsbWrite function */
void UsbWrite(void const * argument)
{
 8001d2c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN UsbWrite */
  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
 8001d2e:	2001      	movs	r0, #1
 8001d30:	f002 fa66 	bl	8004200 <osDelay>
 8001d34:	e7fb      	b.n	8001d2e <UsbWrite+0x2>
 8001d36:	bf00      	nop

08001d38 <UsbRead>:
 8001d38:	b508      	push	{r3, lr}
 8001d3a:	2001      	movs	r0, #1
 8001d3c:	f002 fa60 	bl	8004200 <osDelay>
 8001d40:	e7fb      	b.n	8001d3a <UsbRead+0x2>
 8001d42:	bf00      	nop

08001d44 <LedFlash>:
 8001d44:	b508      	push	{r3, lr}
 8001d46:	2001      	movs	r0, #1
 8001d48:	f002 fa5a 	bl	8004200 <osDelay>
 8001d4c:	e7fb      	b.n	8001d46 <LedFlash+0x2>
 8001d4e:	bf00      	nop

08001d50 <SystemClock_Config>:
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 8001d50:	b570      	push	{r4, r5, r6, lr}
 8001d52:	b094      	sub	sp, #80	; 0x50
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE
                              |RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
 8001d54:	2400      	movs	r4, #0
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE
                              |RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8001d56:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 8001d5a:	2301      	movs	r3, #1
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8001d5c:	2502      	movs	r5, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
 8001d5e:	f44f 11e0 	mov.w	r1, #1835008	; 0x1c0000

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE
 8001d62:	260d      	movs	r6, #13
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8001d64:	a80a      	add	r0, sp, #40	; 0x28
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE
                              |RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8001d66:	920b      	str	r2, [sp, #44]	; 0x2c
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8001d68:	9212      	str	r2, [sp, #72]	; 0x48

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE
 8001d6a:	960a      	str	r6, [sp, #40]	; 0x28
                              |RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 8001d6c:	930d      	str	r3, [sp, #52]	; 0x34
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 8001d6e:	9310      	str	r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
 8001d70:	9113      	str	r1, [sp, #76]	; 0x4c
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8001d72:	260f      	movs	r6, #15
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE
                              |RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
 8001d74:	940c      	str	r4, [sp, #48]	; 0x30
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8001d76:	9511      	str	r5, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8001d78:	f7fe fc2e 	bl	80005d8 <HAL_RCC_OscConfig>
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
 8001d7c:	4629      	mov	r1, r5

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8001d7e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
 8001d82:	a805      	add	r0, sp, #20

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8001d84:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8001d86:	9506      	str	r5, [sp, #24]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8001d88:	9407      	str	r4, [sp, #28]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8001d8a:	9409      	str	r4, [sp, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8001d8c:	9605      	str	r6, [sp, #20]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
 8001d8e:	f7fe ff0f 	bl	8000bb0 <HAL_RCC_ClockConfig>

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_ADC
 8001d92:	2113      	movs	r1, #19
                              |RCC_PERIPHCLK_USB;
  PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 8001d94:	f44f 7280 	mov.w	r2, #256	; 0x100
  PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV6;
 8001d98:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  PeriphClkInit.UsbClockSelection = RCC_USBPLLCLK_DIV1_5;
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);
 8001d9c:	a801      	add	r0, sp, #4
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_ADC
 8001d9e:	9101      	str	r1, [sp, #4]
                              |RCC_PERIPHCLK_USB;
  PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 8001da0:	9202      	str	r2, [sp, #8]
  PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV6;
 8001da2:	9303      	str	r3, [sp, #12]
  PeriphClkInit.UsbClockSelection = RCC_USBPLLCLK_DIV1_5;
 8001da4:	9404      	str	r4, [sp, #16]
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);
 8001da6:	f7fe f9b1 	bl	800010c <HAL_RCCEx_PeriphCLKConfig>

  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8001daa:	f7ff f83d 	bl	8000e28 <HAL_RCC_GetHCLKFreq>
 8001dae:	4b08      	ldr	r3, [pc, #32]	; (8001dd0 <SystemClock_Config+0x80>)
 8001db0:	fba3 3000 	umull	r3, r0, r3, r0
 8001db4:	0980      	lsrs	r0, r0, #6
 8001db6:	f7fe fb83 	bl	80004c0 <HAL_SYSTICK_Config>

  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 8001dba:	2004      	movs	r0, #4
 8001dbc:	f7fe fb98 	bl	80004f0 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 8001dc0:	4622      	mov	r2, r4
 8001dc2:	4631      	mov	r1, r6
 8001dc4:	f04f 30ff 	mov.w	r0, #4294967295
 8001dc8:	f7fe fb36 	bl	8000438 <HAL_NVIC_SetPriority>
}
 8001dcc:	b014      	add	sp, #80	; 0x50
 8001dce:	bd70      	pop	{r4, r5, r6, pc}
 8001dd0:	10624dd3 	.word	0x10624dd3

08001dd4 <main>:
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

int main(void)
{
 8001dd4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
 8001dd8:	4dbb      	ldr	r5, [pc, #748]	; (80020c8 <main+0x2f4>)
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

int main(void)
{
 8001dda:	b0a1      	sub	sp, #132	; 0x84
  /* USER CODE END 1 */

  /* MCU Configuration----------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8001ddc:	f7fe fad2 	bl	8000384 <HAL_Init>

  /* Configure the system clock */
  SystemClock_Config();
 8001de0:	f7ff ffb6 	bl	8001d50 <SystemClock_Config>
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
 8001de4:	69ab      	ldr	r3, [r5, #24]
  __GPIOD_CLK_ENABLE();
  __GPIOA_CLK_ENABLE();
  __GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LedPin_GPIO_Port, LedPin_Pin, GPIO_PIN_RESET);
 8001de6:	2200      	movs	r2, #0
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
 8001de8:	f043 0310 	orr.w	r3, r3, #16
 8001dec:	61ab      	str	r3, [r5, #24]
 8001dee:	69ab      	ldr	r3, [r5, #24]
    /**Common config 
    */
  hadc1.Instance = ADC1;
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
  hadc1.Init.ContinuousConvMode = ENABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8001df0:	4614      	mov	r4, r2
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
 8001df2:	f003 0310 	and.w	r3, r3, #16
 8001df6:	9304      	str	r3, [sp, #16]
 8001df8:	9b04      	ldr	r3, [sp, #16]
  __GPIOD_CLK_ENABLE();
 8001dfa:	69ab      	ldr	r3, [r5, #24]
  __GPIOA_CLK_ENABLE();
  __GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LedPin_GPIO_Port, LedPin_Pin, GPIO_PIN_RESET);
 8001dfc:	f44f 5100 	mov.w	r1, #8192	; 0x2000

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
  __GPIOD_CLK_ENABLE();
 8001e00:	f043 0320 	orr.w	r3, r3, #32
 8001e04:	61ab      	str	r3, [r5, #24]
 8001e06:	69ab      	ldr	r3, [r5, #24]
  __GPIOA_CLK_ENABLE();
  __GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LedPin_GPIO_Port, LedPin_Pin, GPIO_PIN_RESET);
 8001e08:	48b0      	ldr	r0, [pc, #704]	; (80020cc <main+0x2f8>)

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
  __GPIOD_CLK_ENABLE();
 8001e0a:	f003 0320 	and.w	r3, r3, #32
 8001e0e:	9305      	str	r3, [sp, #20]
 8001e10:	9b05      	ldr	r3, [sp, #20]
  __GPIOA_CLK_ENABLE();
 8001e12:	69ab      	ldr	r3, [r5, #24]
  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LedPin_GPIO_Port, LedPin_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : LedPin_Pin */
  GPIO_InitStruct.Pin = LedPin_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001e14:	2701      	movs	r7, #1
  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
  __GPIOD_CLK_ENABLE();
  __GPIOA_CLK_ENABLE();
 8001e16:	f043 0304 	orr.w	r3, r3, #4
 8001e1a:	61ab      	str	r3, [r5, #24]
 8001e1c:	69ab      	ldr	r3, [r5, #24]
  HAL_GPIO_WritePin(LedPin_GPIO_Port, LedPin_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : LedPin_Pin */
  GPIO_InitStruct.Pin = LedPin_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8001e1e:	f04f 0803 	mov.w	r8, #3
  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
  __GPIOD_CLK_ENABLE();
  __GPIOA_CLK_ENABLE();
 8001e22:	f003 0304 	and.w	r3, r3, #4
 8001e26:	9306      	str	r3, [sp, #24]
 8001e28:	9b06      	ldr	r3, [sp, #24]
  __GPIOB_CLK_ENABLE();
 8001e2a:	69ab      	ldr	r3, [r5, #24]

  ADC_ChannelConfTypeDef sConfig;

    /**Common config 
    */
  hadc1.Instance = ADC1;
 8001e2c:	4ea8      	ldr	r6, [pc, #672]	; (80020d0 <main+0x2fc>)

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
  __GPIOD_CLK_ENABLE();
  __GPIOA_CLK_ENABLE();
  __GPIOB_CLK_ENABLE();
 8001e2e:	f043 0308 	orr.w	r3, r3, #8
 8001e32:	61ab      	str	r3, [r5, #24]
 8001e34:	69ab      	ldr	r3, [r5, #24]
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);

    /**Configure Regular Channel 
    */
  sConfig.Channel = ADC_CHANNEL_1;
  sConfig.Rank = 2;
 8001e36:	f04f 0902 	mov.w	r9, #2

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
  __GPIOD_CLK_ENABLE();
  __GPIOA_CLK_ENABLE();
  __GPIOB_CLK_ENABLE();
 8001e3a:	f003 0308 	and.w	r3, r3, #8
 8001e3e:	9307      	str	r3, [sp, #28]
 8001e40:	9b07      	ldr	r3, [sp, #28]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LedPin_GPIO_Port, LedPin_Pin, GPIO_PIN_RESET);
 8001e42:	f001 fce1 	bl	8003808 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : LedPin_Pin */
  GPIO_InitStruct.Pin = LedPin_Pin;
 8001e46:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
  HAL_GPIO_Init(LedPin_GPIO_Port, &GPIO_InitStruct);
 8001e4a:	a919      	add	r1, sp, #100	; 0x64
 8001e4c:	489f      	ldr	r0, [pc, #636]	; (80020cc <main+0x2f8>)

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LedPin_GPIO_Port, LedPin_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : LedPin_Pin */
  GPIO_InitStruct.Pin = LedPin_Pin;
 8001e4e:	9319      	str	r3, [sp, #100]	; 0x64
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001e50:	971a      	str	r7, [sp, #104]	; 0x68
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8001e52:	f8cd 8070 	str.w	r8, [sp, #112]	; 0x70
  HAL_GPIO_Init(LedPin_GPIO_Port, &GPIO_InitStruct);
 8001e56:	f001 fbeb 	bl	8003630 <HAL_GPIO_Init>
  * Enable DMA controller clock
  */
void MX_DMA_Init(void) 
{
  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
 8001e5a:	696b      	ldr	r3, [r5, #20]

  /* DMA interrupt init */
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
 8001e5c:	4622      	mov	r2, r4
  * Enable DMA controller clock
  */
void MX_DMA_Init(void) 
{
  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
 8001e5e:	433b      	orrs	r3, r7
 8001e60:	616b      	str	r3, [r5, #20]
 8001e62:	696b      	ldr	r3, [r5, #20]

  /* DMA interrupt init */
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
 8001e64:	2105      	movs	r1, #5
  * Enable DMA controller clock
  */
void MX_DMA_Init(void) 
{
  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
 8001e66:	403b      	ands	r3, r7
 8001e68:	9303      	str	r3, [sp, #12]

  /* DMA interrupt init */
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
 8001e6a:	200b      	movs	r0, #11
  * Enable DMA controller clock
  */
void MX_DMA_Init(void) 
{
  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
 8001e6c:	9b03      	ldr	r3, [sp, #12]

  /* DMA interrupt init */
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
 8001e6e:	f7fe fae3 	bl	8000438 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 8001e72:	200b      	movs	r0, #11
 8001e74:	f7fe fb18 	bl	80004a8 <HAL_NVIC_EnableIRQ>

  ADC_ChannelConfTypeDef sConfig;

    /**Common config 
    */
  hadc1.Instance = ADC1;
 8001e78:	4996      	ldr	r1, [pc, #600]	; (80020d4 <main+0x300>)
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
 8001e7a:	f44f 7280 	mov.w	r2, #256	; 0x100
  hadc1.Init.ContinuousConvMode = ENABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8001e7e:	f44f 2360 	mov.w	r3, #917504	; 0xe0000
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.NbrOfConversion = 5;
 8001e82:	2505      	movs	r5, #5
  HAL_ADC_Init(&hadc1);
 8001e84:	4630      	mov	r0, r6
  ADC_ChannelConfTypeDef sConfig;

    /**Common config 
    */
  hadc1.Instance = ADC1;
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
 8001e86:	60b2      	str	r2, [r6, #8]
  hadc1.Init.ContinuousConvMode = ENABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8001e88:	61f3      	str	r3, [r6, #28]

    /**Common config 
    */
  hadc1.Instance = ADC1;
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
  hadc1.Init.ContinuousConvMode = ENABLE;
 8001e8a:	60f7      	str	r7, [r6, #12]

  ADC_ChannelConfTypeDef sConfig;

    /**Common config 
    */
  hadc1.Instance = ADC1;
 8001e8c:	6031      	str	r1, [r6, #0]
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
  hadc1.Init.ContinuousConvMode = ENABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.NbrOfConversion = 5;
 8001e8e:	6135      	str	r5, [r6, #16]
    /**Common config 
    */
  hadc1.Instance = ADC1;
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
  hadc1.Init.ContinuousConvMode = ENABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8001e90:	6174      	str	r4, [r6, #20]
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8001e92:	6074      	str	r4, [r6, #4]
  hadc1.Init.NbrOfConversion = 5;
  HAL_ADC_Init(&hadc1);
 8001e94:	f7ff f922 	bl	80010dc <HAL_ADC_Init>
    /**Configure Regular Channel 
    */
  sConfig.Channel = ADC_CHANNEL_0;
  sConfig.Rank = 1;
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);
 8001e98:	a919      	add	r1, sp, #100	; 0x64
 8001e9a:	4630      	mov	r0, r6
  HAL_ADC_Init(&hadc1);

    /**Configure Regular Channel 
    */
  sConfig.Channel = ADC_CHANNEL_0;
  sConfig.Rank = 1;
 8001e9c:	971a      	str	r7, [sp, #104]	; 0x68
  hadc1.Init.NbrOfConversion = 5;
  HAL_ADC_Init(&hadc1);

    /**Configure Regular Channel 
    */
  sConfig.Channel = ADC_CHANNEL_0;
 8001e9e:	9419      	str	r4, [sp, #100]	; 0x64
  sConfig.Rank = 1;
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 8001ea0:	941b      	str	r4, [sp, #108]	; 0x6c
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);
 8001ea2:	f7ff f823 	bl	8000eec <HAL_ADC_ConfigChannel>

    /**Configure Regular Channel 
    */
  sConfig.Channel = ADC_CHANNEL_1;
  sConfig.Rank = 2;
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);
 8001ea6:	a919      	add	r1, sp, #100	; 0x64
 8001ea8:	4630      	mov	r0, r6
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);

    /**Configure Regular Channel 
    */
  sConfig.Channel = ADC_CHANNEL_1;
 8001eaa:	9719      	str	r7, [sp, #100]	; 0x64
  sConfig.Rank = 2;
 8001eac:	f8cd 9068 	str.w	r9, [sp, #104]	; 0x68
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);
 8001eb0:	f7ff f81c 	bl	8000eec <HAL_ADC_ConfigChannel>

    /**Configure Regular Channel 
    */
  sConfig.Channel = ADC_CHANNEL_2;
  sConfig.Rank = 3;
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);
 8001eb4:	a919      	add	r1, sp, #100	; 0x64
 8001eb6:	4630      	mov	r0, r6
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);

    /**Configure Regular Channel 
    */
  sConfig.Channel = ADC_CHANNEL_2;
  sConfig.Rank = 3;
 8001eb8:	f8cd 8068 	str.w	r8, [sp, #104]	; 0x68
  sConfig.Rank = 2;
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);

    /**Configure Regular Channel 
    */
  sConfig.Channel = ADC_CHANNEL_2;
 8001ebc:	f8cd 9064 	str.w	r9, [sp, #100]	; 0x64
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);

    /**Configure Regular Channel 
    */
  sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;
  sConfig.Rank = 4;
 8001ec0:	f04f 0804 	mov.w	r8, #4

    /**Configure Regular Channel 
    */
  sConfig.Channel = ADC_CHANNEL_2;
  sConfig.Rank = 3;
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);
 8001ec4:	f7ff f812 	bl	8000eec <HAL_ADC_ConfigChannel>

    /**Configure Regular Channel 
    */
  sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;
 8001ec8:	2310      	movs	r3, #16
  sConfig.Rank = 4;
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);
 8001eca:	a919      	add	r1, sp, #100	; 0x64
 8001ecc:	4630      	mov	r0, r6
  sConfig.Rank = 3;
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);

    /**Configure Regular Channel 
    */
  sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;
 8001ece:	9319      	str	r3, [sp, #100]	; 0x64
  sConfig.Rank = 4;
 8001ed0:	f8cd 8068 	str.w	r8, [sp, #104]	; 0x68
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);
 8001ed4:	f7ff f80a 	bl	8000eec <HAL_ADC_ConfigChannel>

    /**Configure Regular Channel 
    */
  sConfig.Channel = ADC_CHANNEL_VREFINT;
  sConfig.Rank = 5;
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);
 8001ed8:	a919      	add	r1, sp, #100	; 0x64
  sConfig.Rank = 4;
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);

    /**Configure Regular Channel 
    */
  sConfig.Channel = ADC_CHANNEL_VREFINT;
 8001eda:	2311      	movs	r3, #17
  sConfig.Rank = 5;
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);
 8001edc:	4630      	mov	r0, r6
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);

    /**Configure Regular Channel 
    */
  sConfig.Channel = ADC_CHANNEL_VREFINT;
  sConfig.Rank = 5;
 8001ede:	951a      	str	r5, [sp, #104]	; 0x68
  sConfig.Rank = 4;
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);

    /**Configure Regular Channel 
    */
  sConfig.Channel = ADC_CHANNEL_VREFINT;
 8001ee0:	9319      	str	r3, [sp, #100]	; 0x64
  sConfig.Rank = 5;
  HAL_ADC_ConfigChannel(&hadc1, &sConfig);
 8001ee2:	f7ff f803 	bl	8000eec <HAL_ADC_ConfigChannel>

/* CRC init function */
void MX_CRC_Init(void)
{

  hcrc.Instance = CRC;
 8001ee6:	4b7c      	ldr	r3, [pc, #496]	; (80020d8 <main+0x304>)
 8001ee8:	4a7c      	ldr	r2, [pc, #496]	; (80020dc <main+0x308>)
  HAL_CRC_Init(&hcrc);
 8001eea:	4618      	mov	r0, r3

/* CRC init function */
void MX_CRC_Init(void)
{

  hcrc.Instance = CRC;
 8001eec:	601a      	str	r2, [r3, #0]
  HAL_CRC_Init(&hcrc);
 8001eee:	f7fe fb0b 	bl	8000508 <HAL_CRC_Init>
void MX_IWDG_Init(void)
{

  hiwdg.Instance = IWDG;
  hiwdg.Init.Prescaler = IWDG_PRESCALER_4;
  hiwdg.Init.Reload = 4095;
 8001ef2:	f640 72ff 	movw	r2, #4095	; 0xfff

/* IWDG init function */
void MX_IWDG_Init(void)
{

  hiwdg.Instance = IWDG;
 8001ef6:	4b7a      	ldr	r3, [pc, #488]	; (80020e0 <main+0x30c>)
 8001ef8:	497a      	ldr	r1, [pc, #488]	; (80020e4 <main+0x310>)
  RTC_TimeTypeDef sTime;
  RTC_DateTypeDef DateToUpdate;

    /**Initialize RTC and set the Time and Date 
    */
  hrtc.Instance = RTC;
 8001efa:	4d7b      	ldr	r5, [pc, #492]	; (80020e8 <main+0x314>)
{

  hiwdg.Instance = IWDG;
  hiwdg.Init.Prescaler = IWDG_PRESCALER_4;
  hiwdg.Init.Reload = 4095;
  HAL_IWDG_Init(&hiwdg);
 8001efc:	4618      	mov	r0, r3

/* IWDG init function */
void MX_IWDG_Init(void)
{

  hiwdg.Instance = IWDG;
 8001efe:	e883 0012 	stmia.w	r3, {r1, r4}
  hiwdg.Init.Prescaler = IWDG_PRESCALER_4;
  hiwdg.Init.Reload = 4095;
 8001f02:	609a      	str	r2, [r3, #8]
  HAL_IWDG_Init(&hiwdg);
 8001f04:	f7fe fb14 	bl	8000530 <HAL_IWDG_Init>
  RTC_TimeTypeDef sTime;
  RTC_DateTypeDef DateToUpdate;

    /**Initialize RTC and set the Time and Date 
    */
  hrtc.Instance = RTC;
 8001f08:	4a78      	ldr	r2, [pc, #480]	; (80020ec <main+0x318>)
  hrtc.Init.AsynchPrediv = RTC_AUTO_1_SECOND;
 8001f0a:	f04f 33ff 	mov.w	r3, #4294967295
  hrtc.Init.OutPut = RTC_OUTPUTSOURCE_NONE;
  HAL_RTC_Init(&hrtc);
 8001f0e:	4628      	mov	r0, r5
  RTC_DateTypeDef DateToUpdate;

    /**Initialize RTC and set the Time and Date 
    */
  hrtc.Instance = RTC;
  hrtc.Init.AsynchPrediv = RTC_AUTO_1_SECOND;
 8001f10:	e885 001c 	stmia.w	r5, {r2, r3, r4}
  hrtc.Init.OutPut = RTC_OUTPUTSOURCE_NONE;
  HAL_RTC_Init(&hrtc);
 8001f14:	f003 f8aa 	bl	800506c <HAL_RTC_Init>

  sTime.Hours = 0x1;
  sTime.Minutes = 0x0;
  sTime.Seconds = 0x0;

  HAL_RTC_SetTime(&hrtc, &sTime, FORMAT_BCD);
 8001f18:	463a      	mov	r2, r7
 8001f1a:	4628      	mov	r0, r5
 8001f1c:	a914      	add	r1, sp, #80	; 0x50
  hrtc.Instance = RTC;
  hrtc.Init.AsynchPrediv = RTC_AUTO_1_SECOND;
  hrtc.Init.OutPut = RTC_OUTPUTSOURCE_NONE;
  HAL_RTC_Init(&hrtc);

  sTime.Hours = 0x1;
 8001f1e:	f88d 7050 	strb.w	r7, [sp, #80]	; 0x50
  sTime.Minutes = 0x0;
 8001f22:	f88d 4051 	strb.w	r4, [sp, #81]	; 0x51
  sTime.Seconds = 0x0;
 8001f26:	f88d 4052 	strb.w	r4, [sp, #82]	; 0x52

  HAL_RTC_SetTime(&hrtc, &sTime, FORMAT_BCD);
 8001f2a:	f002 ff83 	bl	8004e34 <HAL_RTC_SetTime>
  DateToUpdate.WeekDay = RTC_WEEKDAY_MONDAY;
  DateToUpdate.Month = RTC_MONTH_JANUARY;
  DateToUpdate.Date = 0x1;
  DateToUpdate.Year = 0x16;

  HAL_RTC_SetDate(&hrtc, &DateToUpdate, FORMAT_BCD);
 8001f2e:	463a      	mov	r2, r7
  HAL_RTC_SetTime(&hrtc, &sTime, FORMAT_BCD);

  DateToUpdate.WeekDay = RTC_WEEKDAY_MONDAY;
  DateToUpdate.Month = RTC_MONTH_JANUARY;
  DateToUpdate.Date = 0x1;
  DateToUpdate.Year = 0x16;
 8001f30:	2316      	movs	r3, #22

  HAL_RTC_SetDate(&hrtc, &DateToUpdate, FORMAT_BCD);
 8001f32:	4628      	mov	r0, r5
 8001f34:	a919      	add	r1, sp, #100	; 0x64
  sTime.Minutes = 0x0;
  sTime.Seconds = 0x0;

  HAL_RTC_SetTime(&hrtc, &sTime, FORMAT_BCD);

  DateToUpdate.WeekDay = RTC_WEEKDAY_MONDAY;
 8001f36:	f88d 7064 	strb.w	r7, [sp, #100]	; 0x64
  DateToUpdate.Month = RTC_MONTH_JANUARY;
 8001f3a:	f88d 7065 	strb.w	r7, [sp, #101]	; 0x65
  DateToUpdate.Date = 0x1;
 8001f3e:	f88d 7066 	strb.w	r7, [sp, #102]	; 0x66
  DateToUpdate.Year = 0x16;
 8001f42:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67

  HAL_RTC_SetDate(&hrtc, &DateToUpdate, FORMAT_BCD);
 8001f46:	f002 ffed 	bl	8004f24 <HAL_RTC_SetDate>

  TIM_ClockConfigTypeDef sClockSourceConfig;
  TIM_MasterConfigTypeDef sMasterConfig;

  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 35999;
 8001f4a:	f648 429f 	movw	r2, #35999	; 0x8c9f
  TIM_OC_InitTypeDef sConfigOC;

  htim3.Instance = TIM3;
  htim3.Init.Prescaler = 720;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 65535;
 8001f4e:	f64f 7aff 	movw	sl, #65535	; 0xffff
{

  TIM_ClockConfigTypeDef sClockSourceConfig;
  TIM_MasterConfigTypeDef sMasterConfig;

  htim2.Instance = TIM2;
 8001f52:	4e67      	ldr	r6, [pc, #412]	; (80020f0 <main+0x31c>)
  htim2.Init.Prescaler = 35999;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 1000;
 8001f54:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
{

  TIM_ClockConfigTypeDef sClockSourceConfig;
  TIM_MasterConfigTypeDef sMasterConfig;

  htim2.Instance = TIM2;
 8001f58:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  htim2.Init.Prescaler = 35999;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 1000;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  HAL_TIM_Base_Init(&htim2);
 8001f5c:	4630      	mov	r0, r6

  TIM_ClockConfigTypeDef sClockSourceConfig;
  TIM_MasterConfigTypeDef sMasterConfig;

  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 35999;
 8001f5e:	e886 0006 	stmia.w	r6, {r1, r2}
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 1000;
 8001f62:	60f3      	str	r3, [r6, #12]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  HAL_TIM_Base_Init(&htim2);

  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8001f64:	f44f 5980 	mov.w	r9, #4096	; 0x1000
  TIM_ClockConfigTypeDef sClockSourceConfig;
  TIM_MasterConfigTypeDef sMasterConfig;

  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 35999;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8001f68:	60b4      	str	r4, [r6, #8]
  htim2.Init.Period = 1000;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8001f6a:	6134      	str	r4, [r6, #16]
  HAL_TIM_Base_Init(&htim2);
 8001f6c:	f003 fb04 	bl	8005578 <HAL_TIM_Base_Init>

  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig);
 8001f70:	a919      	add	r1, sp, #100	; 0x64
 8001f72:	4630      	mov	r0, r6

  TIM_ClockConfigTypeDef sClockSourceConfig;
  TIM_MasterConfigTypeDef sMasterConfig;
  TIM_OC_InitTypeDef sConfigOC;

  htim3.Instance = TIM3;
 8001f74:	4d5f      	ldr	r5, [pc, #380]	; (80020f4 <main+0x320>)
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 1000;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  HAL_TIM_Base_Init(&htim2);

  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8001f76:	f8cd 9064 	str.w	r9, [sp, #100]	; 0x64
  HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig);
 8001f7a:	f003 f94b 	bl	8005214 <HAL_TIM_ConfigClockSource>

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig);
 8001f7e:	a914      	add	r1, sp, #80	; 0x50
 8001f80:	4630      	mov	r0, r6
  HAL_TIM_Base_Init(&htim2);

  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig);

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8001f82:	9414      	str	r4, [sp, #80]	; 0x50
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8001f84:	9415      	str	r4, [sp, #84]	; 0x54
  HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig);
 8001f86:	f003 fed1 	bl	8005d2c <HAL_TIMEx_MasterConfigSynchronization>

  TIM_ClockConfigTypeDef sClockSourceConfig;
  TIM_MasterConfigTypeDef sMasterConfig;
  TIM_OC_InitTypeDef sConfigOC;

  htim3.Instance = TIM3;
 8001f8a:	4b5b      	ldr	r3, [pc, #364]	; (80020f8 <main+0x324>)
  htim3.Init.Prescaler = 720;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 65535;
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  HAL_TIM_Base_Init(&htim3);
 8001f8c:	4628      	mov	r0, r5
  TIM_ClockConfigTypeDef sClockSourceConfig;
  TIM_MasterConfigTypeDef sMasterConfig;
  TIM_OC_InitTypeDef sConfigOC;

  htim3.Instance = TIM3;
  htim3.Init.Prescaler = 720;
 8001f8e:	f44f 7b34 	mov.w	fp, #720	; 0x2d0
 8001f92:	e885 0808 	stmia.w	r5, {r3, fp}
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 8001f96:	60ac      	str	r4, [r5, #8]
  htim3.Init.Period = 65535;
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8001f98:	612c      	str	r4, [r5, #16]
  TIM_OC_InitTypeDef sConfigOC;

  htim3.Instance = TIM3;
  htim3.Init.Prescaler = 720;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 65535;
 8001f9a:	f8c5 a00c 	str.w	sl, [r5, #12]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  HAL_TIM_Base_Init(&htim3);
 8001f9e:	f003 faeb 	bl	8005578 <HAL_TIM_Base_Init>

  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig);
 8001fa2:	a914      	add	r1, sp, #80	; 0x50
 8001fa4:	4628      	mov	r0, r5
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 65535;
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  HAL_TIM_Base_Init(&htim3);

  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8001fa6:	f8cd 9050 	str.w	r9, [sp, #80]	; 0x50
  HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig);
 8001faa:	f003 f933 	bl	8005214 <HAL_TIM_ConfigClockSource>

  HAL_TIM_PWM_Init(&htim3);
 8001fae:	4628      	mov	r0, r5
 8001fb0:	f003 fafe 	bl	80055b0 <HAL_TIM_PWM_Init>

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig);
 8001fb4:	4628      	mov	r0, r5
 8001fb6:	a90f      	add	r1, sp, #60	; 0x3c

  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8001fb8:	2660      	movs	r6, #96	; 0x60
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig);

  HAL_TIM_PWM_Init(&htim3);

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8001fba:	940f      	str	r4, [sp, #60]	; 0x3c
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8001fbc:	9410      	str	r4, [sp, #64]	; 0x40
  HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig);
 8001fbe:	f003 feb5 	bl	8005d2c <HAL_TIMEx_MasterConfigSynchronization>

  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1);
 8001fc2:	4622      	mov	r2, r4
 8001fc4:	a919      	add	r1, sp, #100	; 0x64
 8001fc6:	4628      	mov	r0, r5

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig);

  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8001fc8:	9619      	str	r6, [sp, #100]	; 0x64
  sConfigOC.Pulse = 0;
 8001fca:	941a      	str	r4, [sp, #104]	; 0x68
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8001fcc:	941b      	str	r4, [sp, #108]	; 0x6c
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8001fce:	941d      	str	r4, [sp, #116]	; 0x74
  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1);
 8001fd0:	f003 fb38 	bl	8005644 <HAL_TIM_PWM_ConfigChannel>

  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2);
 8001fd4:	4642      	mov	r2, r8
 8001fd6:	a919      	add	r1, sp, #100	; 0x64
 8001fd8:	4628      	mov	r0, r5
 8001fda:	f003 fb33 	bl	8005644 <HAL_TIM_PWM_ConfigChannel>

  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_3);
 8001fde:	2208      	movs	r2, #8
 8001fe0:	a919      	add	r1, sp, #100	; 0x64
 8001fe2:	4628      	mov	r0, r5
 8001fe4:	f003 fb2e 	bl	8005644 <HAL_TIM_PWM_ConfigChannel>

  HAL_TIM_MspPostInit(&htim3);
 8001fe8:	4628      	mov	r0, r5

  TIM_ClockConfigTypeDef sClockSourceConfig;
  TIM_MasterConfigTypeDef sMasterConfig;
  TIM_OC_InitTypeDef sConfigOC;

  htim4.Instance = TIM4;
 8001fea:	4d44      	ldr	r5, [pc, #272]	; (80020fc <main+0x328>)

  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2);

  HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_3);

  HAL_TIM_MspPostInit(&htim3);
 8001fec:	f002 f8b6 	bl	800415c <HAL_TIM_MspPostInit>

  TIM_ClockConfigTypeDef sClockSourceConfig;
  TIM_MasterConfigTypeDef sMasterConfig;
  TIM_OC_InitTypeDef sConfigOC;

  htim4.Instance = TIM4;
 8001ff0:	4b43      	ldr	r3, [pc, #268]	; (8002100 <main+0x32c>)
  htim4.Init.Prescaler = 720;
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = 65535;
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  HAL_TIM_Base_Init(&htim4);
 8001ff2:	4628      	mov	r0, r5

  TIM_ClockConfigTypeDef sClockSourceConfig;
  TIM_MasterConfigTypeDef sMasterConfig;
  TIM_OC_InitTypeDef sConfigOC;

  htim4.Instance = TIM4;
 8001ff4:	602b      	str	r3, [r5, #0]
  htim4.Init.Prescaler = 720;
 8001ff6:	f8c5 b004 	str.w	fp, [r5, #4]
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
 8001ffa:	60ac      	str	r4, [r5, #8]
  htim4.Init.Period = 65535;
 8001ffc:	f8c5 a00c 	str.w	sl, [r5, #12]
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8002000:	612c      	str	r4, [r5, #16]
  HAL_TIM_Base_Init(&htim4);
 8002002:	f003 fab9 	bl	8005578 <HAL_TIM_Base_Init>

  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig);
 8002006:	a914      	add	r1, sp, #80	; 0x50
 8002008:	4628      	mov	r0, r5
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = 65535;
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  HAL_TIM_Base_Init(&htim4);

  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 800200a:	f8cd 9050 	str.w	r9, [sp, #80]	; 0x50
  HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig);
 800200e:	f003 f901 	bl	8005214 <HAL_TIM_ConfigClockSource>

  HAL_TIM_PWM_Init(&htim4);
 8002012:	4628      	mov	r0, r5
 8002014:	f003 facc 	bl	80055b0 <HAL_TIM_PWM_Init>

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig);
 8002018:	a90f      	add	r1, sp, #60	; 0x3c
 800201a:	4628      	mov	r0, r5
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig);

  HAL_TIM_PWM_Init(&htim4);

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800201c:	940f      	str	r4, [sp, #60]	; 0x3c
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800201e:	9410      	str	r4, [sp, #64]	; 0x40
  HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig);
 8002020:	f003 fe84 	bl	8005d2c <HAL_TIMEx_MasterConfigSynchronization>

  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1);
 8002024:	4622      	mov	r2, r4
 8002026:	a919      	add	r1, sp, #100	; 0x64
 8002028:	4628      	mov	r0, r5

  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig);

  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 800202a:	9619      	str	r6, [sp, #100]	; 0x64
  sConfigOC.Pulse = 0;
 800202c:	941a      	str	r4, [sp, #104]	; 0x68
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 800202e:	941b      	str	r4, [sp, #108]	; 0x6c
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8002030:	941d      	str	r4, [sp, #116]	; 0x74
  HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1);
 8002032:	f003 fb07 	bl	8005644 <HAL_TIM_PWM_ConfigChannel>

  HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2);
 8002036:	4642      	mov	r2, r8
 8002038:	a919      	add	r1, sp, #100	; 0x64
 800203a:	4628      	mov	r0, r5
 800203c:	f003 fb02 	bl	8005644 <HAL_TIM_PWM_ConfigChannel>

  HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_3);
 8002040:	2208      	movs	r2, #8
 8002042:	a919      	add	r1, sp, #100	; 0x64
 8002044:	4628      	mov	r0, r5
 8002046:	f003 fafd 	bl	8005644 <HAL_TIM_PWM_ConfigChannel>

  HAL_TIM_MspPostInit(&htim4);
 800204a:	4628      	mov	r0, r5
 800204c:	f002 f886 	bl	800415c <HAL_TIM_MspPostInit>
  MX_IWDG_Init();
  MX_RTC_Init();
  MX_TIM2_Init();
  MX_TIM3_Init();
  MX_TIM4_Init();
  MX_USB_DEVICE_Init();
 8002050:	f003 fe50 	bl	8005cf4 <MX_USB_DEVICE_Init>
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* Create the semaphores(s) */
  /* definition and creation of SemUsbRead */
  osSemaphoreDef(SemUsbRead);
 8002054:	a820      	add	r0, sp, #128	; 0x80
  SemUsbReadHandle = osSemaphoreCreate(osSemaphore(SemUsbRead), 1);
 8002056:	4639      	mov	r1, r7
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* Create the semaphores(s) */
  /* definition and creation of SemUsbRead */
  osSemaphoreDef(SemUsbRead);
 8002058:	f840 4d7c 	str.w	r4, [r0, #-124]!
  SemUsbReadHandle = osSemaphoreCreate(osSemaphore(SemUsbRead), 1);
 800205c:	f002 f8d8 	bl	8004210 <osSemaphoreCreate>

  /* definition and creation of SemUsbWrite */
  osSemaphoreDef(SemUsbWrite);
 8002060:	ab20      	add	r3, sp, #128	; 0x80
  /* USER CODE END RTOS_MUTEX */

  /* Create the semaphores(s) */
  /* definition and creation of SemUsbRead */
  osSemaphoreDef(SemUsbRead);
  SemUsbReadHandle = osSemaphoreCreate(osSemaphore(SemUsbRead), 1);
 8002062:	4a28      	ldr	r2, [pc, #160]	; (8002104 <main+0x330>)

  /* definition and creation of SemUsbWrite */
  osSemaphoreDef(SemUsbWrite);
 8002064:	f843 4d78 	str.w	r4, [r3, #-120]!
  SemUsbWriteHandle = osSemaphoreCreate(osSemaphore(SemUsbWrite), 1);
 8002068:	4639      	mov	r1, r7
  /* USER CODE END RTOS_MUTEX */

  /* Create the semaphores(s) */
  /* definition and creation of SemUsbRead */
  osSemaphoreDef(SemUsbRead);
  SemUsbReadHandle = osSemaphoreCreate(osSemaphore(SemUsbRead), 1);
 800206a:	6010      	str	r0, [r2, #0]

  /* definition and creation of SemUsbWrite */
  osSemaphoreDef(SemUsbWrite);
  SemUsbWriteHandle = osSemaphoreCreate(osSemaphore(SemUsbWrite), 1);
 800206c:	4618      	mov	r0, r3
 800206e:	f002 f8cf 	bl	8004210 <osSemaphoreCreate>
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* Create the thread(s) */
  /* definition and creation of defaultTask */
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
 8002072:	4d25      	ldr	r5, [pc, #148]	; (8002108 <main+0x334>)
  osSemaphoreDef(SemUsbRead);
  SemUsbReadHandle = osSemaphoreCreate(osSemaphore(SemUsbRead), 1);

  /* definition and creation of SemUsbWrite */
  osSemaphoreDef(SemUsbWrite);
  SemUsbWriteHandle = osSemaphoreCreate(osSemaphore(SemUsbWrite), 1);
 8002074:	4b25      	ldr	r3, [pc, #148]	; (800210c <main+0x338>)
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* Create the thread(s) */
  /* definition and creation of defaultTask */
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
 8002076:	af0a      	add	r7, sp, #40	; 0x28
  osSemaphoreDef(SemUsbRead);
  SemUsbReadHandle = osSemaphoreCreate(osSemaphore(SemUsbRead), 1);

  /* definition and creation of SemUsbWrite */
  osSemaphoreDef(SemUsbWrite);
  SemUsbWriteHandle = osSemaphoreCreate(osSemaphore(SemUsbWrite), 1);
 8002078:	6018      	str	r0, [r3, #0]
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* Create the thread(s) */
  /* definition and creation of defaultTask */
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
 800207a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800207c:	462e      	mov	r6, r5
 800207e:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 8002080:	f856 3b04 	ldr.w	r3, [r6], #4
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
 8002084:	4621      	mov	r1, r4
 8002086:	a80a      	add	r0, sp, #40	; 0x28
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* Create the thread(s) */
  /* definition and creation of defaultTask */
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
 8002088:	603b      	str	r3, [r7, #0]
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
 800208a:	f002 f89d 	bl	80041c8 <osThreadCreate>
 800208e:	4b20      	ldr	r3, [pc, #128]	; (8002110 <main+0x33c>)

  /* definition and creation of TaskLedFlash */
  osThreadDef(TaskLedFlash, LedFlash, osPriorityNormal, 0, 64);
 8002090:	af0f      	add	r7, sp, #60	; 0x3c
  /* USER CODE END RTOS_TIMERS */

  /* Create the thread(s) */
  /* definition and creation of defaultTask */
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
 8002092:	6018      	str	r0, [r3, #0]

  /* definition and creation of TaskLedFlash */
  osThreadDef(TaskLedFlash, LedFlash, osPriorityNormal, 0, 64);
 8002094:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8002096:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 8002098:	6833      	ldr	r3, [r6, #0]
  TaskLedFlashHandle = osThreadCreate(osThread(TaskLedFlash), NULL);
 800209a:	4621      	mov	r1, r4
 800209c:	a80f      	add	r0, sp, #60	; 0x3c
  /* definition and creation of defaultTask */
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);

  /* definition and creation of TaskLedFlash */
  osThreadDef(TaskLedFlash, LedFlash, osPriorityNormal, 0, 64);
 800209e:	603b      	str	r3, [r7, #0]
  TaskLedFlashHandle = osThreadCreate(osThread(TaskLedFlash), NULL);
 80020a0:	f002 f892 	bl	80041c8 <osThreadCreate>
 80020a4:	4b1b      	ldr	r3, [pc, #108]	; (8002114 <main+0x340>)

  /* definition and creation of TaskUsbRead */
  osThreadDef(TaskUsbRead, UsbRead, osPriorityNormal, 0, 64);
 80020a6:	f105 0718 	add.w	r7, r5, #24
 80020aa:	ae14      	add	r6, sp, #80	; 0x50
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);

  /* definition and creation of TaskLedFlash */
  osThreadDef(TaskLedFlash, LedFlash, osPriorityNormal, 0, 64);
  TaskLedFlashHandle = osThreadCreate(osThread(TaskLedFlash), NULL);
 80020ac:	6018      	str	r0, [r3, #0]

  /* definition and creation of TaskUsbRead */
  osThreadDef(TaskUsbRead, UsbRead, osPriorityNormal, 0, 64);
 80020ae:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 80020b0:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80020b2:	683b      	ldr	r3, [r7, #0]
  TaskUsbReadHandle = osThreadCreate(osThread(TaskUsbRead), NULL);
 80020b4:	4621      	mov	r1, r4
 80020b6:	a814      	add	r0, sp, #80	; 0x50
  /* definition and creation of TaskLedFlash */
  osThreadDef(TaskLedFlash, LedFlash, osPriorityNormal, 0, 64);
  TaskLedFlashHandle = osThreadCreate(osThread(TaskLedFlash), NULL);

  /* definition and creation of TaskUsbRead */
  osThreadDef(TaskUsbRead, UsbRead, osPriorityNormal, 0, 64);
 80020b8:	6033      	str	r3, [r6, #0]
  TaskUsbReadHandle = osThreadCreate(osThread(TaskUsbRead), NULL);
 80020ba:	f002 f885 	bl	80041c8 <osThreadCreate>
 80020be:	4b16      	ldr	r3, [pc, #88]	; (8002118 <main+0x344>)

  /* definition and creation of TaskUsbWrite */
  osThreadDef(TaskUsbWrite, UsbWrite, osPriorityNormal, 0, 64);
 80020c0:	f105 072c 	add.w	r7, r5, #44	; 0x2c
 80020c4:	ae19      	add	r6, sp, #100	; 0x64
 80020c6:	e029      	b.n	800211c <main+0x348>
 80020c8:	40021000 	.word	0x40021000
 80020cc:	40011000 	.word	0x40011000
 80020d0:	20001dcc 	.word	0x20001dcc
 80020d4:	40012400 	.word	0x40012400
 80020d8:	20001d78 	.word	0x20001d78
 80020dc:	40023000 	.word	0x40023000
 80020e0:	20001d68 	.word	0x20001d68
 80020e4:	40003000 	.word	0x40003000
 80020e8:	20001e38 	.word	0x20001e38
 80020ec:	40002800 	.word	0x40002800
 80020f0:	20001e50 	.word	0x20001e50
 80020f4:	20001d8c 	.word	0x20001d8c
 80020f8:	40000400 	.word	0x40000400
 80020fc:	20001d2c 	.word	0x20001d2c
 8002100:	40000800 	.word	0x40000800
 8002104:	20001e34 	.word	0x20001e34
 8002108:	080061e8 	.word	0x080061e8
 800210c:	20001e4c 	.word	0x20001e4c
 8002110:	20001d28 	.word	0x20001d28
 8002114:	20001d84 	.word	0x20001d84
 8002118:	20001dc8 	.word	0x20001dc8
  osThreadDef(TaskLedFlash, LedFlash, osPriorityNormal, 0, 64);
  TaskLedFlashHandle = osThreadCreate(osThread(TaskLedFlash), NULL);

  /* definition and creation of TaskUsbRead */
  osThreadDef(TaskUsbRead, UsbRead, osPriorityNormal, 0, 64);
  TaskUsbReadHandle = osThreadCreate(osThread(TaskUsbRead), NULL);
 800211c:	6018      	str	r0, [r3, #0]

  /* definition and creation of TaskUsbWrite */
  osThreadDef(TaskUsbWrite, UsbWrite, osPriorityNormal, 0, 64);
 800211e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8002120:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8002122:	683b      	ldr	r3, [r7, #0]
  TaskUsbWriteHandle = osThreadCreate(osThread(TaskUsbWrite), NULL);
 8002124:	4621      	mov	r1, r4
 8002126:	a819      	add	r0, sp, #100	; 0x64
  /* definition and creation of TaskUsbRead */
  osThreadDef(TaskUsbRead, UsbRead, osPriorityNormal, 0, 64);
  TaskUsbReadHandle = osThreadCreate(osThread(TaskUsbRead), NULL);

  /* definition and creation of TaskUsbWrite */
  osThreadDef(TaskUsbWrite, UsbWrite, osPriorityNormal, 0, 64);
 8002128:	6033      	str	r3, [r6, #0]
  TaskUsbWriteHandle = osThreadCreate(osThread(TaskUsbWrite), NULL);
 800212a:	f002 f84d 	bl	80041c8 <osThreadCreate>
 800212e:	4a08      	ldr	r2, [pc, #32]	; (8002150 <main+0x37c>)
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

  /* Create the queue(s) */
  /* definition and creation of InputFromUsb */
  osMessageQDef(InputFromUsb, 128, uint8_t);
 8002130:	ab08      	add	r3, sp, #32
 8002132:	3540      	adds	r5, #64	; 0x40
  osThreadDef(TaskUsbRead, UsbRead, osPriorityNormal, 0, 64);
  TaskUsbReadHandle = osThreadCreate(osThread(TaskUsbRead), NULL);

  /* definition and creation of TaskUsbWrite */
  osThreadDef(TaskUsbWrite, UsbWrite, osPriorityNormal, 0, 64);
  TaskUsbWriteHandle = osThreadCreate(osThread(TaskUsbWrite), NULL);
 8002134:	6010      	str	r0, [r2, #0]
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

  /* Create the queue(s) */
  /* definition and creation of InputFromUsb */
  osMessageQDef(InputFromUsb, 128, uint8_t);
 8002136:	e895 0003 	ldmia.w	r5, {r0, r1}
 800213a:	e883 0003 	stmia.w	r3, {r0, r1}
  InputFromUsbHandle = osMessageCreate(osMessageQ(InputFromUsb), NULL);
 800213e:	4618      	mov	r0, r3
 8002140:	4621      	mov	r1, r4
 8002142:	f002 f87b 	bl	800423c <osMessageCreate>
 8002146:	4b03      	ldr	r3, [pc, #12]	; (8002154 <main+0x380>)
 8002148:	6018      	str	r0, [r3, #0]
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */
 

  /* Start scheduler */
  osKernelStart();
 800214a:	f002 f837 	bl	80041bc <osKernelStart>
 800214e:	e7fe      	b.n	800214e <main+0x37a>
 8002150:	20001d88 	.word	0x20001d88
 8002154:	20001d80 	.word	0x20001d80

08002158 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 8002158:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
 800215a:	4c12      	ldr	r4, [pc, #72]	; (80021a4 <prvCheckForValidListAndQueue+0x4c>)
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 800215c:	f002 fba8 	bl	80048b0 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 8002160:	6825      	ldr	r5, [r4, #0]
 8002162:	b11d      	cbz	r5, 800216c <prvCheckForValidListAndQueue+0x14>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
 8002164:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8002168:	f002 bbc0 	b.w	80048ec <vPortExitCritical>
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
 800216c:	1d27      	adds	r7, r4, #4
 800216e:	4638      	mov	r0, r7
			vListInitialise( &xActiveTimerList2 );
 8002170:	f104 0618 	add.w	r6, r4, #24
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
 8002174:	f001 feb8 	bl	8003ee8 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 8002178:	4630      	mov	r0, r6
 800217a:	f001 feb5 	bl	8003ee8 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 800217e:	462a      	mov	r2, r5
 8002180:	210c      	movs	r1, #12
 8002182:	200a      	movs	r0, #10
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
			vListInitialise( &xActiveTimerList2 );
			pxCurrentTimerList = &xActiveTimerList1;
 8002184:	62e7      	str	r7, [r4, #44]	; 0x2c
			pxOverflowTimerList = &xActiveTimerList2;
 8002186:	6326      	str	r6, [r4, #48]	; 0x30
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8002188:	f002 f932 	bl	80043f0 <xQueueGenericCreate>
 800218c:	6020      	str	r0, [r4, #0]
			configASSERT( xTimerQueue );
 800218e:	b130      	cbz	r0, 800219e <prvCheckForValidListAndQueue+0x46>

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 8002190:	4905      	ldr	r1, [pc, #20]	; (80021a8 <prvCheckForValidListAndQueue+0x50>)
 8002192:	f002 fb03 	bl	800479c <vQueueAddToRegistry>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
 8002196:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 800219a:	f002 bba7 	b.w	80048ec <vPortExitCritical>
			vListInitialise( &xActiveTimerList1 );
			vListInitialise( &xActiveTimerList2 );
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
			configASSERT( xTimerQueue );
 800219e:	f002 fb71 	bl	8004884 <ulPortSetInterruptMask>
 80021a2:	e7fe      	b.n	80021a2 <prvCheckForValidListAndQueue+0x4a>
 80021a4:	200009a8 	.word	0x200009a8
 80021a8:	08006278 	.word	0x08006278

080021ac <prvInsertTimerInActiveList>:
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );

	if( xNextExpiryTime <= xTimeNow )
 80021ac:	4291      	cmp	r1, r2
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
 80021ae:	b508      	push	{r3, lr}
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 80021b0:	6100      	str	r0, [r0, #16]

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 80021b2:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );

	if( xNextExpiryTime <= xTimeNow )
 80021b4:	d805      	bhi.n	80021c2 <prvInsertTimerInActiveList+0x16>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
 80021b6:	6981      	ldr	r1, [r0, #24]
 80021b8:	1ad2      	subs	r2, r2, r3
 80021ba:	428a      	cmp	r2, r1
 80021bc:	d30c      	bcc.n	80021d8 <prvInsertTimerInActiveList+0x2c>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 80021be:	2001      	movs	r0, #1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
 80021c0:	bd08      	pop	{r3, pc}
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 80021c2:	429a      	cmp	r2, r3
 80021c4:	d201      	bcs.n	80021ca <prvInsertTimerInActiveList+0x1e>
 80021c6:	4299      	cmp	r1, r3
 80021c8:	d2f9      	bcs.n	80021be <prvInsertTimerInActiveList+0x12>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80021ca:	4b07      	ldr	r3, [pc, #28]	; (80021e8 <prvInsertTimerInActiveList+0x3c>)
 80021cc:	1d01      	adds	r1, r0, #4
 80021ce:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 80021d0:	f001 fea8 	bl	8003f24 <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
 80021d4:	2000      	movs	r0, #0
 80021d6:	bd08      	pop	{r3, pc}
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 80021d8:	4b03      	ldr	r3, [pc, #12]	; (80021e8 <prvInsertTimerInActiveList+0x3c>)
 80021da:	1d01      	adds	r1, r0, #4
 80021dc:	6b18      	ldr	r0, [r3, #48]	; 0x30
 80021de:	f001 fea1 	bl	8003f24 <vListInsert>
 80021e2:	2000      	movs	r0, #0
 80021e4:	bd08      	pop	{r3, pc}
 80021e6:	bf00      	nop
 80021e8:	200009a8 	.word	0x200009a8

080021ec <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
 80021ec:	b500      	push	{lr}
 80021ee:	b085      	sub	sp, #20

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
 80021f0:	f7ff ffb2 	bl	8002158 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
 80021f4:	4b0a      	ldr	r3, [pc, #40]	; (8002220 <xTimerCreateTimerTask+0x34>)
 80021f6:	681b      	ldr	r3, [r3, #0]
 80021f8:	b173      	cbz	r3, 8002218 <xTimerCreateTimerTask+0x2c>
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
 80021fa:	2300      	movs	r3, #0
 80021fc:	2203      	movs	r2, #3
 80021fe:	e88d 000c 	stmia.w	sp, {r2, r3}
 8002202:	9303      	str	r3, [sp, #12]
 8002204:	9302      	str	r3, [sp, #8]
 8002206:	2280      	movs	r2, #128	; 0x80
 8002208:	4906      	ldr	r1, [pc, #24]	; (8002224 <xTimerCreateTimerTask+0x38>)
 800220a:	4807      	ldr	r0, [pc, #28]	; (8002228 <xTimerCreateTimerTask+0x3c>)
 800220c:	f000 fe0e 	bl	8002e2c <xTaskGenericCreate>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
 8002210:	b110      	cbz	r0, 8002218 <xTimerCreateTimerTask+0x2c>
	return xReturn;
}
 8002212:	b005      	add	sp, #20
 8002214:	f85d fb04 	ldr.w	pc, [sp], #4
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
 8002218:	f002 fb34 	bl	8004884 <ulPortSetInterruptMask>
 800221c:	e7fe      	b.n	800221c <xTimerCreateTimerTask+0x30>
 800221e:	bf00      	nop
 8002220:	200009a8 	.word	0x200009a8
 8002224:	08006280 	.word	0x08006280
 8002228:	080022fd 	.word	0x080022fd

0800222c <xTimerGenericCommand>:
	return ( TimerHandle_t ) pxNewTimer;
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
 800222c:	b530      	push	{r4, r5, lr}
BaseType_t xReturn = pdFAIL;
DaemonTaskMessage_t xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 800222e:	4d14      	ldr	r5, [pc, #80]	; (8002280 <xTimerGenericCommand+0x54>)
	return ( TimerHandle_t ) pxNewTimer;
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
 8002230:	b085      	sub	sp, #20
BaseType_t xReturn = pdFAIL;
DaemonTaskMessage_t xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 8002232:	682c      	ldr	r4, [r5, #0]
 8002234:	b304      	cbz	r4, 8002278 <xTimerGenericCommand+0x4c>
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8002236:	2905      	cmp	r1, #5
	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 8002238:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 800223a:	9202      	str	r2, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
 800223c:	9003      	str	r0, [sp, #12]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 800223e:	dc0b      	bgt.n	8002258 <xTimerGenericCommand+0x2c>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8002240:	f001 f942 	bl	80034c8 <xTaskGetSchedulerState>
 8002244:	2802      	cmp	r0, #2
 8002246:	d00f      	beq.n	8002268 <xTimerGenericCommand+0x3c>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 8002248:	2300      	movs	r3, #0
 800224a:	6828      	ldr	r0, [r5, #0]
 800224c:	461a      	mov	r2, r3
 800224e:	a901      	add	r1, sp, #4
 8002250:	f002 f90c 	bl	800446c <xQueueGenericSend>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
 8002254:	b005      	add	sp, #20
 8002256:	bd30      	pop	{r4, r5, pc}
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 8002258:	461a      	mov	r2, r3
 800225a:	4620      	mov	r0, r4
 800225c:	2300      	movs	r3, #0
 800225e:	a901      	add	r1, sp, #4
 8002260:	f002 f99e 	bl	80045a0 <xQueueGenericSendFromISR>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
 8002264:	b005      	add	sp, #20
 8002266:	bd30      	pop	{r4, r5, pc}

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8002268:	6828      	ldr	r0, [r5, #0]
 800226a:	2300      	movs	r3, #0
 800226c:	9a08      	ldr	r2, [sp, #32]
 800226e:	a901      	add	r1, sp, #4
 8002270:	f002 f8fc 	bl	800446c <xQueueGenericSend>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
 8002274:	b005      	add	sp, #20
 8002276:	bd30      	pop	{r4, r5, pc}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
 8002278:	4620      	mov	r0, r4
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
 800227a:	b005      	add	sp, #20
 800227c:	bd30      	pop	{r4, r5, pc}
 800227e:	bf00      	nop
 8002280:	200009a8 	.word	0x200009a8

08002284 <prvSwitchTimerLists>:
	}
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
 8002284:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002288:	4e1b      	ldr	r6, [pc, #108]	; (80022f8 <prvSwitchTimerLists+0x74>)
 800228a:	b083      	sub	sp, #12
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 800228c:	f04f 0800 	mov.w	r8, #0

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8002290:	46b1      	mov	r9, r6
 8002292:	e00c      	b.n	80022ae <prvSwitchTimerLists+0x2a>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002294:	68db      	ldr	r3, [r3, #12]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002296:	68dc      	ldr	r4, [r3, #12]
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002298:	681f      	ldr	r7, [r3, #0]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800229a:	1d25      	adds	r5, r4, #4
 800229c:	4628      	mov	r0, r5
 800229e:	f001 fe5b 	bl	8003f58 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 80022a2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80022a4:	4620      	mov	r0, r4
 80022a6:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 80022a8:	69e3      	ldr	r3, [r4, #28]
 80022aa:	2b01      	cmp	r3, #1
 80022ac:	d00a      	beq.n	80022c4 <prvSwitchTimerLists+0x40>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 80022ae:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 80022b0:	4911      	ldr	r1, [pc, #68]	; (80022f8 <prvSwitchTimerLists+0x74>)
 80022b2:	681a      	ldr	r2, [r3, #0]
 80022b4:	2a00      	cmp	r2, #0
 80022b6:	d1ed      	bne.n	8002294 <prvSwitchTimerLists+0x10>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 80022b8:	6b0a      	ldr	r2, [r1, #48]	; 0x30
	pxOverflowTimerList = pxTemp;
 80022ba:	630b      	str	r3, [r1, #48]	; 0x30
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 80022bc:	62ca      	str	r2, [r1, #44]	; 0x2c
	pxOverflowTimerList = pxTemp;
}
 80022be:	b003      	add	sp, #12
 80022c0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 80022c4:	69a2      	ldr	r2, [r4, #24]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 80022c6:	2300      	movs	r3, #0
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 80022c8:	443a      	add	r2, r7
			if( xReloadTime > xNextExpireTime )
 80022ca:	4297      	cmp	r7, r2
 80022cc:	d207      	bcs.n	80022de <prvSwitchTimerLists+0x5a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 80022ce:	6062      	str	r2, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 80022d0:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80022d2:	4629      	mov	r1, r5
 80022d4:	f8d9 002c 	ldr.w	r0, [r9, #44]	; 0x2c
 80022d8:	f001 fe24 	bl	8003f24 <vListInsert>
 80022dc:	e7e7      	b.n	80022ae <prvSwitchTimerLists+0x2a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 80022de:	f8cd 8000 	str.w	r8, [sp]
 80022e2:	463a      	mov	r2, r7
 80022e4:	4620      	mov	r0, r4
 80022e6:	4619      	mov	r1, r3
 80022e8:	f7ff ffa0 	bl	800222c <xTimerGenericCommand>
				configASSERT( xResult );
 80022ec:	2800      	cmp	r0, #0
 80022ee:	d1de      	bne.n	80022ae <prvSwitchTimerLists+0x2a>
 80022f0:	f002 fac8 	bl	8004884 <ulPortSetInterruptMask>
 80022f4:	e7fe      	b.n	80022f4 <prvSwitchTimerLists+0x70>
 80022f6:	bf00      	nop
 80022f8:	200009a8 	.word	0x200009a8

080022fc <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
 80022fc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002300:	4c58      	ldr	r4, [pc, #352]	; (8002464 <prvTimerTask+0x168>)
 8002302:	b087      	sub	sp, #28
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8002304:	4627      	mov	r7, r4
 8002306:	f04f 0801 	mov.w	r8, #1
 800230a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	if( *pxListWasEmpty == pdFALSE )
 800230c:	681e      	ldr	r6, [r3, #0]
 800230e:	2e00      	cmp	r6, #0
 8002310:	d03d      	beq.n	800238e <prvTimerTask+0x92>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002312:	68db      	ldr	r3, [r3, #12]
 8002314:	681e      	ldr	r6, [r3, #0]
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
 8002316:	f000 fe89 	bl	800302c <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 800231a:	f000 fe91 	bl	8003040 <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
 800231e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8002320:	4605      	mov	r5, r0

	if( xTimeNow < xLastTime )
 8002322:	4298      	cmp	r0, r3
 8002324:	d33b      	bcc.n	800239e <prvTimerTask+0xa2>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8002326:	4286      	cmp	r6, r0
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
 8002328:	6378      	str	r0, [r7, #52]	; 0x34
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 800232a:	d946      	bls.n	80023ba <prvTimerTask+0xbe>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
 800232c:	1b71      	subs	r1, r6, r5
 800232e:	6820      	ldr	r0, [r4, #0]
 8002330:	f002 fa4a 	bl	80047c8 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
 8002334:	f000 ff1c 	bl	8003170 <xTaskResumeAll>
 8002338:	2800      	cmp	r0, #0
 800233a:	d03b      	beq.n	80023b4 <prvTimerTask+0xb8>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 800233c:	2300      	movs	r3, #0
 800233e:	461a      	mov	r2, r3
 8002340:	a903      	add	r1, sp, #12
 8002342:	6820      	ldr	r0, [r4, #0]
 8002344:	f002 f984 	bl	8004650 <xQueueGenericReceive>
 8002348:	2800      	cmp	r0, #0
 800234a:	d0de      	beq.n	800230a <prvTimerTask+0xe>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 800234c:	9b03      	ldr	r3, [sp, #12]
 800234e:	2b00      	cmp	r3, #0
 8002350:	dbf4      	blt.n	800233c <prvTimerTask+0x40>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 8002352:	9e05      	ldr	r6, [sp, #20]

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 8002354:	6973      	ldr	r3, [r6, #20]
 8002356:	b113      	cbz	r3, 800235e <prvTimerTask+0x62>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8002358:	1d30      	adds	r0, r6, #4
 800235a:	f001 fdfd 	bl	8003f58 <uxListRemove>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 800235e:	f000 fe6f 	bl	8003040 <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
 8002362:	6b63      	ldr	r3, [r4, #52]	; 0x34
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8002364:	4605      	mov	r5, r0

	if( xTimeNow < xLastTime )
 8002366:	4298      	cmp	r0, r3
 8002368:	d321      	bcc.n	80023ae <prvTimerTask+0xb2>
 800236a:	9b03      	ldr	r3, [sp, #12]
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
 800236c:	6365      	str	r5, [r4, #52]	; 0x34
 800236e:	2b09      	cmp	r3, #9
 8002370:	d8e4      	bhi.n	800233c <prvTimerTask+0x40>
 8002372:	fa08 f303 	lsl.w	r3, r8, r3
 8002376:	f413 7904 	ands.w	r9, r3, #528	; 0x210
 800237a:	d166      	bne.n	800244a <prvTimerTask+0x14e>
 800237c:	f013 0fc7 	tst.w	r3, #199	; 0xc7
 8002380:	d144      	bne.n	800240c <prvTimerTask+0x110>
 8002382:	069b      	lsls	r3, r3, #26
 8002384:	d5da      	bpl.n	800233c <prvTimerTask+0x40>
					break;

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
 8002386:	4630      	mov	r0, r6
 8002388:	f003 fc68 	bl	8005c5c <vPortFree>
 800238c:	e7d6      	b.n	800233c <prvTimerTask+0x40>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
 800238e:	f000 fe4d 	bl	800302c <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8002392:	f000 fe55 	bl	8003040 <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
 8002396:	6b7b      	ldr	r3, [r7, #52]	; 0x34
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8002398:	4605      	mov	r5, r0

	if( xTimeNow < xLastTime )
 800239a:	4283      	cmp	r3, r0
 800239c:	d905      	bls.n	80023aa <prvTimerTask+0xae>
	{
		prvSwitchTimerLists();
 800239e:	f7ff ff71 	bl	8002284 <prvSwitchTimerLists>
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
 80023a2:	6365      	str	r5, [r4, #52]	; 0x34
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
 80023a4:	f000 fee4 	bl	8003170 <xTaskResumeAll>
 80023a8:	e7c8      	b.n	800233c <prvTimerTask+0x40>
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
 80023aa:	637d      	str	r5, [r7, #52]	; 0x34
 80023ac:	e7be      	b.n	800232c <prvTimerTask+0x30>

	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
 80023ae:	f7ff ff69 	bl	8002284 <prvSwitchTimerLists>
 80023b2:	e7da      	b.n	800236a <prvTimerTask+0x6e>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
 80023b4:	f002 fa5a 	bl	800486c <vPortYield>
 80023b8:	e7c0      	b.n	800233c <prvTimerTask+0x40>
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
			{
				( void ) xTaskResumeAll();
 80023ba:	f000 fed9 	bl	8003170 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 80023be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80023c0:	68db      	ldr	r3, [r3, #12]
 80023c2:	f8d3 900c 	ldr.w	r9, [r3, #12]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80023c6:	f109 0004 	add.w	r0, r9, #4
 80023ca:	f001 fdc5 	bl	8003f58 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 80023ce:	f8d9 301c 	ldr.w	r3, [r9, #28]
 80023d2:	2b01      	cmp	r3, #1
 80023d4:	d004      	beq.n	80023e0 <prvTimerTask+0xe4>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 80023d6:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 80023da:	4648      	mov	r0, r9
 80023dc:	4798      	blx	r3
 80023de:	e7ad      	b.n	800233c <prvTimerTask+0x40>
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
 80023e0:	f8d9 1018 	ldr.w	r1, [r9, #24]
 80023e4:	462a      	mov	r2, r5
 80023e6:	4431      	add	r1, r6
 80023e8:	4633      	mov	r3, r6
 80023ea:	4648      	mov	r0, r9
 80023ec:	f7ff fede 	bl	80021ac <prvInsertTimerInActiveList>
 80023f0:	2801      	cmp	r0, #1
 80023f2:	d1f0      	bne.n	80023d6 <prvTimerTask+0xda>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 80023f4:	2300      	movs	r3, #0
 80023f6:	4632      	mov	r2, r6
 80023f8:	9300      	str	r3, [sp, #0]
 80023fa:	4619      	mov	r1, r3
 80023fc:	4648      	mov	r0, r9
 80023fe:	f7ff ff15 	bl	800222c <xTimerGenericCommand>
			configASSERT( xResult );
 8002402:	2800      	cmp	r0, #0
 8002404:	d1e7      	bne.n	80023d6 <prvTimerTask+0xda>
 8002406:	f002 fa3d 	bl	8004884 <ulPortSetInterruptMask>
 800240a:	e7fe      	b.n	800240a <prvTimerTask+0x10e>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
 800240c:	9b04      	ldr	r3, [sp, #16]
 800240e:	69b1      	ldr	r1, [r6, #24]
 8002410:	462a      	mov	r2, r5
 8002412:	4419      	add	r1, r3
 8002414:	4630      	mov	r0, r6
 8002416:	f7ff fec9 	bl	80021ac <prvInsertTimerInActiveList>
 800241a:	2801      	cmp	r0, #1
 800241c:	d18e      	bne.n	800233c <prvTimerTask+0x40>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 800241e:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8002420:	4630      	mov	r0, r6
 8002422:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8002424:	69f3      	ldr	r3, [r6, #28]
 8002426:	2b01      	cmp	r3, #1
 8002428:	d188      	bne.n	800233c <prvTimerTask+0x40>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 800242a:	69b3      	ldr	r3, [r6, #24]
 800242c:	9a04      	ldr	r2, [sp, #16]
 800242e:	4630      	mov	r0, r6
 8002430:	441a      	add	r2, r3
 8002432:	f8cd 9000 	str.w	r9, [sp]
 8002436:	464b      	mov	r3, r9
 8002438:	4649      	mov	r1, r9
 800243a:	f7ff fef7 	bl	800222c <xTimerGenericCommand>
							configASSERT( xResult );
 800243e:	2800      	cmp	r0, #0
 8002440:	f47f af7c 	bne.w	800233c <prvTimerTask+0x40>
 8002444:	f002 fa1e 	bl	8004884 <ulPortSetInterruptMask>
 8002448:	e7fe      	b.n	8002448 <prvTimerTask+0x14c>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 800244a:	9904      	ldr	r1, [sp, #16]
 800244c:	61b1      	str	r1, [r6, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 800244e:	b131      	cbz	r1, 800245e <prvTimerTask+0x162>
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8002450:	4429      	add	r1, r5
 8002452:	4630      	mov	r0, r6
 8002454:	462b      	mov	r3, r5
 8002456:	462a      	mov	r2, r5
 8002458:	f7ff fea8 	bl	80021ac <prvInsertTimerInActiveList>
 800245c:	e76e      	b.n	800233c <prvTimerTask+0x40>
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 800245e:	f002 fa11 	bl	8004884 <ulPortSetInterruptMask>
 8002462:	e7fe      	b.n	8002462 <prvTimerTask+0x166>
 8002464:	200009a8 	.word	0x200009a8

08002468 <USB_CoreInit>:
  * @param  cfg : pointer to a USB_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_TypeDef *USBx, USB_CfgTypeDef cfg)
{
 8002468:	b084      	sub	sp, #16
 800246a:	a801      	add	r0, sp, #4
 800246c:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  /* NOTE : - This function is not required by USB Device FS peripheral, it is used 
              only by USB OTG FS peripheral.
            - This function is added to ensure compatibility across platforms.
   */
  return HAL_OK;
}
 8002470:	b004      	add	sp, #16
 8002472:	2000      	movs	r0, #0
 8002474:	4770      	bx	lr
 8002476:	bf00      	nop

08002478 <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_TypeDef *USBx)
{
 8002478:	4602      	mov	r2, r0
  /* Set winterruptmask variable */
  winterruptmask = USB_CNTR_CTRM  | USB_CNTR_WKUPM | USB_CNTR_SUSPM | USB_CNTR_ERRM \
    | USB_CNTR_ESOFM | USB_CNTR_RESETM;
  
  /* Set interrupt mask */
  USBx->CNTR |= winterruptmask;
 800247a:	f8b0 3040 	ldrh.w	r3, [r0, #64]	; 0x40
  
  return HAL_OK;
}
 800247e:	2000      	movs	r0, #0
  /* Set winterruptmask variable */
  winterruptmask = USB_CNTR_CTRM  | USB_CNTR_WKUPM | USB_CNTR_SUSPM | USB_CNTR_ERRM \
    | USB_CNTR_ESOFM | USB_CNTR_RESETM;
  
  /* Set interrupt mask */
  USBx->CNTR |= winterruptmask;
 8002480:	b29b      	uxth	r3, r3
 8002482:	f443 433d 	orr.w	r3, r3, #48384	; 0xbd00
 8002486:	f8a2 3040 	strh.w	r3, [r2, #64]	; 0x40
  
  return HAL_OK;
}
 800248a:	4770      	bx	lr

0800248c <USB_DisableGlobalInt>:
  /* Set winterruptmask variable */
  winterruptmask = USB_CNTR_CTRM  | USB_CNTR_WKUPM | USB_CNTR_SUSPM | USB_CNTR_ERRM \
    | USB_CNTR_ESOFM | USB_CNTR_RESETM;
  
  /* Clear interrupt mask */
  USBx->CNTR &= ~winterruptmask;
 800248c:	f244 21ff 	movw	r1, #17151	; 0x42ff
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx : Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_TypeDef *USBx)
{
 8002490:	4602      	mov	r2, r0
  /* Set winterruptmask variable */
  winterruptmask = USB_CNTR_CTRM  | USB_CNTR_WKUPM | USB_CNTR_SUSPM | USB_CNTR_ERRM \
    | USB_CNTR_ESOFM | USB_CNTR_RESETM;
  
  /* Clear interrupt mask */
  USBx->CNTR &= ~winterruptmask;
 8002492:	f8b0 3040 	ldrh.w	r3, [r0, #64]	; 0x40
  
  return HAL_OK;
}
 8002496:	2000      	movs	r0, #0
  /* Set winterruptmask variable */
  winterruptmask = USB_CNTR_CTRM  | USB_CNTR_WKUPM | USB_CNTR_SUSPM | USB_CNTR_ERRM \
    | USB_CNTR_ESOFM | USB_CNTR_RESETM;
  
  /* Clear interrupt mask */
  USBx->CNTR &= ~winterruptmask;
 8002498:	400b      	ands	r3, r1
 800249a:	f8a2 3040 	strh.w	r3, [r2, #64]	; 0x40
  
  return HAL_OK;
}
 800249e:	4770      	bx	lr

080024a0 <USB_SetCurrentMode>:
  /* NOTE : - This function is not required by USB Device FS peripheral, it is used 
              only by USB OTG FS peripheral.
            - This function is added to ensure compatibility across platforms.
   */
  return HAL_OK;
}
 80024a0:	2000      	movs	r0, #0
 80024a2:	4770      	bx	lr

080024a4 <USB_DevInit>:
  * @param  cfg  : pointer to a USB_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_TypeDef *USBx, USB_CfgTypeDef cfg)
{    
 80024a4:	b084      	sub	sp, #16
 80024a6:	b470      	push	{r4, r5, r6}
 80024a8:	4604      	mov	r4, r0
  /* Init Device */
  /*CNTR_FRES = 1*/
  USBx->CNTR = USB_CNTR_FRES;
  
  /*CNTR_FRES = 0*/
  USBx->CNTR = 0;
 80024aa:	2500      	movs	r5, #0
  */
HAL_StatusTypeDef USB_DevInit (USB_TypeDef *USBx, USB_CfgTypeDef cfg)
{    
  /* Init Device */
  /*CNTR_FRES = 1*/
  USBx->CNTR = USB_CNTR_FRES;
 80024ac:	2001      	movs	r0, #1
  * @param  cfg  : pointer to a USB_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_TypeDef *USBx, USB_CfgTypeDef cfg)
{    
 80024ae:	ae04      	add	r6, sp, #16
  /* Init Device */
  /*CNTR_FRES = 1*/
  USBx->CNTR = USB_CNTR_FRES;
 80024b0:	f8a4 0040 	strh.w	r0, [r4, #64]	; 0x40
  * @param  cfg  : pointer to a USB_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_TypeDef *USBx, USB_CfgTypeDef cfg)
{    
 80024b4:	e886 000e 	stmia.w	r6, {r1, r2, r3}
  /* Init Device */
  /*CNTR_FRES = 1*/
  USBx->CNTR = USB_CNTR_FRES;
  
  /*CNTR_FRES = 0*/
  USBx->CNTR = 0;
 80024b8:	f8a4 5040 	strh.w	r5, [r4, #64]	; 0x40
  
  /*Set Btable Address*/
  USBx->BTABLE = BTABLE_ADDRESS;
    
  return HAL_OK;
}
 80024bc:	4628      	mov	r0, r5
  
  /*CNTR_FRES = 0*/
  USBx->CNTR = 0;
 
  /*Clear pending interrupts*/
  USBx->ISTR = 0;
 80024be:	f8a4 5044 	strh.w	r5, [r4, #68]	; 0x44
  
  /*Set Btable Address*/
  USBx->BTABLE = BTABLE_ADDRESS;
 80024c2:	f8a4 5050 	strh.w	r5, [r4, #80]	; 0x50
    
  return HAL_OK;
}
 80024c6:	bc70      	pop	{r4, r5, r6}
 80024c8:	b004      	add	sp, #16
 80024ca:	4770      	bx	lr

080024cc <USB_ActivateEndpoint>:
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
  /* initialize Endpoint */
  switch (ep->type)
 80024cc:	78cb      	ldrb	r3, [r1, #3]
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 80024ce:	b430      	push	{r4, r5}
  /* initialize Endpoint */
  switch (ep->type)
 80024d0:	2b03      	cmp	r3, #3
 80024d2:	d810      	bhi.n	80024f6 <USB_ActivateEndpoint+0x2a>
 80024d4:	e8df f013 	tbh	[pc, r3, lsl #1]
 80024d8:	01690176 	.word	0x01690176
 80024dc:	015c0004 	.word	0x015c0004
  {
  case EP_TYPE_CTRL:
    PCD_SET_EPTYPE(USBx, ep->num, USB_EP_CONTROL);
    break;
  case EP_TYPE_BULK:
    PCD_SET_EPTYPE(USBx, ep->num, USB_EP_BULK);
 80024e0:	780a      	ldrb	r2, [r1, #0]
 80024e2:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80024e6:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 80024ea:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80024ee:	041b      	lsls	r3, r3, #16
 80024f0:	0c1b      	lsrs	r3, r3, #16
 80024f2:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
    break;
  default:
      break;
  } 
  
  PCD_SET_EP_ADDRESS(USBx, ep->num, ep->num);
 80024f6:	780c      	ldrb	r4, [r1, #0]
 80024f8:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 80024fc:	f444 4200 	orr.w	r2, r4, #32768	; 0x8000
 8002500:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002504:	051b      	lsls	r3, r3, #20
 8002506:	0d1b      	lsrs	r3, r3, #20
 8002508:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800250c:	4313      	orrs	r3, r2
 800250e:	f820 3024 	strh.w	r3, [r0, r4, lsl #2]
  
  if (ep->doublebuffer == 0) 
 8002512:	7a8b      	ldrb	r3, [r1, #10]
 8002514:	2b00      	cmp	r3, #0
 8002516:	d137      	bne.n	8002588 <USB_ActivateEndpoint+0xbc>
  {
    if (ep->is_in)
 8002518:	784b      	ldrb	r3, [r1, #1]
 800251a:	2b00      	cmp	r3, #0
 800251c:	f000 80ee 	beq.w	80026fc <USB_ActivateEndpoint+0x230>
    {
      /*Set the endpoint Transmit buffer address */
      PCD_SET_EP_TX_ADDRESS(USBx, ep->num, ep->pmaadress);
 8002520:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8002524:	780c      	ldrb	r4, [r1, #0]
 8002526:	888a      	ldrh	r2, [r1, #4]
 8002528:	b29b      	uxth	r3, r3
 800252a:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 800252e:	0852      	lsrs	r2, r2, #1
 8002530:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 8002534:	0052      	lsls	r2, r2, #1
 8002536:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800253a:	780c      	ldrb	r4, [r1, #0]
 800253c:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 8002540:	eb00 0284 	add.w	r2, r0, r4, lsl #2
 8002544:	065b      	lsls	r3, r3, #25
 8002546:	d50e      	bpl.n	8002566 <USB_ActivateEndpoint+0x9a>
 8002548:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 800254c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002550:	051b      	lsls	r3, r3, #20
 8002552:	0d1b      	lsrs	r3, r3, #20
 8002554:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002558:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800255c:	f820 3024 	strh.w	r3, [r0, r4, lsl #2]
 8002560:	780a      	ldrb	r2, [r1, #0]
 8002562:	eb00 0282 	add.w	r2, r0, r2, lsl #2
      /* Configure NAK status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK); 
 8002566:	8813      	ldrh	r3, [r2, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }
  
  return HAL_OK;
}
 8002568:	2000      	movs	r0, #0
    {
      /*Set the endpoint Transmit buffer address */
      PCD_SET_EP_TX_ADDRESS(USBx, ep->num, ep->pmaadress);
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
      /* Configure NAK status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK); 
 800256a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800256e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002572:	041b      	lsls	r3, r3, #16
 8002574:	0c1b      	lsrs	r3, r3, #16
 8002576:	f083 0320 	eor.w	r3, r3, #32
 800257a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800257e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002582:	8013      	strh	r3, [r2, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }
  
  return HAL_OK;
}
 8002584:	bc30      	pop	{r4, r5}
 8002586:	4770      	bx	lr
  }
  /*Double Buffer*/
  else
  {
    /*Set the endpoint as double buffered*/
    PCD_SET_EP_DBUF(USBx, ep->num);
 8002588:	780a      	ldrb	r2, [r1, #0]
 800258a:	f500 6480 	add.w	r4, r0, #1024	; 0x400
 800258e:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002592:	f423 73f8 	bic.w	r3, r3, #496	; 0x1f0
 8002596:	051b      	lsls	r3, r3, #20
 8002598:	0d1b      	lsrs	r3, r3, #20
 800259a:	f443 4301 	orr.w	r3, r3, #33024	; 0x8100
 800259e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80025a2:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
    /*Set buffer address for double buffered mode*/
    PCD_SET_EP_DBUF_ADDR(USBx, ep->num,ep->pmaaddr0, ep->pmaaddr1);
 80025a6:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 80025aa:	88ca      	ldrh	r2, [r1, #6]
 80025ac:	780d      	ldrb	r5, [r1, #0]
 80025ae:	b29b      	uxth	r3, r3
 80025b0:	0852      	lsrs	r2, r2, #1
 80025b2:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 80025b6:	0052      	lsls	r2, r2, #1
 80025b8:	f844 2013 	str.w	r2, [r4, r3, lsl #1]
 80025bc:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 80025c0:	780d      	ldrb	r5, [r1, #0]
 80025c2:	890a      	ldrh	r2, [r1, #8]
 80025c4:	b29b      	uxth	r3, r3
 80025c6:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 80025ca:	0852      	lsrs	r2, r2, #1
 80025cc:	3304      	adds	r3, #4
 80025ce:	0052      	lsls	r2, r2, #1
 80025d0:	f844 2013 	str.w	r2, [r4, r3, lsl #1]
    
    if (ep->is_in==0)
 80025d4:	784b      	ldrb	r3, [r1, #1]
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 80025d6:	780c      	ldrb	r4, [r1, #0]
    /*Set the endpoint as double buffered*/
    PCD_SET_EP_DBUF(USBx, ep->num);
    /*Set buffer address for double buffered mode*/
    PCD_SET_EP_DBUF_ADDR(USBx, ep->num,ep->pmaaddr0, ep->pmaaddr1);
    
    if (ep->is_in==0)
 80025d8:	2b00      	cmp	r3, #0
 80025da:	d14f      	bne.n	800267c <USB_ActivateEndpoint+0x1b0>
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 80025dc:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 80025e0:	eb00 0284 	add.w	r2, r0, r4, lsl #2
 80025e4:	045d      	lsls	r5, r3, #17
 80025e6:	d50e      	bpl.n	8002606 <USB_ActivateEndpoint+0x13a>
 80025e8:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 80025ec:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80025f0:	051b      	lsls	r3, r3, #20
 80025f2:	0d1b      	lsrs	r3, r3, #20
 80025f4:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 80025f8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80025fc:	f820 3024 	strh.w	r3, [r0, r4, lsl #2]
 8002600:	780a      	ldrb	r2, [r1, #0]
 8002602:	eb00 0282 	add.w	r2, r0, r2, lsl #2
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8002606:	8813      	ldrh	r3, [r2, #0]
 8002608:	065b      	lsls	r3, r3, #25
 800260a:	d50c      	bpl.n	8002626 <USB_ActivateEndpoint+0x15a>
 800260c:	8813      	ldrh	r3, [r2, #0]
 800260e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002612:	051b      	lsls	r3, r3, #20
 8002614:	0d1b      	lsrs	r3, r3, #20
 8002616:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800261a:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800261e:	8013      	strh	r3, [r2, #0]
 8002620:	780a      	ldrb	r2, [r1, #0]
 8002622:	eb00 0282 	add.w	r2, r0, r2, lsl #2
      
      /* Reset value of the data toggle bits for the endpoint out*/
      PCD_TX_DTOG(USBx, ep->num);
 8002626:	8813      	ldrh	r3, [r2, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }
  
  return HAL_OK;
}
 8002628:	bc30      	pop	{r4, r5}
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
      
      /* Reset value of the data toggle bits for the endpoint out*/
      PCD_TX_DTOG(USBx, ep->num);
 800262a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800262e:	051b      	lsls	r3, r3, #20
 8002630:	0d1b      	lsrs	r3, r3, #20
 8002632:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002636:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800263a:	8013      	strh	r3, [r2, #0]
      
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 800263c:	780a      	ldrb	r2, [r1, #0]
 800263e:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002642:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002646:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800264a:	041b      	lsls	r3, r3, #16
 800264c:	0c1b      	lsrs	r3, r3, #16
 800264e:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8002652:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002656:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800265a:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 800265e:	780a      	ldrb	r2, [r1, #0]
 8002660:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002664:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8002668:	051b      	lsls	r3, r3, #20
 800266a:	0d1b      	lsrs	r3, r3, #20
 800266c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002670:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002674:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }
  
  return HAL_OK;
}
 8002678:	2000      	movs	r0, #0
 800267a:	4770      	bx	lr
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
    }
    else
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800267c:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 8002680:	eb00 0284 	add.w	r2, r0, r4, lsl #2
 8002684:	045d      	lsls	r5, r3, #17
 8002686:	d50e      	bpl.n	80026a6 <USB_ActivateEndpoint+0x1da>
 8002688:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 800268c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002690:	051b      	lsls	r3, r3, #20
 8002692:	0d1b      	lsrs	r3, r3, #20
 8002694:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8002698:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800269c:	f820 3024 	strh.w	r3, [r0, r4, lsl #2]
 80026a0:	780a      	ldrb	r2, [r1, #0]
 80026a2:	eb00 0282 	add.w	r2, r0, r2, lsl #2
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 80026a6:	8813      	ldrh	r3, [r2, #0]
 80026a8:	065b      	lsls	r3, r3, #25
 80026aa:	f100 8098 	bmi.w	80027de <USB_ActivateEndpoint+0x312>
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }
  
  return HAL_OK;
}
 80026ae:	bc30      	pop	{r4, r5}
    else
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
      PCD_RX_DTOG(USBx, ep->num);
 80026b0:	8813      	ldrh	r3, [r2, #0]
 80026b2:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80026b6:	051b      	lsls	r3, r3, #20
 80026b8:	0d1b      	lsrs	r3, r3, #20
 80026ba:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 80026be:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80026c2:	8013      	strh	r3, [r2, #0]
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 80026c4:	780a      	ldrb	r2, [r1, #0]
 80026c6:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80026ca:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 80026ce:	051b      	lsls	r3, r3, #20
 80026d0:	0d1b      	lsrs	r3, r3, #20
 80026d2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80026d6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80026da:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 80026de:	780a      	ldrb	r2, [r1, #0]
 80026e0:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80026e4:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80026e8:	049b      	lsls	r3, r3, #18
 80026ea:	0c9b      	lsrs	r3, r3, #18
 80026ec:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80026f0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80026f4:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
    }
  }
  
  return HAL_OK;
}
 80026f8:	2000      	movs	r0, #0
 80026fa:	4770      	bx	lr
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK); 
    }
    else
    {
      /*Set the endpoint Receive buffer address */
      PCD_SET_EP_RX_ADDRESS(USBx, ep->num, ep->pmaadress);
 80026fc:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8002700:	780c      	ldrb	r4, [r1, #0]
 8002702:	888a      	ldrh	r2, [r1, #4]
 8002704:	b29b      	uxth	r3, r3
 8002706:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 800270a:	0852      	lsrs	r2, r2, #1
 800270c:	3304      	adds	r3, #4
 800270e:	0052      	lsls	r2, r2, #1
 8002710:	f500 6480 	add.w	r4, r0, #1024	; 0x400
 8002714:	f844 2013 	str.w	r2, [r4, r3, lsl #1]
      /*Set the endpoint Receive buffer counter*/
      PCD_SET_EP_RX_CNT(USBx, ep->num, ep->maxpacket);
 8002718:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 800271c:	780a      	ldrb	r2, [r1, #0]
 800271e:	690d      	ldr	r5, [r1, #16]
 8002720:	b29b      	uxth	r3, r3
 8002722:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8002726:	2d3e      	cmp	r5, #62	; 0x3e
 8002728:	f103 0306 	add.w	r3, r3, #6
 800272c:	d865      	bhi.n	80027fa <USB_ActivateEndpoint+0x32e>
 800272e:	f3c5 024f 	ubfx	r2, r5, #1, #16
 8002732:	07ed      	lsls	r5, r5, #31
 8002734:	bf44      	itt	mi
 8002736:	3201      	addmi	r2, #1
 8002738:	b292      	uxthmi	r2, r2
 800273a:	0292      	lsls	r2, r2, #10
 800273c:	b292      	uxth	r2, r2
 800273e:	f844 2013 	str.w	r2, [r4, r3, lsl #1]
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8002742:	780c      	ldrb	r4, [r1, #0]
 8002744:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 8002748:	eb00 0284 	add.w	r2, r0, r4, lsl #2
 800274c:	045b      	lsls	r3, r3, #17
 800274e:	d50e      	bpl.n	800276e <USB_ActivateEndpoint+0x2a2>
 8002750:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 8002754:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002758:	051b      	lsls	r3, r3, #20
 800275a:	0d1b      	lsrs	r3, r3, #20
 800275c:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8002760:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002764:	f820 3024 	strh.w	r3, [r0, r4, lsl #2]
 8002768:	780a      	ldrb	r2, [r1, #0]
 800276a:	eb00 0282 	add.w	r2, r0, r2, lsl #2
      /* Configure VALID status for the Endpoint*/
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 800276e:	8813      	ldrh	r3, [r2, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }
  
  return HAL_OK;
}
 8002770:	2000      	movs	r0, #0
      PCD_SET_EP_RX_ADDRESS(USBx, ep->num, ep->pmaadress);
      /*Set the endpoint Receive buffer counter*/
      PCD_SET_EP_RX_CNT(USBx, ep->num, ep->maxpacket);
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
      /* Configure VALID status for the Endpoint*/
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8002772:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002776:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800277a:	041b      	lsls	r3, r3, #16
 800277c:	0c1b      	lsrs	r3, r3, #16
 800277e:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8002782:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002786:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800278a:	8013      	strh	r3, [r2, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }
  
  return HAL_OK;
}
 800278c:	bc30      	pop	{r4, r5}
 800278e:	4770      	bx	lr
    break;
  case EP_TYPE_BULK:
    PCD_SET_EPTYPE(USBx, ep->num, USB_EP_BULK);
    break;
  case EP_TYPE_INTR:
    PCD_SET_EPTYPE(USBx, ep->num, USB_EP_INTERRUPT);
 8002790:	780a      	ldrb	r2, [r1, #0]
 8002792:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002796:	b29b      	uxth	r3, r3
 8002798:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 800279c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80027a0:	f443 63c0 	orr.w	r3, r3, #1536	; 0x600
 80027a4:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
    break;
 80027a8:	e6a5      	b.n	80024f6 <USB_ActivateEndpoint+0x2a>
  case EP_TYPE_ISOC:
    PCD_SET_EPTYPE(USBx, ep->num, USB_EP_ISOCHRONOUS);
 80027aa:	780a      	ldrb	r2, [r1, #0]
 80027ac:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80027b0:	b29b      	uxth	r3, r3
 80027b2:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 80027b6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80027ba:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80027be:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
    break;
 80027c2:	e698      	b.n	80024f6 <USB_ActivateEndpoint+0x2a>
{
  /* initialize Endpoint */
  switch (ep->type)
  {
  case EP_TYPE_CTRL:
    PCD_SET_EPTYPE(USBx, ep->num, USB_EP_CONTROL);
 80027c4:	780a      	ldrb	r2, [r1, #0]
 80027c6:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80027ca:	b29b      	uxth	r3, r3
 80027cc:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 80027d0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80027d4:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80027d8:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
    break;
 80027dc:	e68b      	b.n	80024f6 <USB_ActivateEndpoint+0x2a>
    }
    else
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 80027de:	8813      	ldrh	r3, [r2, #0]
 80027e0:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80027e4:	051b      	lsls	r3, r3, #20
 80027e6:	0d1b      	lsrs	r3, r3, #20
 80027e8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80027ec:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80027f0:	8013      	strh	r3, [r2, #0]
 80027f2:	780a      	ldrb	r2, [r1, #0]
 80027f4:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 80027f8:	e759      	b.n	80026ae <USB_ActivateEndpoint+0x1e2>
    else
    {
      /*Set the endpoint Receive buffer address */
      PCD_SET_EP_RX_ADDRESS(USBx, ep->num, ep->pmaadress);
      /*Set the endpoint Receive buffer counter*/
      PCD_SET_EP_RX_CNT(USBx, ep->num, ep->maxpacket);
 80027fa:	f3c5 124f 	ubfx	r2, r5, #5, #16
 80027fe:	06ed      	lsls	r5, r5, #27
 8002800:	bf04      	itt	eq
 8002802:	f102 32ff 	addeq.w	r2, r2, #4294967295
 8002806:	b292      	uxtheq	r2, r2
 8002808:	ea6f 62c2 	mvn.w	r2, r2, lsl #27
 800280c:	ea6f 4252 	mvn.w	r2, r2, lsr #17
 8002810:	b292      	uxth	r2, r2
 8002812:	f844 2013 	str.w	r2, [r4, r3, lsl #1]
 8002816:	e794      	b.n	8002742 <USB_ActivateEndpoint+0x276>

08002818 <USB_DeactivateEndpoint>:
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
  if (ep->doublebuffer == 0) 
 8002818:	7a8b      	ldrb	r3, [r1, #10]
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 800281a:	b410      	push	{r4}
  if (ep->doublebuffer == 0) 
 800281c:	bb33      	cbnz	r3, 800286c <USB_DeactivateEndpoint+0x54>
  {
    if (ep->is_in)
 800281e:	784b      	ldrb	r3, [r1, #1]
    {
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8002820:	780c      	ldrb	r4, [r1, #0]
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
  if (ep->doublebuffer == 0) 
  {
    if (ep->is_in)
 8002822:	2b00      	cmp	r3, #0
 8002824:	f000 80b1 	beq.w	800298a <USB_DeactivateEndpoint+0x172>
    {
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8002828:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 800282c:	eb00 0284 	add.w	r2, r0, r4, lsl #2
 8002830:	065b      	lsls	r3, r3, #25
 8002832:	d50e      	bpl.n	8002852 <USB_DeactivateEndpoint+0x3a>
 8002834:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 8002838:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800283c:	051b      	lsls	r3, r3, #20
 800283e:	0d1b      	lsrs	r3, r3, #20
 8002840:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002844:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8002848:	f820 3024 	strh.w	r3, [r0, r4, lsl #2]
 800284c:	780a      	ldrb	r2, [r1, #0]
 800284e:	eb00 0282 	add.w	r2, r0, r2, lsl #2
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS); 
 8002852:	8813      	ldrh	r3, [r2, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }
  
  return HAL_OK;
}
 8002854:	2000      	movs	r0, #0
  {
    if (ep->is_in)
    {
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS); 
 8002856:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800285a:	051b      	lsls	r3, r3, #20
 800285c:	0d1b      	lsrs	r3, r3, #20
 800285e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002862:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002866:	8013      	strh	r3, [r2, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }
  
  return HAL_OK;
}
 8002868:	bc10      	pop	{r4}
 800286a:	4770      	bx	lr
    }
  }
  /*Double Buffer*/
  else
  { 
    if (ep->is_in==0)
 800286c:	784b      	ldrb	r3, [r1, #1]
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800286e:	780c      	ldrb	r4, [r1, #0]
    }
  }
  /*Double Buffer*/
  else
  { 
    if (ep->is_in==0)
 8002870:	2b00      	cmp	r3, #0
 8002872:	d14b      	bne.n	800290c <USB_DeactivateEndpoint+0xf4>
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8002874:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 8002878:	eb00 0284 	add.w	r2, r0, r4, lsl #2
 800287c:	045b      	lsls	r3, r3, #17
 800287e:	d50e      	bpl.n	800289e <USB_DeactivateEndpoint+0x86>
 8002880:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 8002884:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002888:	051b      	lsls	r3, r3, #20
 800288a:	0d1b      	lsrs	r3, r3, #20
 800288c:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8002890:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002894:	f820 3024 	strh.w	r3, [r0, r4, lsl #2]
 8002898:	780a      	ldrb	r2, [r1, #0]
 800289a:	eb00 0282 	add.w	r2, r0, r2, lsl #2
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800289e:	8813      	ldrh	r3, [r2, #0]
 80028a0:	065c      	lsls	r4, r3, #25
 80028a2:	d50c      	bpl.n	80028be <USB_DeactivateEndpoint+0xa6>
 80028a4:	8813      	ldrh	r3, [r2, #0]
 80028a6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80028aa:	051b      	lsls	r3, r3, #20
 80028ac:	0d1b      	lsrs	r3, r3, #20
 80028ae:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80028b2:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80028b6:	8013      	strh	r3, [r2, #0]
 80028b8:	780a      	ldrb	r2, [r1, #0]
 80028ba:	eb00 0282 	add.w	r2, r0, r2, lsl #2
      
      /* Reset value of the data toggle bits for the endpoint out*/
      PCD_TX_DTOG(USBx, ep->num);
 80028be:	8813      	ldrh	r3, [r2, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }
  
  return HAL_OK;
}
 80028c0:	bc10      	pop	{r4}
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
      
      /* Reset value of the data toggle bits for the endpoint out*/
      PCD_TX_DTOG(USBx, ep->num);
 80028c2:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80028c6:	051b      	lsls	r3, r3, #20
 80028c8:	0d1b      	lsrs	r3, r3, #20
 80028ca:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80028ce:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80028d2:	8013      	strh	r3, [r2, #0]
      
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 80028d4:	780a      	ldrb	r2, [r1, #0]
 80028d6:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80028da:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80028de:	049b      	lsls	r3, r3, #18
 80028e0:	0c9b      	lsrs	r3, r3, #18
 80028e2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80028e6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80028ea:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 80028ee:	780a      	ldrb	r2, [r1, #0]
 80028f0:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80028f4:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 80028f8:	051b      	lsls	r3, r3, #20
 80028fa:	0d1b      	lsrs	r3, r3, #20
 80028fc:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002900:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002904:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }
  
  return HAL_OK;
}
 8002908:	2000      	movs	r0, #0
 800290a:	4770      	bx	lr
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
    }
    else
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800290c:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 8002910:	eb00 0284 	add.w	r2, r0, r4, lsl #2
 8002914:	045b      	lsls	r3, r3, #17
 8002916:	d50e      	bpl.n	8002936 <USB_DeactivateEndpoint+0x11e>
 8002918:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 800291c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002920:	051b      	lsls	r3, r3, #20
 8002922:	0d1b      	lsrs	r3, r3, #20
 8002924:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8002928:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800292c:	f820 3024 	strh.w	r3, [r0, r4, lsl #2]
 8002930:	780a      	ldrb	r2, [r1, #0]
 8002932:	eb00 0282 	add.w	r2, r0, r2, lsl #2
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8002936:	8813      	ldrh	r3, [r2, #0]
 8002938:	065b      	lsls	r3, r3, #25
 800293a:	d448      	bmi.n	80029ce <USB_DeactivateEndpoint+0x1b6>
      PCD_RX_DTOG(USBx, ep->num);
 800293c:	8813      	ldrh	r3, [r2, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }
  
  return HAL_OK;
}
 800293e:	bc10      	pop	{r4}
    else
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
      PCD_RX_DTOG(USBx, ep->num);
 8002940:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002944:	051b      	lsls	r3, r3, #20
 8002946:	0d1b      	lsrs	r3, r3, #20
 8002948:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800294c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002950:	8013      	strh	r3, [r2, #0]
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 8002952:	780a      	ldrb	r2, [r1, #0]
 8002954:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002958:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800295c:	051b      	lsls	r3, r3, #20
 800295e:	0d1b      	lsrs	r3, r3, #20
 8002960:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002964:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002968:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 800296c:	780a      	ldrb	r2, [r1, #0]
 800296e:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002972:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002976:	049b      	lsls	r3, r3, #18
 8002978:	0c9b      	lsrs	r3, r3, #18
 800297a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800297e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002982:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
    }
  }
  
  return HAL_OK;
}
 8002986:	2000      	movs	r0, #0
 8002988:	4770      	bx	lr
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS); 
    }
    else
    {
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800298a:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 800298e:	eb00 0284 	add.w	r2, r0, r4, lsl #2
 8002992:	045b      	lsls	r3, r3, #17
 8002994:	d50e      	bpl.n	80029b4 <USB_DeactivateEndpoint+0x19c>
 8002996:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 800299a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800299e:	051b      	lsls	r3, r3, #20
 80029a0:	0d1b      	lsrs	r3, r3, #20
 80029a2:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 80029a6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80029aa:	f820 3024 	strh.w	r3, [r0, r4, lsl #2]
 80029ae:	780a      	ldrb	r2, [r1, #0]
 80029b0:	eb00 0282 	add.w	r2, r0, r2, lsl #2
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 80029b4:	8813      	ldrh	r3, [r2, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }
  
  return HAL_OK;
}
 80029b6:	2000      	movs	r0, #0
    }
    else
    {
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 80029b8:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80029bc:	049b      	lsls	r3, r3, #18
 80029be:	0c9b      	lsrs	r3, r3, #18
 80029c0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80029c4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80029c8:	8013      	strh	r3, [r2, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }
  
  return HAL_OK;
}
 80029ca:	bc10      	pop	{r4}
 80029cc:	4770      	bx	lr
    }
    else
    {
      /* Clear the data toggle bits for the endpoint IN/OUT*/
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 80029ce:	8813      	ldrh	r3, [r2, #0]
 80029d0:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80029d4:	051b      	lsls	r3, r3, #20
 80029d6:	0d1b      	lsrs	r3, r3, #20
 80029d8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80029dc:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80029e0:	8013      	strh	r3, [r2, #0]
 80029e2:	780a      	ldrb	r2, [r1, #0]
 80029e4:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 80029e8:	e7a8      	b.n	800293c <USB_DeactivateEndpoint+0x124>
 80029ea:	bf00      	nop

080029ec <USB_EPStartXfer>:
{
  uint16_t pmabuffer = 0;
  uint32_t len = ep->xfer_len;
  
  /* IN endpoint */
  if (ep->is_in == 1)
 80029ec:	784a      	ldrb	r2, [r1, #1]
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_TypeDef *USBx , USB_EPTypeDef *ep)
{
 80029ee:	b4f0      	push	{r4, r5, r6, r7}
  uint16_t pmabuffer = 0;
  uint32_t len = ep->xfer_len;
  
  /* IN endpoint */
  if (ep->is_in == 1)
 80029f0:	2a01      	cmp	r2, #1
 80029f2:	d072      	beq.n	8002ada <USB_EPStartXfer+0xee>
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
  }
  else /* OUT endpoint */
  {
    /* Multi packet transfer*/
    if (ep->xfer_len > ep->maxpacket)
 80029f4:	698b      	ldr	r3, [r1, #24]
 80029f6:	690c      	ldr	r4, [r1, #16]
 80029f8:	42a3      	cmp	r3, r4
 80029fa:	d833      	bhi.n	8002a64 <USB_EPStartXfer+0x78>
      ep->xfer_len-=len; 
    }
    else
    {
      len=ep->xfer_len;
      ep->xfer_len =0;
 80029fc:	2400      	movs	r4, #0
 80029fe:	618c      	str	r4, [r1, #24]
    }
    
    /* configure and validate Rx endpoint */
    if (ep->doublebuffer == 0) 
 8002a00:	7a8c      	ldrb	r4, [r1, #10]
 8002a02:	2c00      	cmp	r4, #0
 8002a04:	d134      	bne.n	8002a70 <USB_EPStartXfer+0x84>
    {
      /*Set RX buffer count*/
      PCD_SET_EP_RX_CNT(USBx, ep->num, len);
 8002a06:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
 8002a0a:	780c      	ldrb	r4, [r1, #0]
 8002a0c:	b292      	uxth	r2, r2
 8002a0e:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 8002a12:	2b3e      	cmp	r3, #62	; 0x3e
 8002a14:	f102 0206 	add.w	r2, r2, #6
 8002a18:	f500 6580 	add.w	r5, r0, #1024	; 0x400
 8002a1c:	f240 8097 	bls.w	8002b4e <USB_EPStartXfer+0x162>
 8002a20:	f3c3 144f 	ubfx	r4, r3, #5, #16
 8002a24:	06de      	lsls	r6, r3, #27
 8002a26:	bf04      	itt	eq
 8002a28:	f104 34ff 	addeq.w	r4, r4, #4294967295
 8002a2c:	b2a4      	uxtheq	r4, r4
 8002a2e:	ea6f 64c4 	mvn.w	r4, r4, lsl #27
 8002a32:	ea6f 4454 	mvn.w	r4, r4, lsr #17
 8002a36:	b2a4      	uxth	r4, r4
 8002a38:	f845 4012 	str.w	r4, [r5, r2, lsl #1]
    {
      /*Set the Double buffer counter*/
      PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, len);
    }
    
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8002a3c:	780a      	ldrb	r2, [r1, #0]
  }
  
  return HAL_OK;
}
 8002a3e:	bcf0      	pop	{r4, r5, r6, r7}
    {
      /*Set the Double buffer counter*/
      PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, len);
    }
    
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8002a40:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002a44:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002a48:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002a4c:	041b      	lsls	r3, r3, #16
 8002a4e:	0c1b      	lsrs	r3, r3, #16
 8002a50:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8002a54:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002a58:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002a5c:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
  }
  
  return HAL_OK;
}
 8002a60:	2000      	movs	r0, #0
 8002a62:	4770      	bx	lr
  {
    /* Multi packet transfer*/
    if (ep->xfer_len > ep->maxpacket)
    {
      len=ep->maxpacket;
      ep->xfer_len-=len; 
 8002a64:	1b1b      	subs	r3, r3, r4
 8002a66:	618b      	str	r3, [r1, #24]
 8002a68:	4623      	mov	r3, r4
      len=ep->xfer_len;
      ep->xfer_len =0;
    }
    
    /* configure and validate Rx endpoint */
    if (ep->doublebuffer == 0) 
 8002a6a:	7a8c      	ldrb	r4, [r1, #10]
 8002a6c:	2c00      	cmp	r4, #0
 8002a6e:	d0ca      	beq.n	8002a06 <USB_EPStartXfer+0x1a>
      PCD_SET_EP_RX_CNT(USBx, ep->num, len);
    }
    else
    {
      /*Set the Double buffer counter*/
      PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, len);
 8002a70:	2a00      	cmp	r2, #0
 8002a72:	d1e3      	bne.n	8002a3c <USB_EPStartXfer+0x50>
 8002a74:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
 8002a78:	780c      	ldrb	r4, [r1, #0]
 8002a7a:	b292      	uxth	r2, r2
 8002a7c:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 8002a80:	2b3e      	cmp	r3, #62	; 0x3e
 8002a82:	f102 0202 	add.w	r2, r2, #2
 8002a86:	f500 6580 	add.w	r5, r0, #1024	; 0x400
 8002a8a:	f240 80a2 	bls.w	8002bd2 <USB_EPStartXfer+0x1e6>
 8002a8e:	095c      	lsrs	r4, r3, #5
 8002a90:	b2a6      	uxth	r6, r4
 8002a92:	f013 071f 	ands.w	r7, r3, #31
 8002a96:	bf04      	itt	eq
 8002a98:	f106 36ff 	addeq.w	r6, r6, #4294967295
 8002a9c:	b2b6      	uxtheq	r6, r6
 8002a9e:	ea6f 66c6 	mvn.w	r6, r6, lsl #27
 8002aa2:	ea6f 4656 	mvn.w	r6, r6, lsr #17
 8002aa6:	b2b6      	uxth	r6, r6
 8002aa8:	f845 6012 	str.w	r6, [r5, r2, lsl #1]
 8002aac:	784a      	ldrb	r2, [r1, #1]
 8002aae:	2a00      	cmp	r2, #0
 8002ab0:	f040 80c9 	bne.w	8002c46 <USB_EPStartXfer+0x25a>
 8002ab4:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8002ab8:	780a      	ldrb	r2, [r1, #0]
 8002aba:	b29b      	uxth	r3, r3
 8002abc:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8002ac0:	3206      	adds	r2, #6
 8002ac2:	b2a3      	uxth	r3, r4
 8002ac4:	b90f      	cbnz	r7, 8002aca <USB_EPStartXfer+0xde>
 8002ac6:	3b01      	subs	r3, #1
 8002ac8:	b29b      	uxth	r3, r3
 8002aca:	ea6f 63c3 	mvn.w	r3, r3, lsl #27
 8002ace:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8002ad2:	b29b      	uxth	r3, r3
 8002ad4:	f845 3012 	str.w	r3, [r5, r2, lsl #1]
 8002ad8:	e7b0      	b.n	8002a3c <USB_EPStartXfer+0x50>
  
  /* IN endpoint */
  if (ep->is_in == 1)
  {
    /*Multi packet transfer*/
    if (ep->xfer_len > ep->maxpacket)
 8002ada:	698c      	ldr	r4, [r1, #24]
 8002adc:	690b      	ldr	r3, [r1, #16]
 8002ade:	429c      	cmp	r4, r3
 8002ae0:	d840      	bhi.n	8002b64 <USB_EPStartXfer+0x178>
      ep->xfer_len-=len; 
    }
    else
    {  
      len=ep->xfer_len;
      ep->xfer_len =0;
 8002ae2:	2300      	movs	r3, #0
 8002ae4:	618b      	str	r3, [r1, #24]
    }
    
    /* configure and validate Tx endpoint */
    if (ep->doublebuffer == 0) 
 8002ae6:	7a8b      	ldrb	r3, [r1, #10]
 8002ae8:	2b00      	cmp	r3, #0
 8002aea:	d141      	bne.n	8002b70 <USB_EPStartXfer+0x184>
  * @param  wNBytes : number of bytes to be copied.
  * @retval None
  */
void USB_WritePMA(USB_TypeDef *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t nbytes = (wNBytes + 1) >> 1;   /* nbytes = (wNBytes + 1) / 2 */
 8002aec:	b2a3      	uxth	r3, r4
  uint32_t index = 0, temp1 = 0, temp2 = 0;
  uint16_t *pdwVal = NULL;
  
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
 8002aee:	888a      	ldrh	r2, [r1, #4]
  * @param  wNBytes : number of bytes to be copied.
  * @retval None
  */
void USB_WritePMA(USB_TypeDef *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t nbytes = (wNBytes + 1) >> 1;   /* nbytes = (wNBytes + 1) / 2 */
 8002af0:	3301      	adds	r3, #1
  uint32_t index = 0, temp1 = 0, temp2 = 0;
  uint16_t *pdwVal = NULL;
  
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
 8002af2:	eb00 0242 	add.w	r2, r0, r2, lsl #1
  for (index = nbytes; index != 0; index--)
 8002af6:	105b      	asrs	r3, r3, #1
    }
    
    /* configure and validate Tx endpoint */
    if (ep->doublebuffer == 0) 
    {
      USB_WritePMA(USBx, ep->xfer_buff, ep->pmaadress, len);
 8002af8:	694d      	ldr	r5, [r1, #20]
 8002afa:	bf18      	it	ne
 8002afc:	f202 4204 	addwne	r2, r2, #1028	; 0x404
  uint32_t nbytes = (wNBytes + 1) >> 1;   /* nbytes = (wNBytes + 1) / 2 */
  uint32_t index = 0, temp1 = 0, temp2 = 0;
  uint16_t *pdwVal = NULL;
  
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
  for (index = nbytes; index != 0; index--)
 8002b00:	d007      	beq.n	8002b12 <USB_EPStartXfer+0x126>
 8002b02:	f835 6b02 	ldrh.w	r6, [r5], #2
 8002b06:	3b01      	subs	r3, #1
  {
    temp1 = (uint16_t) * pbUsrBuf;
    pbUsrBuf++;
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
    *pdwVal++ = temp2;
 8002b08:	f822 6c04 	strh.w	r6, [r2, #-4]
 8002b0c:	f102 0204 	add.w	r2, r2, #4
  uint32_t nbytes = (wNBytes + 1) >> 1;   /* nbytes = (wNBytes + 1) / 2 */
  uint32_t index = 0, temp1 = 0, temp2 = 0;
  uint16_t *pdwVal = NULL;
  
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
  for (index = nbytes; index != 0; index--)
 8002b10:	d1f7      	bne.n	8002b02 <USB_EPStartXfer+0x116>
    
    /* configure and validate Tx endpoint */
    if (ep->doublebuffer == 0) 
    {
      USB_WritePMA(USBx, ep->xfer_buff, ep->pmaadress, len);
      PCD_SET_EP_TX_CNT(USBx, ep->num, len);
 8002b12:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8002b16:	780a      	ldrb	r2, [r1, #0]
 8002b18:	b29b      	uxth	r3, r3
 8002b1a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8002b1e:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 8002b22:	f8c3 4404 	str.w	r4, [r3, #1028]	; 0x404
      }
      USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, len);
      PCD_FreeUserBuffer(USBx, ep->num, ep->is_in);
    }
    
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
 8002b26:	780a      	ldrb	r2, [r1, #0]
    
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
  }
  
  return HAL_OK;
}
 8002b28:	bcf0      	pop	{r4, r5, r6, r7}
      }
      USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, len);
      PCD_FreeUserBuffer(USBx, ep->num, ep->is_in);
    }
    
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
 8002b2a:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002b2e:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8002b32:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002b36:	041b      	lsls	r3, r3, #16
 8002b38:	0c1b      	lsrs	r3, r3, #16
 8002b3a:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 8002b3e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002b42:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002b46:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
    
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
  }
  
  return HAL_OK;
}
 8002b4a:	2000      	movs	r0, #0
 8002b4c:	4770      	bx	lr
    
    /* configure and validate Rx endpoint */
    if (ep->doublebuffer == 0) 
    {
      /*Set RX buffer count*/
      PCD_SET_EP_RX_CNT(USBx, ep->num, len);
 8002b4e:	f3c3 044f 	ubfx	r4, r3, #1, #16
 8002b52:	07db      	lsls	r3, r3, #31
 8002b54:	bf44      	itt	mi
 8002b56:	3401      	addmi	r4, #1
 8002b58:	b2a4      	uxthmi	r4, r4
 8002b5a:	02a4      	lsls	r4, r4, #10
 8002b5c:	b2a4      	uxth	r4, r4
 8002b5e:	f845 4012 	str.w	r4, [r5, r2, lsl #1]
 8002b62:	e76b      	b.n	8002a3c <USB_EPStartXfer+0x50>
  {
    /*Multi packet transfer*/
    if (ep->xfer_len > ep->maxpacket)
    {
      len=ep->maxpacket;
      ep->xfer_len-=len; 
 8002b64:	1ae4      	subs	r4, r4, r3
 8002b66:	618c      	str	r4, [r1, #24]
 8002b68:	461c      	mov	r4, r3
      len=ep->xfer_len;
      ep->xfer_len =0;
    }
    
    /* configure and validate Tx endpoint */
    if (ep->doublebuffer == 0) 
 8002b6a:	7a8b      	ldrb	r3, [r1, #10]
 8002b6c:	2b00      	cmp	r3, #0
 8002b6e:	d0bd      	beq.n	8002aec <USB_EPStartXfer+0x100>
      PCD_SET_EP_TX_CNT(USBx, ep->num, len);
    }
    else
    {
      /* Write the data to the USB endpoint */
      if (PCD_GET_ENDPOINT(USBx, ep->num)& USB_EP_DTOG_TX)
 8002b70:	780e      	ldrb	r6, [r1, #0]
 8002b72:	f830 3026 	ldrh.w	r3, [r0, r6, lsl #2]
 8002b76:	065f      	lsls	r7, r3, #25
 8002b78:	d548      	bpl.n	8002c0c <USB_EPStartXfer+0x220>
      {
        /* Set the Double buffer counter for pmabuffer1 */
        PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 8002b7a:	f8b0 5050 	ldrh.w	r5, [r0, #80]	; 0x50
 8002b7e:	f500 6380 	add.w	r3, r0, #1024	; 0x400
 8002b82:	b2ad      	uxth	r5, r5
 8002b84:	eb05 02c6 	add.w	r2, r5, r6, lsl #3
 8002b88:	3202      	adds	r2, #2
        pmabuffer = ep->pmaaddr1;
 8002b8a:	890e      	ldrh	r6, [r1, #8]
    {
      /* Write the data to the USB endpoint */
      if (PCD_GET_ENDPOINT(USBx, ep->num)& USB_EP_DTOG_TX)
      {
        /* Set the Double buffer counter for pmabuffer1 */
        PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 8002b8c:	f843 4012 	str.w	r4, [r3, r2, lsl #1]
  * @param  wNBytes : number of bytes to be copied.
  * @retval None
  */
void USB_WritePMA(USB_TypeDef *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t nbytes = (wNBytes + 1) >> 1;   /* nbytes = (wNBytes + 1) / 2 */
 8002b90:	b2a2      	uxth	r2, r4
 8002b92:	3201      	adds	r2, #1
  uint32_t index = 0, temp1 = 0, temp2 = 0;
  uint16_t *pdwVal = NULL;
  
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
  for (index = nbytes; index != 0; index--)
 8002b94:	1052      	asrs	r2, r2, #1
{
  uint32_t nbytes = (wNBytes + 1) >> 1;   /* nbytes = (wNBytes + 1) / 2 */
  uint32_t index = 0, temp1 = 0, temp2 = 0;
  uint16_t *pdwVal = NULL;
  
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
 8002b96:	eb03 0646 	add.w	r6, r3, r6, lsl #1
      {
        /* Set the Double buffer counter for pmabuffer0 */
        PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
        pmabuffer = ep->pmaaddr0;
      }
      USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, len);
 8002b9a:	694c      	ldr	r4, [r1, #20]
  uint32_t nbytes = (wNBytes + 1) >> 1;   /* nbytes = (wNBytes + 1) / 2 */
  uint32_t index = 0, temp1 = 0, temp2 = 0;
  uint16_t *pdwVal = NULL;
  
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
  for (index = nbytes; index != 0; index--)
 8002b9c:	bf18      	it	ne
 8002b9e:	2300      	movne	r3, #0
 8002ba0:	d006      	beq.n	8002bb0 <USB_EPStartXfer+0x1c4>
 8002ba2:	f834 5b02 	ldrh.w	r5, [r4], #2
  {
    temp1 = (uint16_t) * pbUsrBuf;
    pbUsrBuf++;
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
    *pdwVal++ = temp2;
 8002ba6:	f826 5023 	strh.w	r5, [r6, r3, lsl #2]
 8002baa:	3301      	adds	r3, #1
  uint32_t nbytes = (wNBytes + 1) >> 1;   /* nbytes = (wNBytes + 1) / 2 */
  uint32_t index = 0, temp1 = 0, temp2 = 0;
  uint16_t *pdwVal = NULL;
  
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
  for (index = nbytes; index != 0; index--)
 8002bac:	4293      	cmp	r3, r2
 8002bae:	d1f8      	bne.n	8002ba2 <USB_EPStartXfer+0x1b6>
        /* Set the Double buffer counter for pmabuffer0 */
        PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
        pmabuffer = ep->pmaaddr0;
      }
      USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, len);
      PCD_FreeUserBuffer(USBx, ep->num, ep->is_in);
 8002bb0:	784b      	ldrb	r3, [r1, #1]
 8002bb2:	2b00      	cmp	r3, #0
 8002bb4:	d136      	bne.n	8002c24 <USB_EPStartXfer+0x238>
 8002bb6:	780a      	ldrb	r2, [r1, #0]
 8002bb8:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002bbc:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002bc0:	051b      	lsls	r3, r3, #20
 8002bc2:	0d1b      	lsrs	r3, r3, #20
 8002bc4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002bc8:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8002bcc:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
 8002bd0:	e7a9      	b.n	8002b26 <USB_EPStartXfer+0x13a>
      PCD_SET_EP_RX_CNT(USBx, ep->num, len);
    }
    else
    {
      /*Set the Double buffer counter*/
      PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, len);
 8002bd2:	085c      	lsrs	r4, r3, #1
 8002bd4:	b2a6      	uxth	r6, r4
 8002bd6:	f013 0701 	ands.w	r7, r3, #1
 8002bda:	bf1c      	itt	ne
 8002bdc:	3601      	addne	r6, #1
 8002bde:	b2b6      	uxthne	r6, r6
 8002be0:	02b6      	lsls	r6, r6, #10
 8002be2:	b2b6      	uxth	r6, r6
 8002be4:	f845 6012 	str.w	r6, [r5, r2, lsl #1]
 8002be8:	784a      	ldrb	r2, [r1, #1]
 8002bea:	bb62      	cbnz	r2, 8002c46 <USB_EPStartXfer+0x25a>
 8002bec:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8002bf0:	780a      	ldrb	r2, [r1, #0]
 8002bf2:	b29b      	uxth	r3, r3
 8002bf4:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8002bf8:	b2a4      	uxth	r4, r4
 8002bfa:	3306      	adds	r3, #6
 8002bfc:	b10f      	cbz	r7, 8002c02 <USB_EPStartXfer+0x216>
 8002bfe:	3401      	adds	r4, #1
 8002c00:	b2a4      	uxth	r4, r4
 8002c02:	02a4      	lsls	r4, r4, #10
 8002c04:	b2a4      	uxth	r4, r4
 8002c06:	f845 4013 	str.w	r4, [r5, r3, lsl #1]
 8002c0a:	e717      	b.n	8002a3c <USB_EPStartXfer+0x50>
        pmabuffer = ep->pmaaddr1;
      }
      else
      {
        /* Set the Double buffer counter for pmabuffer0 */
        PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 8002c0c:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
 8002c10:	f500 6380 	add.w	r3, r0, #1024	; 0x400
 8002c14:	b292      	uxth	r2, r2
 8002c16:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
 8002c1a:	3202      	adds	r2, #2
        pmabuffer = ep->pmaaddr0;
 8002c1c:	88ce      	ldrh	r6, [r1, #6]
        pmabuffer = ep->pmaaddr1;
      }
      else
      {
        /* Set the Double buffer counter for pmabuffer0 */
        PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 8002c1e:	f843 4012 	str.w	r4, [r3, r2, lsl #1]
 8002c22:	e7b5      	b.n	8002b90 <USB_EPStartXfer+0x1a4>
        pmabuffer = ep->pmaaddr0;
      }
      USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, len);
      PCD_FreeUserBuffer(USBx, ep->num, ep->is_in);
 8002c24:	2b01      	cmp	r3, #1
 8002c26:	f47f af7e 	bne.w	8002b26 <USB_EPStartXfer+0x13a>
 8002c2a:	780a      	ldrb	r2, [r1, #0]
 8002c2c:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002c30:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002c34:	051b      	lsls	r3, r3, #20
 8002c36:	0d1b      	lsrs	r3, r3, #20
 8002c38:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8002c3c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002c40:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
 8002c44:	e76f      	b.n	8002b26 <USB_EPStartXfer+0x13a>
      PCD_SET_EP_RX_CNT(USBx, ep->num, len);
    }
    else
    {
      /*Set the Double buffer counter*/
      PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, len);
 8002c46:	2a01      	cmp	r2, #1
 8002c48:	f47f aef8 	bne.w	8002a3c <USB_EPStartXfer+0x50>
 8002c4c:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
 8002c50:	780c      	ldrb	r4, [r1, #0]
 8002c52:	b292      	uxth	r2, r2
 8002c54:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 8002c58:	3202      	adds	r2, #2
 8002c5a:	f845 3012 	str.w	r3, [r5, r2, lsl #1]
 8002c5e:	e6ed      	b.n	8002a3c <USB_EPStartXfer+0x50>

08002c60 <USB_EPSetStall>:
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_TypeDef *USBx , USB_EPTypeDef *ep)
{
  if (ep->num == 0)
 8002c60:	780a      	ldrb	r2, [r1, #0]
 8002c62:	b32a      	cbz	r2, 8002cb0 <USB_EPSetStall+0x50>
    /* This macro sets STALL status for RX & TX*/ 
    PCD_SET_EP_TXRX_STATUS(USBx, ep->num, USB_EP_RX_STALL, USB_EP_TX_STALL); 
  }
  else
  {
    if (ep->is_in)
 8002c64:	784b      	ldrb	r3, [r1, #1]
 8002c66:	b98b      	cbnz	r3, 8002c8c <USB_EPSetStall+0x2c>
    {
      PCD_SET_EP_TX_STATUS(USBx, ep->num , USB_EP_TX_STALL); 
    }
    else
    {
      PCD_SET_EP_RX_STATUS(USBx, ep->num , USB_EP_RX_STALL);
 8002c68:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002c6c:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002c70:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002c74:	041b      	lsls	r3, r3, #16
 8002c76:	0c1b      	lsrs	r3, r3, #16
 8002c78:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8002c7c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002c80:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002c84:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
    }
  }
  return HAL_OK;
}
 8002c88:	2000      	movs	r0, #0
 8002c8a:	4770      	bx	lr
  }
  else
  {
    if (ep->is_in)
    {
      PCD_SET_EP_TX_STATUS(USBx, ep->num , USB_EP_TX_STALL); 
 8002c8c:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002c90:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8002c94:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002c98:	041b      	lsls	r3, r3, #16
 8002c9a:	0c1b      	lsrs	r3, r3, #16
 8002c9c:	f083 0310 	eor.w	r3, r3, #16
 8002ca0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002ca4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002ca8:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
    {
      PCD_SET_EP_RX_STATUS(USBx, ep->num , USB_EP_RX_STALL);
    }
  }
  return HAL_OK;
}
 8002cac:	2000      	movs	r0, #0
 8002cae:	4770      	bx	lr
HAL_StatusTypeDef USB_EPSetStall(USB_TypeDef *USBx , USB_EPTypeDef *ep)
{
  if (ep->num == 0)
  {
    /* This macro sets STALL status for RX & TX*/ 
    PCD_SET_EP_TXRX_STATUS(USBx, ep->num, USB_EP_RX_STALL, USB_EP_TX_STALL); 
 8002cb0:	8803      	ldrh	r3, [r0, #0]
 8002cb2:	b29b      	uxth	r3, r3
 8002cb4:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002cb8:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002cbc:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8002cc0:	f083 0310 	eor.w	r3, r3, #16
 8002cc4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002cc8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002ccc:	8003      	strh	r3, [r0, #0]
    {
      PCD_SET_EP_RX_STATUS(USBx, ep->num , USB_EP_RX_STALL);
    }
  }
  return HAL_OK;
}
 8002cce:	2000      	movs	r0, #0
 8002cd0:	4770      	bx	lr
 8002cd2:	bf00      	nop

08002cd4 <USB_EPClearStall>:
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
  if (ep->is_in)
 8002cd4:	784b      	ldrb	r3, [r1, #1]
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 8002cd6:	b410      	push	{r4}
  if (ep->is_in)
  {
    PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8002cd8:	780c      	ldrb	r4, [r1, #0]
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
  if (ep->is_in)
 8002cda:	b32b      	cbz	r3, 8002d28 <USB_EPClearStall+0x54>
  {
    PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8002cdc:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 8002ce0:	eb00 0284 	add.w	r2, r0, r4, lsl #2
 8002ce4:	065b      	lsls	r3, r3, #25
 8002ce6:	d50e      	bpl.n	8002d06 <USB_EPClearStall+0x32>
 8002ce8:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 8002cec:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002cf0:	051b      	lsls	r3, r3, #20
 8002cf2:	0d1b      	lsrs	r3, r3, #20
 8002cf4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002cf8:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8002cfc:	f820 3024 	strh.w	r3, [r0, r4, lsl #2]
 8002d00:	780a      	ldrb	r2, [r1, #0]
 8002d02:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
 8002d06:	8813      	ldrh	r3, [r2, #0]
  {
    PCD_CLEAR_RX_DTOG(USBx, ep->num);
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
  }
  return HAL_OK;
}
 8002d08:	2000      	movs	r0, #0
HAL_StatusTypeDef USB_EPClearStall(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
  if (ep->is_in)
  {
    PCD_CLEAR_TX_DTOG(USBx, ep->num);
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
 8002d0a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8002d0e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002d12:	041b      	lsls	r3, r3, #16
 8002d14:	0c1b      	lsrs	r3, r3, #16
 8002d16:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 8002d1a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002d1e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002d22:	8013      	strh	r3, [r2, #0]
  {
    PCD_CLEAR_RX_DTOG(USBx, ep->num);
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
  }
  return HAL_OK;
}
 8002d24:	bc10      	pop	{r4}
 8002d26:	4770      	bx	lr
    PCD_CLEAR_TX_DTOG(USBx, ep->num);
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
  }
  else
  {
    PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8002d28:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 8002d2c:	eb00 0284 	add.w	r2, r0, r4, lsl #2
 8002d30:	045b      	lsls	r3, r3, #17
 8002d32:	d50e      	bpl.n	8002d52 <USB_EPClearStall+0x7e>
 8002d34:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 8002d38:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002d3c:	051b      	lsls	r3, r3, #20
 8002d3e:	0d1b      	lsrs	r3, r3, #20
 8002d40:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8002d44:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002d48:	f820 3024 	strh.w	r3, [r0, r4, lsl #2]
 8002d4c:	780a      	ldrb	r2, [r1, #0]
 8002d4e:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8002d52:	8813      	ldrh	r3, [r2, #0]
  }
  return HAL_OK;
}
 8002d54:	2000      	movs	r0, #0
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
  }
  else
  {
    PCD_CLEAR_RX_DTOG(USBx, ep->num);
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8002d56:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002d5a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002d5e:	041b      	lsls	r3, r3, #16
 8002d60:	0c1b      	lsrs	r3, r3, #16
 8002d62:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8002d66:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002d6a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002d6e:	8013      	strh	r3, [r2, #0]
  }
  return HAL_OK;
}
 8002d70:	bc10      	pop	{r4}
 8002d72:	4770      	bx	lr

08002d74 <USB_SetDevAddress>:
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_SetDevAddress (USB_TypeDef *USBx, uint8_t address)
{
  if(address == 0) 
 8002d74:	b911      	cbnz	r1, 8002d7c <USB_SetDevAddress+0x8>
  {
   /* set device address and enable function */
   USBx->DADDR = USB_DADDR_EF;
 8002d76:	2380      	movs	r3, #128	; 0x80
 8002d78:	f8a0 304c 	strh.w	r3, [r0, #76]	; 0x4c
  }
  
  return HAL_OK;
}
 8002d7c:	2000      	movs	r0, #0
 8002d7e:	4770      	bx	lr

08002d80 <USB_DevConnect>:
 8002d80:	2000      	movs	r0, #0
 8002d82:	4770      	bx	lr

08002d84 <USB_DevDisconnect>:
  /* NOTE : - This function is not required by USB Device FS peripheral, it is used 
              only by USB OTG FS peripheral.
            - This function is added to ensure compatibility across platforms.
   */
  return HAL_OK;
}
 8002d84:	2000      	movs	r0, #0
 8002d86:	4770      	bx	lr

08002d88 <USB_ReadInterrupts>:
  */
uint32_t  USB_ReadInterrupts (USB_TypeDef *USBx)
{
  uint32_t tmpreg = 0;
  
  tmpreg = USBx->ISTR;
 8002d88:	f8b0 0044 	ldrh.w	r0, [r0, #68]	; 0x44
  return tmpreg;
}
 8002d8c:	b280      	uxth	r0, r0
 8002d8e:	4770      	bx	lr

08002d90 <USB_EP0_OutStart>:
  /* NOTE : - This function is not required by USB Device FS peripheral, it is used 
              only by USB OTG FS peripheral.
            - This function is added to ensure compatibility across platforms.
   */
  return HAL_OK;
}
 8002d90:	2000      	movs	r0, #0
 8002d92:	4770      	bx	lr

08002d94 <USB_WritePMA>:
  * @param  wNBytes : number of bytes to be copied.
  * @retval None
  */
void USB_WritePMA(USB_TypeDef *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t nbytes = (wNBytes + 1) >> 1;   /* nbytes = (wNBytes + 1) / 2 */
 8002d94:	3301      	adds	r3, #1
  uint32_t index = 0, temp1 = 0, temp2 = 0;
  uint16_t *pdwVal = NULL;
  
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
 8002d96:	f500 6080 	add.w	r0, r0, #1024	; 0x400
  for (index = nbytes; index != 0; index--)
 8002d9a:	105b      	asrs	r3, r3, #1
{
  uint32_t nbytes = (wNBytes + 1) >> 1;   /* nbytes = (wNBytes + 1) / 2 */
  uint32_t index = 0, temp1 = 0, temp2 = 0;
  uint16_t *pdwVal = NULL;
  
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
 8002d9c:	eb00 0242 	add.w	r2, r0, r2, lsl #1
  for (index = nbytes; index != 0; index--)
 8002da0:	d009      	beq.n	8002db6 <USB_WritePMA+0x22>
  * @param  wPMABufAddr : address into PMA.
  * @param  wNBytes : number of bytes to be copied.
  * @retval None
  */
void USB_WritePMA(USB_TypeDef *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
 8002da2:	b430      	push	{r4, r5}
  uint32_t nbytes = (wNBytes + 1) >> 1;   /* nbytes = (wNBytes + 1) / 2 */
  uint32_t index = 0, temp1 = 0, temp2 = 0;
  uint16_t *pdwVal = NULL;
  
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
  for (index = nbytes; index != 0; index--)
 8002da4:	2400      	movs	r4, #0
 8002da6:	f831 5b02 	ldrh.w	r5, [r1], #2
  {
    temp1 = (uint16_t) * pbUsrBuf;
    pbUsrBuf++;
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
    *pdwVal++ = temp2;
 8002daa:	f822 5024 	strh.w	r5, [r2, r4, lsl #2]
 8002dae:	3401      	adds	r4, #1
  uint32_t nbytes = (wNBytes + 1) >> 1;   /* nbytes = (wNBytes + 1) / 2 */
  uint32_t index = 0, temp1 = 0, temp2 = 0;
  uint16_t *pdwVal = NULL;
  
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
  for (index = nbytes; index != 0; index--)
 8002db0:	42a3      	cmp	r3, r4
 8002db2:	d1f8      	bne.n	8002da6 <USB_WritePMA+0x12>
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
    *pdwVal++ = temp2;
    pdwVal++;
    pbUsrBuf++;
  }
}
 8002db4:	bc30      	pop	{r4, r5}
 8002db6:	4770      	bx	lr

08002db8 <USB_ReadPMA>:
  * @param  wNBytes : number of bytes to be copied.
  * @retval None
  */
void USB_ReadPMA(USB_TypeDef *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t nbytes = (wNBytes + 1) >> 1;/* /2*/
 8002db8:	3301      	adds	r3, #1
  uint32_t index = 0;
  uint32_t *pdwVal = NULL;
  
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
 8002dba:	f500 6080 	add.w	r0, r0, #1024	; 0x400
  for (index = nbytes; index != 0; index--)
 8002dbe:	105b      	asrs	r3, r3, #1
{
  uint32_t nbytes = (wNBytes + 1) >> 1;/* /2*/
  uint32_t index = 0;
  uint32_t *pdwVal = NULL;
  
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
 8002dc0:	eb00 0242 	add.w	r2, r0, r2, lsl #1
  for (index = nbytes; index != 0; index--)
 8002dc4:	d005      	beq.n	8002dd2 <USB_ReadPMA+0x1a>
  {
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
 8002dc6:	f852 0b04 	ldr.w	r0, [r2], #4
  uint32_t nbytes = (wNBytes + 1) >> 1;/* /2*/
  uint32_t index = 0;
  uint32_t *pdwVal = NULL;
  
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
  for (index = nbytes; index != 0; index--)
 8002dca:	3b01      	subs	r3, #1
  {
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
 8002dcc:	f821 0b02 	strh.w	r0, [r1], #2
  uint32_t nbytes = (wNBytes + 1) >> 1;/* /2*/
  uint32_t index = 0;
  uint32_t *pdwVal = NULL;
  
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
  for (index = nbytes; index != 0; index--)
 8002dd0:	d1f9      	bne.n	8002dc6 <USB_ReadPMA+0xe>
 8002dd2:	4770      	bx	lr

08002dd4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8002dd4:	b508      	push	{r3, lr}
 8002dd6:	4c03      	ldr	r4, [pc, #12]	; (8002de4 <prvIdleTask+0x10>)
 8002dd8:	6823      	ldr	r3, [r4, #0]

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8002dda:	2b01      	cmp	r3, #1
 8002ddc:	d9fd      	bls.n	8002dda <prvIdleTask+0x6>
			{
				taskYIELD();
 8002dde:	f001 fd45 	bl	800486c <vPortYield>
 8002de2:	e7f9      	b.n	8002dd8 <prvIdleTask+0x4>
 8002de4:	200009e0 	.word	0x200009e0

08002de8 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8002de8:	4b0e      	ldr	r3, [pc, #56]	; (8002e24 <prvAddCurrentTaskToDelayedList+0x3c>)
 8002dea:	f8d3 108c 	ldr.w	r1, [r3, #140]	; 0x8c

	if( xTimeToWake < xTickCount )
 8002dee:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8002df2:	6048      	str	r0, [r1, #4]

	if( xTimeToWake < xTickCount )
 8002df4:	4290      	cmp	r0, r2
 8002df6:	d30e      	bcc.n	8002e16 <prvAddCurrentTaskToDelayedList+0x2e>
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
 8002df8:	b510      	push	{r4, lr}
 8002dfa:	4604      	mov	r4, r0
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8002dfc:	f8d3 0098 	ldr.w	r0, [r3, #152]	; 0x98
 8002e00:	f8d3 108c 	ldr.w	r1, [r3, #140]	; 0x8c
 8002e04:	3104      	adds	r1, #4
 8002e06:	f001 f88d 	bl	8003f24 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 8002e0a:	4b07      	ldr	r3, [pc, #28]	; (8002e28 <prvAddCurrentTaskToDelayedList+0x40>)
 8002e0c:	681a      	ldr	r2, [r3, #0]
 8002e0e:	4294      	cmp	r4, r2
		{
			xNextTaskUnblockTime = xTimeToWake;
 8002e10:	bf38      	it	cc
 8002e12:	601c      	strcc	r4, [r3, #0]
 8002e14:	bd10      	pop	{r4, pc}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8002e16:	f8d3 0094 	ldr.w	r0, [r3, #148]	; 0x94
 8002e1a:	f8d3 108c 	ldr.w	r1, [r3, #140]	; 0x8c
 8002e1e:	3104      	adds	r1, #4
 8002e20:	f001 b880 	b.w	8003f24 <vListInsert>
 8002e24:	200009e0 	.word	0x200009e0
 8002e28:	20000438 	.word	0x20000438

08002e2c <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 8002e2c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002e30:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8002e32:	469a      	mov	sl, r3
 8002e34:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
 8002e38:	9b0c      	ldr	r3, [sp, #48]	; 0x30
BaseType_t xReturn;
TCB_t * pxNewTCB;
StackType_t *pxTopOfStack;

	configASSERT( pxTaskCode );
 8002e3a:	2800      	cmp	r0, #0
 8002e3c:	f000 8088 	beq.w	8002f50 <xTaskGenericCreate+0x124>
	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );
 8002e40:	2f04      	cmp	r7, #4
 8002e42:	d902      	bls.n	8002e4a <xTaskGenericCreate+0x1e>
 8002e44:	f001 fd1e 	bl	8004884 <ulPortSetInterruptMask>
 8002e48:	e7fe      	b.n	8002e48 <xTaskGenericCreate+0x1c>
 8002e4a:	460e      	mov	r6, r1
 8002e4c:	4615      	mov	r5, r2
 8002e4e:	4681      	mov	r9, r0
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002e50:	469b      	mov	fp, r3
 8002e52:	2b00      	cmp	r3, #0
 8002e54:	f000 80b0 	beq.w	8002fb8 <xTaskGenericCreate+0x18c>

		if( pxStack != NULL )
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 8002e58:	205c      	movs	r0, #92	; 0x5c
 8002e5a:	f002 fed1 	bl	8005c00 <pvPortMalloc>

			if( pxNewTCB != NULL )
 8002e5e:	4604      	mov	r4, r0
 8002e60:	2800      	cmp	r0, #0
 8002e62:	f000 80a2 	beq.w	8002faa <xTaskGenericCreate+0x17e>
	{
		/* Avoid dependency on memset() if it is not required. */
		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
 8002e66:	00ad      	lsls	r5, r5, #2
 8002e68:	462a      	mov	r2, r5
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );

			if( pxNewTCB != NULL )
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
 8002e6a:	f8c0 b030 	str.w	fp, [r0, #48]	; 0x30
	{
		/* Avoid dependency on memset() if it is not required. */
		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
 8002e6e:	21a5      	movs	r1, #165	; 0xa5
 8002e70:	4658      	mov	r0, fp
 8002e72:	f003 f803 	bl	8005e7c <memset>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8002e76:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002e78:	3d04      	subs	r5, #4
 8002e7a:	441d      	add	r5, r3
 8002e7c:	f025 0507 	bic.w	r5, r5, #7
 8002e80:	1e73      	subs	r3, r6, #1
 8002e82:	f104 0233 	add.w	r2, r4, #51	; 0x33
 8002e86:	360f      	adds	r6, #15
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 8002e88:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 8002e8c:	f802 1f01 	strb.w	r1, [r2, #1]!

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 8002e90:	7819      	ldrb	r1, [r3, #0]
 8002e92:	b109      	cbz	r1, 8002e98 <xTaskGenericCreate+0x6c>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8002e94:	42b3      	cmp	r3, r6
 8002e96:	d1f7      	bne.n	8002e88 <xTaskGenericCreate+0x5c>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8002e98:	2600      	movs	r6, #0
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8002e9a:	f104 0b04 	add.w	fp, r4, #4
 8002e9e:	4658      	mov	r0, fp
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
 8002ea0:	62e7      	str	r7, [r4, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 8002ea2:	64e7      	str	r7, [r4, #76]	; 0x4c
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8002ea4:	f884 6043 	strb.w	r6, [r4, #67]	; 0x43

	pxTCB->uxPriority = uxPriority;
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
 8002ea8:	6526      	str	r6, [r4, #80]	; 0x50
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8002eaa:	f001 f829 	bl	8003f00 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 8002eae:	f104 0018 	add.w	r0, r4, #24
 8002eb2:	f001 f825 	bl	8003f00 <vListInitialiseItem>
	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002eb6:	f1c7 0305 	rsb	r3, r7, #5
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
 8002eba:	6566      	str	r6, [r4, #84]	; 0x54
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 8002ebc:	6124      	str	r4, [r4, #16]
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
		pxTCB->eNotifyState = eNotWaitingNotification;
 8002ebe:	f884 6058 	strb.w	r6, [r4, #88]	; 0x58
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 8002ec2:	6264      	str	r4, [r4, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8002ec4:	4652      	mov	r2, sl
 8002ec6:	4649      	mov	r1, r9
 8002ec8:	4628      	mov	r0, r5
	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002eca:	61a3      	str	r3, [r4, #24]
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8002ecc:	f001 fcaa 	bl	8004824 <pxPortInitialiseStack>
 8002ed0:	6020      	str	r0, [r4, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
 8002ed2:	f1b8 0f00 	cmp.w	r8, #0
 8002ed6:	d001      	beq.n	8002edc <xTaskGenericCreate+0xb0>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8002ed8:	f8c8 4000 	str.w	r4, [r8]

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
		{
			uxCurrentNumberOfTasks++;
 8002edc:	4d3a      	ldr	r5, [pc, #232]	; (8002fc8 <xTaskGenericCreate+0x19c>)
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
 8002ede:	f001 fce7 	bl	80048b0 <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 8002ee2:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
 8002ee6:	3301      	adds	r3, #1
 8002ee8:	f8c5 309c 	str.w	r3, [r5, #156]	; 0x9c
			if( pxCurrentTCB == NULL )
 8002eec:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
 8002ef0:	b3b3      	cbz	r3, 8002f60 <xTaskGenericCreate+0x134>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 8002ef2:	f8d5 30c8 	ldr.w	r3, [r5, #200]	; 0xc8
 8002ef6:	b933      	cbnz	r3, 8002f06 <xTaskGenericCreate+0xda>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 8002ef8:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
 8002efc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002efe:	429f      	cmp	r7, r3
					{
						pxCurrentTCB = pxNewTCB;
 8002f00:	bf28      	it	cs
 8002f02:	f8c5 408c 	strcs.w	r4, [r5, #140]	; 0x8c
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8002f06:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8002f08:	f8d5 30cc 	ldr.w	r3, [r5, #204]	; 0xcc
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8002f0c:	f8d5 20d0 	ldr.w	r2, [r5, #208]	; 0xd0
 8002f10:	2601      	movs	r6, #1
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8002f12:	4433      	add	r3, r6
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8002f14:	fa06 fe00 	lsl.w	lr, r6, r0
 8002f18:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002f1c:	ea4e 0202 	orr.w	r2, lr, r2
			uxTaskNumber++;

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
 8002f20:	6463      	str	r3, [r4, #68]	; 0x44
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8002f22:	4659      	mov	r1, fp
 8002f24:	eb05 0080 	add.w	r0, r5, r0, lsl #2
 8002f28:	f8c5 20d0 	str.w	r2, [r5, #208]	; 0xd0
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8002f2c:	f8c5 30cc 	str.w	r3, [r5, #204]	; 0xcc
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8002f30:	f000 ffea 	bl	8003f08 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 8002f34:	f001 fcda 	bl	80048ec <vPortExitCritical>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 8002f38:	f8d5 20c8 	ldr.w	r2, [r5, #200]	; 0xc8
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8002f3c:	4b22      	ldr	r3, [pc, #136]	; (8002fc8 <xTaskGenericCreate+0x19c>)
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 8002f3e:	b122      	cbz	r2, 8002f4a <xTaskGenericCreate+0x11e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 8002f40:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8002f44:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002f46:	429f      	cmp	r7, r3
 8002f48:	d805      	bhi.n	8002f56 <xTaskGenericCreate+0x12a>
 8002f4a:	4630      	mov	r0, r6
 8002f4c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
BaseType_t xReturn;
TCB_t * pxNewTCB;
StackType_t *pxTopOfStack;

	configASSERT( pxTaskCode );
 8002f50:	f001 fc98 	bl	8004884 <ulPortSetInterruptMask>
 8002f54:	e7fe      	b.n	8002f54 <xTaskGenericCreate+0x128>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
			{
				taskYIELD_IF_USING_PREEMPTION();
 8002f56:	f001 fc89 	bl	800486c <vPortYield>
 8002f5a:	4630      	mov	r0, r6
 8002f5c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			uxCurrentNumberOfTasks++;
			if( pxCurrentTCB == NULL )
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 8002f60:	f8c5 408c 	str.w	r4, [r5, #140]	; 0x8c

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8002f64:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
 8002f68:	2b01      	cmp	r3, #1
 8002f6a:	d1cc      	bne.n	8002f06 <xTaskGenericCreate+0xda>
 8002f6c:	462e      	mov	r6, r5
 8002f6e:	f105 0864 	add.w	r8, r5, #100	; 0x64
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8002f72:	4630      	mov	r0, r6
 8002f74:	3614      	adds	r6, #20
 8002f76:	f000 ffb7 	bl	8003ee8 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8002f7a:	4546      	cmp	r6, r8
 8002f7c:	d1f9      	bne.n	8002f72 <xTaskGenericCreate+0x146>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 8002f7e:	4e13      	ldr	r6, [pc, #76]	; (8002fcc <xTaskGenericCreate+0x1a0>)
 8002f80:	4630      	mov	r0, r6
	vListInitialise( &xDelayedTaskList2 );
 8002f82:	f106 0814 	add.w	r8, r6, #20
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 8002f86:	f000 ffaf 	bl	8003ee8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8002f8a:	4640      	mov	r0, r8
 8002f8c:	f000 ffac 	bl	8003ee8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8002f90:	f1a6 0028 	sub.w	r0, r6, #40	; 0x28
 8002f94:	f000 ffa8 	bl	8003ee8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 8002f98:	f1a6 003c 	sub.w	r0, r6, #60	; 0x3c
 8002f9c:	f000 ffa4 	bl	8003ee8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8002fa0:	f8c5 6098 	str.w	r6, [r5, #152]	; 0x98
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8002fa4:	f8c5 8094 	str.w	r8, [r5, #148]	; 0x94
 8002fa8:	e7ad      	b.n	8002f06 <xTaskGenericCreate+0xda>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
 8002faa:	4658      	mov	r0, fp
 8002fac:	f002 fe56 	bl	8005c5c <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8002fb0:	f04f 30ff 	mov.w	r0, #4294967295
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
 8002fb4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002fb8:	0090      	lsls	r0, r2, #2
 8002fba:	f002 fe21 	bl	8005c00 <pvPortMalloc>

		if( pxStack != NULL )
 8002fbe:	4683      	mov	fp, r0
 8002fc0:	2800      	cmp	r0, #0
 8002fc2:	d0f5      	beq.n	8002fb0 <xTaskGenericCreate+0x184>
 8002fc4:	e748      	b.n	8002e58 <xTaskGenericCreate+0x2c>
 8002fc6:	bf00      	nop
 8002fc8:	200009e0 	.word	0x200009e0
 8002fcc:	20000a80 	.word	0x20000a80

08002fd0 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 8002fd0:	b530      	push	{r4, r5, lr}
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 8002fd2:	2400      	movs	r4, #0

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 8002fd4:	b085      	sub	sp, #20
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 8002fd6:	9403      	str	r4, [sp, #12]
 8002fd8:	9402      	str	r4, [sp, #8]
 8002fda:	9401      	str	r4, [sp, #4]
 8002fdc:	9400      	str	r4, [sp, #0]
 8002fde:	4623      	mov	r3, r4
 8002fe0:	2240      	movs	r2, #64	; 0x40
 8002fe2:	490f      	ldr	r1, [pc, #60]	; (8003020 <vTaskStartScheduler+0x50>)
 8002fe4:	480f      	ldr	r0, [pc, #60]	; (8003024 <vTaskStartScheduler+0x54>)
 8002fe6:	f7ff ff21 	bl	8002e2c <xTaskGenericCreate>
	}
	#endif /* INCLUDE_xTaskGetIdleTaskHandle */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 8002fea:	2801      	cmp	r0, #1
 8002fec:	d006      	beq.n	8002ffc <vTaskStartScheduler+0x2c>
 8002fee:	4605      	mov	r5, r0
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
 8002ff0:	b10d      	cbz	r5, 8002ff6 <vTaskStartScheduler+0x26>
	}
}
 8002ff2:	b005      	add	sp, #20
 8002ff4:	bd30      	pop	{r4, r5, pc}
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
 8002ff6:	f001 fc45 	bl	8004884 <ulPortSetInterruptMask>
 8002ffa:	e7fe      	b.n	8002ffa <vTaskStartScheduler+0x2a>

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
		{
			xReturn = xTimerCreateTimerTask();
 8002ffc:	f7ff f8f6 	bl	80021ec <xTimerCreateTimerTask>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 8003000:	2801      	cmp	r0, #1

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
		{
			xReturn = xTimerCreateTimerTask();
 8003002:	4605      	mov	r5, r0
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 8003004:	d1f4      	bne.n	8002ff0 <vTaskStartScheduler+0x20>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 8003006:	f001 fc3d 	bl	8004884 <ulPortSetInterruptMask>
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
 800300a:	4b07      	ldr	r3, [pc, #28]	; (8003028 <vTaskStartScheduler+0x58>)
 800300c:	f8c3 50c8 	str.w	r5, [r3, #200]	; 0xc8
		xTickCount = ( TickType_t ) 0U;
 8003010:	f8c3 4090 	str.w	r4, [r3, #144]	; 0x90
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 8003014:	b005      	add	sp, #20
 8003016:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 800301a:	f001 bcc3 	b.w	80049a4 <xPortStartScheduler>
 800301e:	bf00      	nop
 8003020:	08006288 	.word	0x08006288
 8003024:	08002dd5 	.word	0x08002dd5
 8003028:	200009e0 	.word	0x200009e0

0800302c <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 800302c:	4a03      	ldr	r2, [pc, #12]	; (800303c <vTaskSuspendAll+0x10>)
 800302e:	f8d2 30d4 	ldr.w	r3, [r2, #212]	; 0xd4
 8003032:	3301      	adds	r3, #1
 8003034:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
 8003038:	4770      	bx	lr
 800303a:	bf00      	nop
 800303c:	200009e0 	.word	0x200009e0

08003040 <xTaskGetTickCount>:
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
 8003040:	4b01      	ldr	r3, [pc, #4]	; (8003048 <xTaskGetTickCount+0x8>)
 8003042:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
}
 8003046:	4770      	bx	lr
 8003048:	200009e0 	.word	0x200009e0

0800304c <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 800304c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8003050:	4c45      	ldr	r4, [pc, #276]	; (8003168 <xTaskIncrementTick+0x11c>)
 8003052:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8003056:	2b00      	cmp	r3, #0
 8003058:	d14e      	bne.n	80030f8 <xTaskIncrementTick+0xac>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
 800305a:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 800305e:	3301      	adds	r3, #1
 8003060:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 8003064:	f8d4 8090 	ldr.w	r8, [r4, #144]	; 0x90

			if( xConstTickCount == ( TickType_t ) 0U )
 8003068:	f1b8 0f00 	cmp.w	r8, #0
 800306c:	d052      	beq.n	8003114 <xTaskIncrementTick+0xc8>
 800306e:	4f3f      	ldr	r7, [pc, #252]	; (800316c <xTaskIncrementTick+0x120>)

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 8003070:	683b      	ldr	r3, [r7, #0]
 8003072:	4598      	cmp	r8, r3
 8003074:	d36a      	bcc.n	800314c <xTaskIncrementTick+0x100>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003076:	f8df a0f0 	ldr.w	sl, [pc, #240]	; 8003168 <xTaskIncrementTick+0x11c>
 800307a:	2600      	movs	r6, #0
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 800307c:	f04f 0901 	mov.w	r9, #1
 8003080:	e027      	b.n	80030d2 <xTaskIncrementTick+0x86>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8003082:	f8da 3098 	ldr.w	r3, [sl, #152]	; 0x98
 8003086:	68db      	ldr	r3, [r3, #12]
 8003088:	68dd      	ldr	r5, [r3, #12]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 800308a:	686b      	ldr	r3, [r5, #4]
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 800308c:	f105 0b04 	add.w	fp, r5, #4
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );

						if( xConstTickCount < xItemValue )
 8003090:	4598      	cmp	r8, r3
 8003092:	d325      	bcc.n	80030e0 <xTaskIncrementTick+0x94>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8003094:	4658      	mov	r0, fp
 8003096:	f000 ff5f 	bl	8003f58 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800309a:	6aab      	ldr	r3, [r5, #40]	; 0x28
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800309c:	f105 0018 	add.w	r0, r5, #24
						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80030a0:	b10b      	cbz	r3, 80030a6 <xTaskIncrementTick+0x5a>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80030a2:	f000 ff59 	bl	8003f58 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 80030a6:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 80030a8:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 80030ac:	fa09 f200 	lsl.w	r2, r9, r0
 80030b0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80030b4:	4313      	orrs	r3, r2
 80030b6:	4659      	mov	r1, fp
 80030b8:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 80030bc:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
 80030c0:	f000 ff22 	bl	8003f08 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80030c4:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 80030c8:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 80030ca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							{
								xSwitchRequired = pdTRUE;
 80030cc:	429a      	cmp	r2, r3
 80030ce:	bf28      	it	cs
 80030d0:	2601      	movcs	r6, #1
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80030d2:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 80030d6:	681b      	ldr	r3, [r3, #0]
 80030d8:	2b00      	cmp	r3, #0
 80030da:	d1d2      	bne.n	8003082 <xTaskIncrementTick+0x36>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 80030dc:	f04f 33ff 	mov.w	r3, #4294967295
 80030e0:	603b      	str	r3, [r7, #0]
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 80030e2:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 80030e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80030e8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80030ec:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
			{
				xSwitchRequired = pdTRUE;
 80030f0:	2b02      	cmp	r3, #2
 80030f2:	bf28      	it	cs
 80030f4:	2601      	movcs	r6, #1
 80030f6:	e005      	b.n	8003104 <xTaskIncrementTick+0xb8>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 80030f8:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 80030fc:	2600      	movs	r6, #0
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 80030fe:	3301      	adds	r3, #1
 8003100:	f8c4 30dc 	str.w	r3, [r4, #220]	; 0xdc
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 8003104:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
		{
			xSwitchRequired = pdTRUE;
 8003108:	2b00      	cmp	r3, #0
 800310a:	bf18      	it	ne
 800310c:	2601      	movne	r6, #1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 800310e:	4630      	mov	r0, r6
 8003110:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			block. */
			const TickType_t xConstTickCount = xTickCount;

			if( xConstTickCount == ( TickType_t ) 0U )
			{
				taskSWITCH_DELAYED_LISTS();
 8003114:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8003118:	681b      	ldr	r3, [r3, #0]
 800311a:	bb0b      	cbnz	r3, 8003160 <xTaskIncrementTick+0x114>
 800311c:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8003120:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
 8003124:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
 8003128:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
 800312c:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
 8003130:	3301      	adds	r3, #1
 8003132:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003136:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 800313a:	681b      	ldr	r3, [r3, #0]
 800313c:	b943      	cbnz	r3, 8003150 <xTaskIncrementTick+0x104>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 800313e:	4f0b      	ldr	r7, [pc, #44]	; (800316c <xTaskIncrementTick+0x120>)
 8003140:	f04f 33ff 	mov.w	r3, #4294967295
 8003144:	603b      	str	r3, [r7, #0]

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 8003146:	683b      	ldr	r3, [r7, #0]
 8003148:	4598      	cmp	r8, r3
 800314a:	d294      	bcs.n	8003076 <xTaskIncrementTick+0x2a>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 800314c:	2600      	movs	r6, #0
 800314e:	e7c8      	b.n	80030e2 <xTaskIncrementTick+0x96>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8003150:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 8003154:	4f05      	ldr	r7, [pc, #20]	; (800316c <xTaskIncrementTick+0x120>)
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8003156:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 8003158:	68db      	ldr	r3, [r3, #12]
 800315a:	685b      	ldr	r3, [r3, #4]
 800315c:	603b      	str	r3, [r7, #0]
 800315e:	e787      	b.n	8003070 <xTaskIncrementTick+0x24>
			block. */
			const TickType_t xConstTickCount = xTickCount;

			if( xConstTickCount == ( TickType_t ) 0U )
			{
				taskSWITCH_DELAYED_LISTS();
 8003160:	f001 fb90 	bl	8004884 <ulPortSetInterruptMask>
 8003164:	e7fe      	b.n	8003164 <xTaskIncrementTick+0x118>
 8003166:	bf00      	nop
 8003168:	200009e0 	.word	0x200009e0
 800316c:	20000438 	.word	0x20000438

08003170 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 8003170:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
 8003174:	4c34      	ldr	r4, [pc, #208]	; (8003248 <xTaskResumeAll+0xd8>)
 8003176:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 800317a:	b913      	cbnz	r3, 8003182 <xTaskResumeAll+0x12>
 800317c:	f001 fb82 	bl	8004884 <ulPortSetInterruptMask>
 8003180:	e7fe      	b.n	8003180 <xTaskResumeAll+0x10>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 8003182:	f001 fb95 	bl	80048b0 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 8003186:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 800318a:	3b01      	subs	r3, #1
 800318c:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8003190:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8003194:	bbb3      	cbnz	r3, 8003204 <xTaskResumeAll+0x94>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8003196:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
 800319a:	b39b      	cbz	r3, 8003204 <xTaskResumeAll+0x94>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800319c:	4625      	mov	r5, r4
 800319e:	46a1      	mov	r9, r4
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyList( pxTCB );
 80031a0:	f04f 0801 	mov.w	r8, #1
 80031a4:	e021      	b.n	80031ea <xTaskResumeAll+0x7a>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 80031a6:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
 80031aa:	68de      	ldr	r6, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 80031ac:	1d37      	adds	r7, r6, #4
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80031ae:	f106 0018 	add.w	r0, r6, #24
 80031b2:	f000 fed1 	bl	8003f58 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 80031b6:	4638      	mov	r0, r7
 80031b8:	f000 fece 	bl	8003f58 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80031bc:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 80031be:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
 80031c2:	fa08 f200 	lsl.w	r2, r8, r0
 80031c6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80031ca:	4313      	orrs	r3, r2
 80031cc:	4639      	mov	r1, r7
 80031ce:	eb05 0080 	add.w	r0, r5, r0, lsl #2
 80031d2:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0
 80031d6:	f000 fe97 	bl	8003f08 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80031da:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
 80031de:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 80031e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80031e2:	429a      	cmp	r2, r3
					{
						xYieldPending = pdTRUE;
 80031e4:	bf28      	it	cs
 80031e6:	f8c9 a0e0 	strcs.w	sl, [r9, #224]	; 0xe0
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80031ea:	6fa2      	ldr	r2, [r4, #120]	; 0x78
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyList( pxTCB );
 80031ec:	f04f 0a01 	mov.w	sl, #1
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80031f0:	4b15      	ldr	r3, [pc, #84]	; (8003248 <xTaskResumeAll+0xd8>)
 80031f2:	2a00      	cmp	r2, #0
 80031f4:	d1d7      	bne.n	80031a6 <xTaskResumeAll+0x36>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
 80031f6:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
 80031fa:	b94a      	cbnz	r2, 8003210 <xTaskResumeAll+0xa0>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
 80031fc:	f8d4 40e0 	ldr.w	r4, [r4, #224]	; 0xe0
 8003200:	2c01      	cmp	r4, #1
 8003202:	d019      	beq.n	8003238 <xTaskResumeAll+0xc8>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
 8003204:	2400      	movs	r4, #0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8003206:	f001 fb71 	bl	80048ec <vPortExitCritical>

	return xAlreadyYielded;
}
 800320a:	4620      	mov	r0, r4
 800320c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 8003210:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 8003214:	2b00      	cmp	r3, #0
 8003216:	d0f1      	beq.n	80031fc <xTaskResumeAll+0x8c>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
 8003218:	2501      	movs	r5, #1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
 800321a:	f7ff ff17 	bl	800304c <xTaskIncrementTick>
 800321e:	b108      	cbz	r0, 8003224 <xTaskResumeAll+0xb4>
						{
							xYieldPending = pdTRUE;
 8003220:	f8c4 50e0 	str.w	r5, [r4, #224]	; 0xe0
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
 8003224:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
 8003228:	3b01      	subs	r3, #1
 800322a:	f8c4 30dc 	str.w	r3, [r4, #220]	; 0xdc
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 800322e:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
 8003232:	2b00      	cmp	r3, #0
 8003234:	d1f1      	bne.n	800321a <xTaskResumeAll+0xaa>
 8003236:	e7e1      	b.n	80031fc <xTaskResumeAll+0x8c>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 8003238:	f001 fb18 	bl	800486c <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 800323c:	f001 fb56 	bl	80048ec <vPortExitCritical>

	return xAlreadyYielded;
}
 8003240:	4620      	mov	r0, r4
 8003242:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8003246:	bf00      	nop
 8003248:	200009e0 	.word	0x200009e0

0800324c <vTaskDelay>:
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 800324c:	b328      	cbz	r0, 800329a <vTaskDelay+0x4e>
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 800324e:	b538      	push	{r3, r4, r5, lr}


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
 8003250:	4c16      	ldr	r4, [pc, #88]	; (80032ac <vTaskDelay+0x60>)
 8003252:	4603      	mov	r3, r0
 8003254:	f8d4 20d4 	ldr.w	r2, [r4, #212]	; 0xd4
 8003258:	bb0a      	cbnz	r2, 800329e <vTaskDelay+0x52>
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 800325a:	f8d4 20d4 	ldr.w	r2, [r4, #212]	; 0xd4
 800325e:	3201      	adds	r2, #1
 8003260:	f8c4 20d4 	str.w	r2, [r4, #212]	; 0xd4
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8003264:	f8d4 5090 	ldr.w	r5, [r4, #144]	; 0x90

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8003268:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 800326c:	441d      	add	r5, r3

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 800326e:	3004      	adds	r0, #4
 8003270:	f000 fe72 	bl	8003f58 <uxListRemove>
 8003274:	b950      	cbnz	r0, 800328c <vTaskDelay+0x40>
				{
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8003276:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 800327a:	2201      	movs	r2, #1
 800327c:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 800327e:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 8003282:	408a      	lsls	r2, r1
 8003284:	ea23 0302 	bic.w	r3, r3, r2
 8003288:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 800328c:	4628      	mov	r0, r5
 800328e:	f7ff fdab 	bl	8002de8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 8003292:	f7ff ff6d 	bl	8003170 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8003296:	b128      	cbz	r0, 80032a4 <vTaskDelay+0x58>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8003298:	bd38      	pop	{r3, r4, r5, pc}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 800329a:	f001 bae7 	b.w	800486c <vPortYield>


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
 800329e:	f001 faf1 	bl	8004884 <ulPortSetInterruptMask>
 80032a2:	e7fe      	b.n	80032a2 <vTaskDelay+0x56>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 80032a4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 80032a8:	f001 bae0 	b.w	800486c <vPortYield>
 80032ac:	200009e0 	.word	0x200009e0

080032b0 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 80032b0:	4a14      	ldr	r2, [pc, #80]	; (8003304 <vTaskSwitchContext+0x54>)

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 80032b2:	b508      	push	{r3, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 80032b4:	f8d2 30d4 	ldr.w	r3, [r2, #212]	; 0xd4
 80032b8:	b9fb      	cbnz	r3, 80032fa <vTaskSwitchContext+0x4a>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
 80032ba:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 80032be:	f8d2 30d0 	ldr.w	r3, [r2, #208]	; 0xd0
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 80032c2:	fab3 f383 	clz	r3, r3
 80032c6:	b2db      	uxtb	r3, r3
 80032c8:	f1c3 031f 	rsb	r3, r3, #31
 80032cc:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80032d0:	009b      	lsls	r3, r3, #2
 80032d2:	58d1      	ldr	r1, [r2, r3]
 80032d4:	18d0      	adds	r0, r2, r3
 80032d6:	b169      	cbz	r1, 80032f4 <vTaskSwitchContext+0x44>
 80032d8:	6841      	ldr	r1, [r0, #4]
 80032da:	3308      	adds	r3, #8
 80032dc:	6849      	ldr	r1, [r1, #4]
 80032de:	4413      	add	r3, r2
 80032e0:	4299      	cmp	r1, r3
 80032e2:	6041      	str	r1, [r0, #4]
 80032e4:	bf08      	it	eq
 80032e6:	6849      	ldreq	r1, [r1, #4]
 80032e8:	68cb      	ldr	r3, [r1, #12]
 80032ea:	bf08      	it	eq
 80032ec:	6041      	streq	r1, [r0, #4]
 80032ee:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 80032f2:	bd08      	pop	{r3, pc}
 80032f4:	f001 fac6 	bl	8004884 <ulPortSetInterruptMask>
 80032f8:	e7fe      	b.n	80032f8 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 80032fa:	2301      	movs	r3, #1
 80032fc:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8003300:	bd08      	pop	{r3, pc}
 8003302:	bf00      	nop
 8003304:	200009e0 	.word	0x200009e0

08003308 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 8003308:	b538      	push	{r3, r4, r5, lr}
TickType_t xTimeToWake;

	configASSERT( pxEventList );
 800330a:	b300      	cbz	r0, 800334e <vTaskPlaceOnEventList+0x46>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800330c:	4c15      	ldr	r4, [pc, #84]	; (8003364 <vTaskPlaceOnEventList+0x5c>)
 800330e:	460d      	mov	r5, r1
 8003310:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
 8003314:	3118      	adds	r1, #24
 8003316:	f000 fe05 	bl	8003f24 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 800331a:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 800331e:	3004      	adds	r0, #4
 8003320:	f000 fe1a 	bl	8003f58 <uxListRemove>
 8003324:	b950      	cbnz	r0, 800333c <vTaskPlaceOnEventList+0x34>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8003326:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 800332a:	2201      	movs	r2, #1
 800332c:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 800332e:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 8003332:	408a      	lsls	r2, r1
 8003334:	ea23 0302 	bic.w	r3, r3, r2
 8003338:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
 800333c:	1c6b      	adds	r3, r5, #1
 800333e:	d009      	beq.n	8003354 <vTaskPlaceOnEventList+0x4c>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
 8003340:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 8003344:	4428      	add	r0, r5
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8003346:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 800334a:	f7ff bd4d 	b.w	8002de8 <prvAddCurrentTaskToDelayedList>

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
TickType_t xTimeToWake;

	configASSERT( pxEventList );
 800334e:	f001 fa99 	bl	8004884 <ulPortSetInterruptMask>
 8003352:	e7fe      	b.n	8003352 <vTaskPlaceOnEventList+0x4a>
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8003354:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
 8003358:	4803      	ldr	r0, [pc, #12]	; (8003368 <vTaskPlaceOnEventList+0x60>)
 800335a:	3104      	adds	r1, #4
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 800335c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8003360:	f000 bdd2 	b.w	8003f08 <vListInsertEnd>
 8003364:	200009e0 	.word	0x200009e0
 8003368:	20000a44 	.word	0x20000a44

0800336c <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait )
	{
 800336c:	b538      	push	{r3, r4, r5, lr}
	TickType_t xTimeToWake;

		configASSERT( pxEventList );
 800336e:	b1f0      	cbz	r0, 80033ae <vTaskPlaceOnEventListRestricted+0x42>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8003370:	4c10      	ldr	r4, [pc, #64]	; (80033b4 <vTaskPlaceOnEventListRestricted+0x48>)
 8003372:	460d      	mov	r5, r1
 8003374:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
 8003378:	3118      	adds	r1, #24
 800337a:	f000 fdc5 	bl	8003f08 <vListInsertEnd>

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called with the scheduler locked so interrupts will not
		access the lists at the same time. */
		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 800337e:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 8003382:	3004      	adds	r0, #4
 8003384:	f000 fde8 	bl	8003f58 <uxListRemove>
 8003388:	b950      	cbnz	r0, 80033a0 <vTaskPlaceOnEventListRestricted+0x34>
		{
			/* The current task must be in a ready list, so there is no need to
			check, and the port reset macro can be called directly. */
			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 800338a:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 800338e:	2201      	movs	r2, #1
 8003390:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8003392:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 8003396:	408a      	lsls	r2, r1
 8003398:	ea23 0302 	bic.w	r3, r3, r2
 800339c:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
			mtCOVERAGE_TEST_MARKER();
		}

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
 80033a0:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90

		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
 80033a4:	4428      	add	r0, r5
	}
 80033a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;

		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
 80033aa:	f7ff bd1d 	b.w	8002de8 <prvAddCurrentTaskToDelayedList>

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait )
	{
	TickType_t xTimeToWake;

		configASSERT( pxEventList );
 80033ae:	f001 fa69 	bl	8004884 <ulPortSetInterruptMask>
 80033b2:	e7fe      	b.n	80033b2 <vTaskPlaceOnEventListRestricted+0x46>
 80033b4:	200009e0 	.word	0x200009e0

080033b8 <xTaskRemoveFromEventList>:
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 80033b8:	68c3      	ldr	r3, [r0, #12]

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 80033ba:	b570      	push	{r4, r5, r6, lr}
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 80033bc:	68dd      	ldr	r5, [r3, #12]
	configASSERT( pxUnblockedTCB );
 80033be:	b36d      	cbz	r5, 800341c <xTaskRemoveFromEventList+0x64>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 80033c0:	f105 0618 	add.w	r6, r5, #24

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80033c4:	4c17      	ldr	r4, [pc, #92]	; (8003424 <xTaskRemoveFromEventList+0x6c>)

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 80033c6:	4630      	mov	r0, r6
 80033c8:	f000 fdc6 	bl	8003f58 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80033cc:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 80033d0:	b9f3      	cbnz	r3, 8003410 <xTaskRemoveFromEventList+0x58>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 80033d2:	1d2e      	adds	r6, r5, #4
 80033d4:	4630      	mov	r0, r6
 80033d6:	f000 fdbf 	bl	8003f58 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 80033da:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 80033dc:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 80033e0:	2201      	movs	r2, #1
 80033e2:	4082      	lsls	r2, r0
 80033e4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80033e8:	4313      	orrs	r3, r2
 80033ea:	4631      	mov	r1, r6
 80033ec:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 80033f0:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
 80033f4:	f000 fd88 	bl	8003f08 <vListInsertEnd>
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 80033f8:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 80033fc:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 80033fe:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8003400:	4b08      	ldr	r3, [pc, #32]	; (8003424 <xTaskRemoveFromEventList+0x6c>)
 8003402:	4291      	cmp	r1, r2
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 8003404:	bf86      	itte	hi
 8003406:	2001      	movhi	r0, #1
 8003408:	f8c3 00e0 	strhi.w	r0, [r3, #224]	; 0xe0
	}
	else
	{
		xReturn = pdFALSE;
 800340c:	2000      	movls	r0, #0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
 800340e:	bd70      	pop	{r4, r5, r6, pc}
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8003410:	4631      	mov	r1, r6
 8003412:	f104 0078 	add.w	r0, r4, #120	; 0x78
 8003416:	f000 fd77 	bl	8003f08 <vListInsertEnd>
 800341a:	e7ed      	b.n	80033f8 <xTaskRemoveFromEventList+0x40>
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	configASSERT( pxUnblockedTCB );
 800341c:	f001 fa32 	bl	8004884 <ulPortSetInterruptMask>
 8003420:	e7fe      	b.n	8003420 <xTaskRemoveFromEventList+0x68>
 8003422:	bf00      	nop
 8003424:	200009e0 	.word	0x200009e0

08003428 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 8003428:	b508      	push	{r3, lr}
	configASSERT( pxTimeOut );
 800342a:	b138      	cbz	r0, 800343c <vTaskSetTimeOutState+0x14>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800342c:	4b05      	ldr	r3, [pc, #20]	; (8003444 <vTaskSetTimeOutState+0x1c>)
 800342e:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
	pxTimeOut->xTimeOnEntering = xTickCount;
 8003432:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8003436:	e880 000c 	stmia.w	r0, {r2, r3}
 800343a:	bd08      	pop	{r3, pc}
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
 800343c:	f001 fa22 	bl	8004884 <ulPortSetInterruptMask>
 8003440:	e7fe      	b.n	8003440 <vTaskSetTimeOutState+0x18>
 8003442:	bf00      	nop
 8003444:	200009e0 	.word	0x200009e0

08003448 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 8003448:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
BaseType_t xReturn;

	configASSERT( pxTimeOut );
 800344a:	b380      	cbz	r0, 80034ae <xTaskCheckForTimeOut+0x66>
 800344c:	460e      	mov	r6, r1
	configASSERT( pxTicksToWait );
 800344e:	b359      	cbz	r1, 80034a8 <xTaskCheckForTimeOut+0x60>
 8003450:	4604      	mov	r4, r0

	taskENTER_CRITICAL();
 8003452:	f001 fa2d 	bl	80048b0 <vPortEnterCritical>

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 8003456:	6832      	ldr	r2, [r6, #0]
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 8003458:	4816      	ldr	r0, [pc, #88]	; (80034b4 <xTaskCheckForTimeOut+0x6c>)

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 800345a:	1c53      	adds	r3, r2, #1
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 800345c:	f8d0 5090 	ldr.w	r5, [r0, #144]	; 0x90

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 8003460:	d01d      	beq.n	800349e <xTaskCheckForTimeOut+0x56>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8003462:	f8d0 30d8 	ldr.w	r3, [r0, #216]	; 0xd8
 8003466:	6821      	ldr	r1, [r4, #0]
 8003468:	4299      	cmp	r1, r3
 800346a:	6863      	ldr	r3, [r4, #4]
 800346c:	d001      	beq.n	8003472 <xTaskCheckForTimeOut+0x2a>
 800346e:	429d      	cmp	r5, r3
 8003470:	d210      	bcs.n	8003494 <xTaskCheckForTimeOut+0x4c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 8003472:	1ae9      	subs	r1, r5, r3
 8003474:	428a      	cmp	r2, r1
 8003476:	d90d      	bls.n	8003494 <xTaskCheckForTimeOut+0x4c>
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8003478:	f8d0 70d8 	ldr.w	r7, [r0, #216]	; 0xd8
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 800347c:	1b52      	subs	r2, r2, r5

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
	pxTimeOut->xTimeOnEntering = xTickCount;
 800347e:	f8d0 1090 	ldr.w	r1, [r0, #144]	; 0x90
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 8003482:	4413      	add	r3, r2
 8003484:	6033      	str	r3, [r6, #0]
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
 8003486:	2500      	movs	r5, #0
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8003488:	6027      	str	r7, [r4, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800348a:	6061      	str	r1, [r4, #4]
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
 800348c:	f001 fa2e 	bl	80048ec <vPortExitCritical>

	return xReturn;
}
 8003490:	4628      	mov	r0, r5
 8003492:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
 8003494:	2501      	movs	r5, #1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
 8003496:	f001 fa29 	bl	80048ec <vPortExitCritical>

	return xReturn;
}
 800349a:	4628      	mov	r0, r5
 800349c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
 800349e:	2500      	movs	r5, #0
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
 80034a0:	f001 fa24 	bl	80048ec <vPortExitCritical>

	return xReturn;
}
 80034a4:	4628      	mov	r0, r5
 80034a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );
 80034a8:	f001 f9ec 	bl	8004884 <ulPortSetInterruptMask>
 80034ac:	e7fe      	b.n	80034ac <xTaskCheckForTimeOut+0x64>

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
BaseType_t xReturn;

	configASSERT( pxTimeOut );
 80034ae:	f001 f9e9 	bl	8004884 <ulPortSetInterruptMask>
 80034b2:	e7fe      	b.n	80034b2 <xTaskCheckForTimeOut+0x6a>
 80034b4:	200009e0 	.word	0x200009e0

080034b8 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
 80034b8:	4b02      	ldr	r3, [pc, #8]	; (80034c4 <vTaskMissedYield+0xc>)
 80034ba:	2201      	movs	r2, #1
 80034bc:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 80034c0:	4770      	bx	lr
 80034c2:	bf00      	nop
 80034c4:	200009e0 	.word	0x200009e0

080034c8 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 80034c8:	4b06      	ldr	r3, [pc, #24]	; (80034e4 <xTaskGetSchedulerState+0x1c>)
 80034ca:	f8d3 20c8 	ldr.w	r2, [r3, #200]	; 0xc8
 80034ce:	b132      	cbz	r2, 80034de <xTaskGetSchedulerState+0x16>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80034d0:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 80034d4:	2b00      	cmp	r3, #0
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 80034d6:	bf0c      	ite	eq
 80034d8:	2002      	moveq	r0, #2
 80034da:	2000      	movne	r0, #0
 80034dc:	4770      	bx	lr
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 80034de:	2001      	movs	r0, #1
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
 80034e0:	4770      	bx	lr
 80034e2:	bf00      	nop
 80034e4:	200009e0 	.word	0x200009e0

080034e8 <vTaskPriorityInherit>:
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
 80034e8:	2800      	cmp	r0, #0
 80034ea:	d047      	beq.n	800357c <vTaskPriorityInherit+0x94>
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
 80034ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		if( pxMutexHolder != NULL )
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 80034ee:	4c24      	ldr	r4, [pc, #144]	; (8003580 <vTaskPriorityInherit+0x98>)
 80034f0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80034f2:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 80034f6:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80034f8:	4293      	cmp	r3, r2
 80034fa:	d214      	bcs.n	8003526 <vTaskPriorityInherit+0x3e>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80034fc:	6982      	ldr	r2, [r0, #24]
 80034fe:	2a00      	cmp	r2, #0
 8003500:	db05      	blt.n	800350e <vTaskPriorityInherit+0x26>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003502:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 8003506:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8003508:	f1c2 0205 	rsb	r2, r2, #5
 800350c:	6182      	str	r2, [r0, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 800350e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8003512:	6942      	ldr	r2, [r0, #20]
 8003514:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8003518:	429a      	cmp	r2, r3
 800351a:	4d19      	ldr	r5, [pc, #100]	; (8003580 <vTaskPriorityInherit+0x98>)
 800351c:	d004      	beq.n	8003528 <vTaskPriorityInherit+0x40>
					prvAddTaskToReadyList( pxTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 800351e:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
 8003522:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003524:	62c3      	str	r3, [r0, #44]	; 0x2c
 8003526:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 8003528:	1d07      	adds	r7, r0, #4
 800352a:	4606      	mov	r6, r0
 800352c:	4638      	mov	r0, r7
 800352e:	f000 fd13 	bl	8003f58 <uxListRemove>
 8003532:	b970      	cbnz	r0, 8003552 <vTaskPriorityInherit+0x6a>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8003534:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8003536:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 800353a:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 800353e:	b942      	cbnz	r2, 8003552 <vTaskPriorityInherit+0x6a>
 8003540:	f8d5 20d0 	ldr.w	r2, [r5, #208]	; 0xd0
 8003544:	2101      	movs	r1, #1
 8003546:	fa01 f303 	lsl.w	r3, r1, r3
 800354a:	ea22 0303 	bic.w	r3, r2, r3
 800354e:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8003552:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
					prvAddTaskToReadyList( pxTCB );
 8003556:	2501      	movs	r5, #1
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8003558:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 800355a:	f8d4 20d0 	ldr.w	r2, [r4, #208]	; 0xd0
 800355e:	409d      	lsls	r5, r3
 8003560:	eb03 0083 	add.w	r0, r3, r3, lsl #2
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8003564:	62f3      	str	r3, [r6, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 8003566:	ea45 0302 	orr.w	r3, r5, r2
 800356a:	4639      	mov	r1, r7
 800356c:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8003570:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8003574:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
					prvAddTaskToReadyList( pxTCB );
 8003578:	f000 bcc6 	b.w	8003f08 <vListInsertEnd>
 800357c:	4770      	bx	lr
 800357e:	bf00      	nop
 8003580:	200009e0 	.word	0x200009e0

08003584 <xTaskPriorityDisinherit>:
	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
 8003584:	b148      	cbz	r0, 800359a <xTaskPriorityDisinherit+0x16>
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 8003586:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
 8003588:	4d21      	ldr	r5, [pc, #132]	; (8003610 <xTaskPriorityDisinherit+0x8c>)
 800358a:	4604      	mov	r4, r0
 800358c:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
 8003590:	4298      	cmp	r0, r3
 8003592:	d004      	beq.n	800359e <xTaskPriorityDisinherit+0x1a>
 8003594:	f001 f976 	bl	8004884 <ulPortSetInterruptMask>
 8003598:	e7fe      	b.n	8003598 <xTaskPriorityDisinherit+0x14>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
 800359a:	2000      	movs	r0, #0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
 800359c:	4770      	bx	lr
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
 800359e:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80035a0:	b143      	cbz	r3, 80035b4 <xTaskPriorityDisinherit+0x30>
			( pxTCB->uxMutexesHeld )--;

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 80035a2:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 80035a4:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
 80035a6:	3b01      	subs	r3, #1

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 80035a8:	4291      	cmp	r1, r2
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
 80035aa:	6503      	str	r3, [r0, #80]	; 0x50

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 80035ac:	d000      	beq.n	80035b0 <xTaskPriorityDisinherit+0x2c>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 80035ae:	b123      	cbz	r3, 80035ba <xTaskPriorityDisinherit+0x36>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
 80035b0:	2000      	movs	r0, #0
 80035b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
 80035b4:	f001 f966 	bl	8004884 <ulPortSetInterruptMask>
 80035b8:	e7fe      	b.n	80035b8 <xTaskPriorityDisinherit+0x34>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 80035ba:	1d07      	adds	r7, r0, #4
 80035bc:	4638      	mov	r0, r7
 80035be:	f000 fccb 	bl	8003f58 <uxListRemove>
 80035c2:	b968      	cbnz	r0, 80035e0 <xTaskPriorityDisinherit+0x5c>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 80035c4:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80035c6:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 80035ca:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 80035ce:	b93b      	cbnz	r3, 80035e0 <xTaskPriorityDisinherit+0x5c>
 80035d0:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
 80035d4:	2201      	movs	r2, #1
 80035d6:	4082      	lsls	r2, r0
 80035d8:	ea23 0302 	bic.w	r3, r3, r2
 80035dc:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 80035e0:	6ce0      	ldr	r0, [r4, #76]	; 0x4c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
					prvAddTaskToReadyList( pxTCB );
 80035e2:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
 80035e6:	2601      	movs	r6, #1
 80035e8:	fa06 fe00 	lsl.w	lr, r6, r0
					pxTCB->uxPriority = pxTCB->uxBasePriority;

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80035ec:	f1c0 0205 	rsb	r2, r0, #5
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 80035f0:	62e0      	str	r0, [r4, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
					prvAddTaskToReadyList( pxTCB );
 80035f2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80035f6:	ea4e 0303 	orr.w	r3, lr, r3
 80035fa:	eb05 0080 	add.w	r0, r5, r0, lsl #2
 80035fe:	4639      	mov	r1, r7
					pxTCB->uxPriority = pxTCB->uxBasePriority;

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003600:	61a2      	str	r2, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 8003602:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0
 8003606:	f000 fc7f 	bl	8003f08 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
 800360a:	4630      	mov	r0, r6
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
 800360c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800360e:	bf00      	nop
 8003610:	200009e0 	.word	0x200009e0

08003614 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
 8003614:	4b05      	ldr	r3, [pc, #20]	; (800362c <pvTaskIncrementMutexHeldCount+0x18>)
 8003616:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 800361a:	b122      	cbz	r2, 8003626 <pvTaskIncrementMutexHeldCount+0x12>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
 800361c:	f8d3 108c 	ldr.w	r1, [r3, #140]	; 0x8c
 8003620:	6d0a      	ldr	r2, [r1, #80]	; 0x50
 8003622:	3201      	adds	r2, #1
 8003624:	650a      	str	r2, [r1, #80]	; 0x50
		}

		return pxCurrentTCB;
 8003626:	f8d3 008c 	ldr.w	r0, [r3, #140]	; 0x8c
	}
 800362a:	4770      	bx	lr
 800362c:	200009e0 	.word	0x200009e0

08003630 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8003630:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position;
  uint32_t ioposition = 0x00;
  uint32_t iocurrent = 0x00;
  uint32_t temp = 0x00;
  uint32_t config = 0x00;
 8003634:	f04f 0800 	mov.w	r8, #0
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8003638:	b085      	sub	sp, #20
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for (position = 0; position < GPIO_NUMBER; position++)
 800363a:	4645      	mov	r5, r8
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
 800363c:	4f6a      	ldr	r7, [pc, #424]	; (80037e8 <HAL_GPIO_Init+0x1b8>)
        temp = AFIO->EXTICR[position >> 2];
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 800363e:	f8df e1c0 	ldr.w	lr, [pc, #448]	; 8003800 <HAL_GPIO_Init+0x1d0>
        {
          SET_BIT(EXTI->FTSR, iocurrent); 
        } 
        else
        {
          CLEAR_BIT(EXTI->FTSR, iocurrent); 
 8003642:	4e6a      	ldr	r6, [pc, #424]	; (80037ec <HAL_GPIO_Init+0x1bc>)
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
        temp = AFIO->EXTICR[position >> 2];
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8003644:	f8df c1bc 	ldr.w	ip, [pc, #444]	; 8003804 <HAL_GPIO_Init+0x1d4>
 8003648:	e002      	b.n	8003650 <HAL_GPIO_Init+0x20>
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for (position = 0; position < GPIO_NUMBER; position++)
 800364a:	3501      	adds	r5, #1
 800364c:	2d10      	cmp	r5, #16
 800364e:	d07c      	beq.n	800374a <HAL_GPIO_Init+0x11a>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 8003650:	2301      	movs	r3, #1
    
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if (iocurrent == ioposition)
 8003652:	680a      	ldr	r2, [r1, #0]

  /* Configure the port pins */
  for (position = 0; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 8003654:	40ab      	lsls	r3, r5
    
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if (iocurrent == ioposition)
 8003656:	ea33 0202 	bics.w	r2, r3, r2
 800365a:	d1f6      	bne.n	800364a <HAL_GPIO_Init+0x1a>
    {
      /* Check the Alternate function parameters */
      assert_param(IS_GPIO_AF_INSTANCE(GPIOx));

      /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
      switch (GPIO_Init->Mode)
 800365c:	684a      	ldr	r2, [r1, #4]
 800365e:	2a12      	cmp	r2, #18
 8003660:	f000 8099 	beq.w	8003796 <HAL_GPIO_Init+0x166>
 8003664:	f200 8082 	bhi.w	800376c <HAL_GPIO_Init+0x13c>
 8003668:	2a02      	cmp	r2, #2
 800366a:	f000 809b 	beq.w	80037a4 <HAL_GPIO_Init+0x174>
 800366e:	d977      	bls.n	8003760 <HAL_GPIO_Init+0x130>
 8003670:	2a03      	cmp	r2, #3
 8003672:	f000 8094 	beq.w	800379e <HAL_GPIO_Init+0x16e>
 8003676:	2a11      	cmp	r2, #17
 8003678:	d102      	bne.n	8003680 <HAL_GPIO_Init+0x50>
          
        /* If we are configuring the pin in OUTPUT open-drain mode */
        case GPIO_MODE_OUTPUT_OD:
          /* Check the GPIO speed parameter */
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
 800367a:	68ca      	ldr	r2, [r1, #12]
 800367c:	f102 0804 	add.w	r8, r2, #4
          break;
      }
      
      /* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register*/
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 8003680:	2bff      	cmp	r3, #255	; 0xff
 8003682:	d865      	bhi.n	8003750 <HAL_GPIO_Init+0x120>
 8003684:	4681      	mov	r9, r0
 8003686:	6802      	ldr	r2, [r0, #0]
 8003688:	4692      	mov	sl, r2
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2) : ((position - 8) << 2);
 800368a:	00aa      	lsls	r2, r5, #2
      
      /* Apply the new configuration of the pin to the register */
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset ), (config << registeroffset));
 800368c:	240f      	movs	r4, #15
 800368e:	fa04 fb02 	lsl.w	fp, r4, r2
 8003692:	ea2a 0a0b 	bic.w	sl, sl, fp
 8003696:	fa08 f202 	lsl.w	r2, r8, r2
 800369a:	ea4a 0202 	orr.w	r2, sl, r2
 800369e:	f8c9 2000 	str.w	r2, [r9]
      
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 80036a2:	f8d1 a004 	ldr.w	sl, [r1, #4]
 80036a6:	f01a 5f80 	tst.w	sl, #268435456	; 0x10000000
 80036aa:	d0ce      	beq.n	800364a <HAL_GPIO_Init+0x1a>
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
 80036ac:	69ba      	ldr	r2, [r7, #24]
 80036ae:	f025 0903 	bic.w	r9, r5, #3
 80036b2:	f042 0201 	orr.w	r2, r2, #1
 80036b6:	61ba      	str	r2, [r7, #24]
 80036b8:	69ba      	ldr	r2, [r7, #24]
 80036ba:	f109 4980 	add.w	r9, r9, #1073741824	; 0x40000000
 80036be:	f002 0201 	and.w	r2, r2, #1
 80036c2:	9203      	str	r2, [sp, #12]
 80036c4:	f509 3980 	add.w	r9, r9, #65536	; 0x10000
        temp = AFIO->EXTICR[position >> 2];
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
 80036c8:	f005 0203 	and.w	r2, r5, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
 80036cc:	f8dd b00c 	ldr.w	fp, [sp, #12]
        temp = AFIO->EXTICR[position >> 2];
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
 80036d0:	0092      	lsls	r2, r2, #2
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
        temp = AFIO->EXTICR[position >> 2];
 80036d2:	f8d9 b008 	ldr.w	fp, [r9, #8]
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
 80036d6:	4094      	lsls	r4, r2
 80036d8:	ea2b 0404 	bic.w	r4, fp, r4
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 80036dc:	4570      	cmp	r0, lr
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
        temp = AFIO->EXTICR[position >> 2];
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
 80036de:	9401      	str	r4, [sp, #4]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 80036e0:	d075      	beq.n	80037ce <HAL_GPIO_Init+0x19e>
 80036e2:	4560      	cmp	r0, ip
 80036e4:	d075      	beq.n	80037d2 <HAL_GPIO_Init+0x1a2>
 80036e6:	4c42      	ldr	r4, [pc, #264]	; (80037f0 <HAL_GPIO_Init+0x1c0>)
 80036e8:	42a0      	cmp	r0, r4
 80036ea:	d077      	beq.n	80037dc <HAL_GPIO_Init+0x1ac>
 80036ec:	4c41      	ldr	r4, [pc, #260]	; (80037f4 <HAL_GPIO_Init+0x1c4>)
 80036ee:	42a0      	cmp	r0, r4
 80036f0:	bf0c      	ite	eq
 80036f2:	f04f 0b03 	moveq.w	fp, #3
 80036f6:	f04f 0b04 	movne.w	fp, #4
 80036fa:	fa0b f202 	lsl.w	r2, fp, r2
 80036fe:	9c01      	ldr	r4, [sp, #4]
        AFIO->EXTICR[position >> 2] = temp;
        

        /* Configure the interrupt mask */
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8003700:	f41a 3f80 	tst.w	sl, #65536	; 0x10000
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
        temp = AFIO->EXTICR[position >> 2];
        CLEAR_BIT(temp, ((uint32_t)0x0F) << (4 * (position & 0x03)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8003704:	ea44 0402 	orr.w	r4, r4, r2
        AFIO->EXTICR[position >> 2] = temp;
 8003708:	f8c9 4008 	str.w	r4, [r9, #8]
        

        /* Configure the interrupt mask */
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          SET_BIT(EXTI->IMR, iocurrent); 
 800370c:	6832      	ldr	r2, [r6, #0]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for (position = 0; position < GPIO_NUMBER; position++)
 800370e:	f105 0501 	add.w	r5, r5, #1
        

        /* Configure the interrupt mask */
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          SET_BIT(EXTI->IMR, iocurrent); 
 8003712:	bf14      	ite	ne
 8003714:	431a      	orrne	r2, r3
        } 
        else
        {
          CLEAR_BIT(EXTI->IMR, iocurrent); 
 8003716:	439a      	biceq	r2, r3
 8003718:	6032      	str	r2, [r6, #0]
        } 
        
        /* Configure the event mask */
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          SET_BIT(EXTI->EMR, iocurrent); 
 800371a:	6872      	ldr	r2, [r6, #4]
        {
          CLEAR_BIT(EXTI->IMR, iocurrent); 
        } 
        
        /* Configure the event mask */
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800371c:	f41a 3f00 	tst.w	sl, #131072	; 0x20000
        {
          SET_BIT(EXTI->EMR, iocurrent); 
 8003720:	bf14      	ite	ne
 8003722:	431a      	orrne	r2, r3
        } 
        else
        {
          CLEAR_BIT(EXTI->EMR, iocurrent); 
 8003724:	439a      	biceq	r2, r3
 8003726:	6072      	str	r2, [r6, #4]
        }
        
        /* Enable or disable the rising trigger */
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          SET_BIT(EXTI->RTSR, iocurrent); 
 8003728:	68b2      	ldr	r2, [r6, #8]
        {
          CLEAR_BIT(EXTI->EMR, iocurrent); 
        }
        
        /* Enable or disable the rising trigger */
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800372a:	f41a 1f80 	tst.w	sl, #1048576	; 0x100000
        {
          SET_BIT(EXTI->RTSR, iocurrent); 
 800372e:	bf14      	ite	ne
 8003730:	431a      	orrne	r2, r3
        } 
        else
        {
          CLEAR_BIT(EXTI->RTSR, iocurrent); 
 8003732:	439a      	biceq	r2, r3
 8003734:	60b2      	str	r2, [r6, #8]
        }
        
        /* Enable or disable the falling trigger */
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          SET_BIT(EXTI->FTSR, iocurrent); 
 8003736:	68f2      	ldr	r2, [r6, #12]
        {
          CLEAR_BIT(EXTI->RTSR, iocurrent); 
        }
        
        /* Enable or disable the falling trigger */
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8003738:	f41a 1f00 	tst.w	sl, #2097152	; 0x200000
        {
          SET_BIT(EXTI->FTSR, iocurrent); 
 800373c:	bf14      	ite	ne
 800373e:	4313      	orrne	r3, r2
        } 
        else
        {
          CLEAR_BIT(EXTI->FTSR, iocurrent); 
 8003740:	ea22 0303 	biceq.w	r3, r2, r3
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for (position = 0; position < GPIO_NUMBER; position++)
 8003744:	2d10      	cmp	r5, #16
        {
          SET_BIT(EXTI->FTSR, iocurrent); 
        } 
        else
        {
          CLEAR_BIT(EXTI->FTSR, iocurrent); 
 8003746:	60f3      	str	r3, [r6, #12]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for (position = 0; position < GPIO_NUMBER; position++)
 8003748:	d182      	bne.n	8003650 <HAL_GPIO_Init+0x20>
          CLEAR_BIT(EXTI->FTSR, iocurrent); 
        }
      }
    }
  }
}
 800374a:	b005      	add	sp, #20
 800374c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          break;
      }
      
      /* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register*/
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 8003750:	6844      	ldr	r4, [r0, #4]
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2) : ((position - 8) << 2);
 8003752:	f1a5 0208 	sub.w	r2, r5, #8
          break;
      }
      
      /* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register*/
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 8003756:	46a2      	mov	sl, r4
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2) : ((position - 8) << 2);
 8003758:	0092      	lsls	r2, r2, #2
          break;
      }
      
      /* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register*/
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 800375a:	f100 0904 	add.w	r9, r0, #4
 800375e:	e795      	b.n	800368c <HAL_GPIO_Init+0x5c>
    {
      /* Check the Alternate function parameters */
      assert_param(IS_GPIO_AF_INSTANCE(GPIOx));

      /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
      switch (GPIO_Init->Mode)
 8003760:	b1a2      	cbz	r2, 800378c <HAL_GPIO_Init+0x15c>
 8003762:	2a01      	cmp	r2, #1
 8003764:	d18c      	bne.n	8003680 <HAL_GPIO_Init+0x50>
      {
        /* If we are configuring the pin in OUTPUT push-pull mode */
        case GPIO_MODE_OUTPUT_PP:
          /* Check the GPIO speed parameter */
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
 8003766:	f8d1 800c 	ldr.w	r8, [r1, #12]
          break;
 800376a:	e789      	b.n	8003680 <HAL_GPIO_Init+0x50>
    {
      /* Check the Alternate function parameters */
      assert_param(IS_GPIO_AF_INSTANCE(GPIOx));

      /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
      switch (GPIO_Init->Mode)
 800376c:	4c22      	ldr	r4, [pc, #136]	; (80037f8 <HAL_GPIO_Init+0x1c8>)
 800376e:	42a2      	cmp	r2, r4
 8003770:	d00c      	beq.n	800378c <HAL_GPIO_Init+0x15c>
 8003772:	d91b      	bls.n	80037ac <HAL_GPIO_Init+0x17c>
 8003774:	4c21      	ldr	r4, [pc, #132]	; (80037fc <HAL_GPIO_Init+0x1cc>)
 8003776:	42a2      	cmp	r2, r4
 8003778:	d008      	beq.n	800378c <HAL_GPIO_Init+0x15c>
 800377a:	f504 3480 	add.w	r4, r4, #65536	; 0x10000
 800377e:	42a2      	cmp	r2, r4
 8003780:	d004      	beq.n	800378c <HAL_GPIO_Init+0x15c>
 8003782:	f5a4 1480 	sub.w	r4, r4, #1048576	; 0x100000
 8003786:	42a2      	cmp	r2, r4
 8003788:	f47f af7a 	bne.w	8003680 <HAL_GPIO_Init+0x50>
        case GPIO_MODE_EVT_RISING:
        case GPIO_MODE_EVT_FALLING:
        case GPIO_MODE_EVT_RISING_FALLING:
          /* Check the GPIO pull parameter */
          assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
          if(GPIO_Init->Pull == GPIO_NOPULL)
 800378c:	688a      	ldr	r2, [r1, #8]
 800378e:	b9ba      	cbnz	r2, 80037c0 <HAL_GPIO_Init+0x190>
          {  
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
 8003790:	f04f 0804 	mov.w	r8, #4
 8003794:	e774      	b.n	8003680 <HAL_GPIO_Init+0x50>
          
        /* If we are configuring the pin in ALTERNATE FUNCTION open-drain mode */
        case GPIO_MODE_AF_OD:
          /* Check the GPIO speed parameter */
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
 8003796:	68ca      	ldr	r2, [r1, #12]
 8003798:	f102 080c 	add.w	r8, r2, #12
          break;
 800379c:	e770      	b.n	8003680 <HAL_GPIO_Init+0x50>
          }
          break; 
          
        /* If we are configuring the pin in INPUT analog mode */
        case GPIO_MODE_ANALOG:
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
 800379e:	f04f 0800 	mov.w	r8, #0
 80037a2:	e76d      	b.n	8003680 <HAL_GPIO_Init+0x50>
          
        /* If we are configuring the pin in ALTERNATE FUNCTION push-pull mode */
        case GPIO_MODE_AF_PP:
          /* Check the GPIO speed parameter */
          assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
 80037a4:	68ca      	ldr	r2, [r1, #12]
 80037a6:	f102 0808 	add.w	r8, r2, #8
          break;
 80037aa:	e769      	b.n	8003680 <HAL_GPIO_Init+0x50>
    {
      /* Check the Alternate function parameters */
      assert_param(IS_GPIO_AF_INSTANCE(GPIOx));

      /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
      switch (GPIO_Init->Mode)
 80037ac:	f5a4 1480 	sub.w	r4, r4, #1048576	; 0x100000
 80037b0:	42a2      	cmp	r2, r4
 80037b2:	d0eb      	beq.n	800378c <HAL_GPIO_Init+0x15c>
 80037b4:	f504 3480 	add.w	r4, r4, #65536	; 0x10000
 80037b8:	42a2      	cmp	r2, r4
 80037ba:	f47f af61 	bne.w	8003680 <HAL_GPIO_Init+0x50>
 80037be:	e7e5      	b.n	800378c <HAL_GPIO_Init+0x15c>
          assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
          if(GPIO_Init->Pull == GPIO_NOPULL)
          {  
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
          }
          else if(GPIO_Init->Pull == GPIO_PULLUP)
 80037c0:	2a01      	cmp	r2, #1
          {
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
            
            /* Set the corresponding ODR bit */
            GPIOx->BSRR = ioposition;
 80037c2:	bf0c      	ite	eq
 80037c4:	6103      	streq	r3, [r0, #16]
          else /* GPIO_PULLDOWN */
          {
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
            
            /* Reset the corresponding ODR bit */
            GPIOx->BRR = ioposition;
 80037c6:	6143      	strne	r3, [r0, #20]
            /* Set the corresponding ODR bit */
            GPIOx->BSRR = ioposition;
          }
          else /* GPIO_PULLDOWN */
          {
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 80037c8:	f04f 0808 	mov.w	r8, #8
 80037cc:	e758      	b.n	8003680 <HAL_GPIO_Init+0x50>
 80037ce:	2200      	movs	r2, #0
 80037d0:	e795      	b.n	80036fe <HAL_GPIO_Init+0xce>
 80037d2:	f04f 0b01 	mov.w	fp, #1
 80037d6:	fa0b f202 	lsl.w	r2, fp, r2
 80037da:	e790      	b.n	80036fe <HAL_GPIO_Init+0xce>
 80037dc:	f04f 0b02 	mov.w	fp, #2
 80037e0:	fa0b f202 	lsl.w	r2, fp, r2
 80037e4:	e78b      	b.n	80036fe <HAL_GPIO_Init+0xce>
 80037e6:	bf00      	nop
 80037e8:	40021000 	.word	0x40021000
 80037ec:	40010400 	.word	0x40010400
 80037f0:	40011000 	.word	0x40011000
 80037f4:	40011400 	.word	0x40011400
 80037f8:	10210000 	.word	0x10210000
 80037fc:	10310000 	.word	0x10310000
 8003800:	40010800 	.word	0x40010800
 8003804:	40010c00 	.word	0x40010c00

08003808 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8003808:	b902      	cbnz	r2, 800380c <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 800380a:	0409      	lsls	r1, r1, #16
 800380c:	6101      	str	r1, [r0, #16]
 800380e:	4770      	bx	lr

08003810 <HAL_DMA_Init>:
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{ 
  uint32_t tmp = 0;
  
  /* Check the DMA handle allocation */
  if(hdma == NULL)
 8003810:	b318      	cbz	r0, 800385a <HAL_DMA_Init+0x4a>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
  
  if(hdma->State == HAL_DMA_STATE_RESET)
 8003812:	f890 2021 	ldrb.w	r2, [r0, #33]	; 0x21
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{ 
 8003816:	b430      	push	{r4, r5}
 8003818:	4603      	mov	r3, r0
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
  
  if(hdma->State == HAL_DMA_STATE_RESET)
 800381a:	b90a      	cbnz	r2, 8003820 <HAL_DMA_Init+0x10>
  {  
    /* Allocate lock resource and initialize it */
    hdma->Lock = HAL_UNLOCKED;
 800381c:	f880 2020 	strb.w	r2, [r0, #32]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8003820:	1d18      	adds	r0, r3, #4
 8003822:	c815      	ldmia	r0, {r0, r2, r4}
 8003824:	6919      	ldr	r1, [r3, #16]
 8003826:	4302      	orrs	r2, r0
  
  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 8003828:	681d      	ldr	r5, [r3, #0]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 800382a:	4314      	orrs	r4, r2
 800382c:	695a      	ldr	r2, [r3, #20]
 800382e:	ea44 0001 	orr.w	r0, r4, r1
  
  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 8003832:	6829      	ldr	r1, [r5, #0]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8003834:	699c      	ldr	r4, [r3, #24]
 8003836:	4302      	orrs	r2, r0
 8003838:	69d8      	ldr	r0, [r3, #28]
 800383a:	4314      	orrs	r4, r2

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
  
  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 800383c:	f421 527f 	bic.w	r2, r1, #16320	; 0x3fc0
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8003840:	4320      	orrs	r0, r4

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
  
  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8003842:	f022 0230 	bic.w	r2, r2, #48	; 0x30
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8003846:	4302      	orrs	r2, r0

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;  
  
  /* Initialise the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8003848:	2100      	movs	r1, #0

  /* Initialize the DMA state*/
  hdma->State = HAL_DMA_STATE_READY;
 800384a:	2401      	movs	r4, #1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
          hdma->Init.Mode                | hdma->Init.Priority;

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;  
 800384c:	602a      	str	r2, [r5, #0]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;

  /* Initialize the DMA state*/
  hdma->State = HAL_DMA_STATE_READY;
  
  return HAL_OK;
 800384e:	4608      	mov	r0, r1
  
  /* Initialise the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;

  /* Initialize the DMA state*/
  hdma->State = HAL_DMA_STATE_READY;
 8003850:	f883 4021 	strb.w	r4, [r3, #33]	; 0x21

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;  
  
  /* Initialise the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8003854:	6359      	str	r1, [r3, #52]	; 0x34

  /* Initialize the DMA state*/
  hdma->State = HAL_DMA_STATE_READY;
  
  return HAL_OK;
}
 8003856:	bc30      	pop	{r4, r5}
 8003858:	4770      	bx	lr
  uint32_t tmp = 0;
  
  /* Check the DMA handle allocation */
  if(hdma == NULL)
  {
    return HAL_ERROR;
 800385a:	2001      	movs	r0, #1
 800385c:	4770      	bx	lr
 800385e:	bf00      	nop

08003860 <HAL_DMA_IRQHandler>:
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8003860:	6803      	ldr	r3, [r0, #0]
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 8003862:	b570      	push	{r4, r5, r6, lr}
 8003864:	4604      	mov	r4, r0
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8003866:	48ad      	ldr	r0, [pc, #692]	; (8003b1c <HAL_DMA_IRQHandler+0x2bc>)
 8003868:	49ad      	ldr	r1, [pc, #692]	; (8003b20 <HAL_DMA_IRQHandler+0x2c0>)
 800386a:	4283      	cmp	r3, r0
 800386c:	461a      	mov	r2, r3
 800386e:	680d      	ldr	r5, [r1, #0]
 8003870:	d038      	beq.n	80038e4 <HAL_DMA_IRQHandler+0x84>
 8003872:	3014      	adds	r0, #20
 8003874:	4283      	cmp	r3, r0
 8003876:	f000 80d6 	beq.w	8003a26 <HAL_DMA_IRQHandler+0x1c6>
 800387a:	3014      	adds	r0, #20
 800387c:	4283      	cmp	r3, r0
 800387e:	f000 80df 	beq.w	8003a40 <HAL_DMA_IRQHandler+0x1e0>
 8003882:	3014      	adds	r0, #20
 8003884:	4283      	cmp	r3, r0
 8003886:	f000 8103 	beq.w	8003a90 <HAL_DMA_IRQHandler+0x230>
 800388a:	3014      	adds	r0, #20
 800388c:	4283      	cmp	r3, r0
 800388e:	f000 80f2 	beq.w	8003a76 <HAL_DMA_IRQHandler+0x216>
 8003892:	3014      	adds	r0, #20
 8003894:	4283      	cmp	r3, r0
 8003896:	f000 8120 	beq.w	8003ada <HAL_DMA_IRQHandler+0x27a>
 800389a:	012e      	lsls	r6, r5, #4
 800389c:	f140 81a3 	bpl.w	8003be6 <HAL_DMA_IRQHandler+0x386>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 80038a0:	6819      	ldr	r1, [r3, #0]
 80038a2:	070e      	lsls	r6, r1, #28
 80038a4:	d56b      	bpl.n	800397e <HAL_DMA_IRQHandler+0x11e>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
 80038a6:	6819      	ldr	r1, [r3, #0]
      
      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80038a8:	489c      	ldr	r0, [pc, #624]	; (8003b1c <HAL_DMA_IRQHandler+0x2bc>)
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
 80038aa:	f021 0108 	bic.w	r1, r1, #8
      
      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80038ae:	4283      	cmp	r3, r0
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
 80038b0:	6019      	str	r1, [r3, #0]
      
      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 80038b2:	d051      	beq.n	8003958 <HAL_DMA_IRQHandler+0xf8>
 80038b4:	499b      	ldr	r1, [pc, #620]	; (8003b24 <HAL_DMA_IRQHandler+0x2c4>)
 80038b6:	428b      	cmp	r3, r1
 80038b8:	f000 811e 	beq.w	8003af8 <HAL_DMA_IRQHandler+0x298>
 80038bc:	3114      	adds	r1, #20
 80038be:	428b      	cmp	r3, r1
 80038c0:	f000 814e 	beq.w	8003b60 <HAL_DMA_IRQHandler+0x300>
 80038c4:	3114      	adds	r1, #20
 80038c6:	428b      	cmp	r3, r1
 80038c8:	f000 815e 	beq.w	8003b88 <HAL_DMA_IRQHandler+0x328>
 80038cc:	3114      	adds	r1, #20
 80038ce:	428b      	cmp	r3, r1
 80038d0:	f000 8140 	beq.w	8003b54 <HAL_DMA_IRQHandler+0x2f4>
 80038d4:	3114      	adds	r1, #20
 80038d6:	428b      	cmp	r3, r1
 80038d8:	bf0c      	ite	eq
 80038da:	f44f 0100 	moveq.w	r1, #8388608	; 0x800000
 80038de:	f04f 6100 	movne.w	r1, #134217728	; 0x8000000
 80038e2:	e03a      	b.n	800395a <HAL_DMA_IRQHandler+0xfa>
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 80038e4:	0728      	lsls	r0, r5, #28
 80038e6:	d4db      	bmi.n	80038a0 <HAL_DMA_IRQHandler+0x40>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 80038e8:	6809      	ldr	r1, [r1, #0]
 80038ea:	074d      	lsls	r5, r1, #29
 80038ec:	f140 80be 	bpl.w	8003a6c <HAL_DMA_IRQHandler+0x20c>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 80038f0:	681a      	ldr	r2, [r3, #0]
 80038f2:	0756      	lsls	r6, r2, #29
 80038f4:	f140 80ba 	bpl.w	8003a6c <HAL_DMA_IRQHandler+0x20c>
    { 
      /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
      if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
 80038f8:	681a      	ldr	r2, [r3, #0]
 80038fa:	0690      	lsls	r0, r2, #26
 80038fc:	f100 80d9 	bmi.w	8003ab2 <HAL_DMA_IRQHandler+0x252>
 8003900:	4a86      	ldr	r2, [pc, #536]	; (8003b1c <HAL_DMA_IRQHandler+0x2bc>)
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8003902:	6819      	ldr	r1, [r3, #0]
 8003904:	f021 0104 	bic.w	r1, r1, #4
 8003908:	6019      	str	r1, [r3, #0]
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 800390a:	4984      	ldr	r1, [pc, #528]	; (8003b1c <HAL_DMA_IRQHandler+0x2bc>)
 800390c:	428a      	cmp	r2, r1
 800390e:	f000 80d0 	beq.w	8003ab2 <HAL_DMA_IRQHandler+0x252>
 8003912:	4984      	ldr	r1, [pc, #528]	; (8003b24 <HAL_DMA_IRQHandler+0x2c4>)
 8003914:	428a      	cmp	r2, r1
 8003916:	f000 80f1 	beq.w	8003afc <HAL_DMA_IRQHandler+0x29c>
 800391a:	3114      	adds	r1, #20
 800391c:	428a      	cmp	r2, r1
 800391e:	f000 8122 	beq.w	8003b66 <HAL_DMA_IRQHandler+0x306>
 8003922:	3114      	adds	r1, #20
 8003924:	428a      	cmp	r2, r1
 8003926:	f000 8132 	beq.w	8003b8e <HAL_DMA_IRQHandler+0x32e>
 800392a:	3114      	adds	r1, #20
 800392c:	428a      	cmp	r2, r1
 800392e:	f000 8103 	beq.w	8003b38 <HAL_DMA_IRQHandler+0x2d8>
 8003932:	3114      	adds	r1, #20
 8003934:	428a      	cmp	r2, r1
 8003936:	f000 8138 	beq.w	8003baa <HAL_DMA_IRQHandler+0x34a>
 800393a:	4879      	ldr	r0, [pc, #484]	; (8003b20 <HAL_DMA_IRQHandler+0x2c0>)

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;

      if(hdma->XferHalfCpltCallback != NULL)
 800393c:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 800393e:	f04f 6680 	mov.w	r6, #67108864	; 0x4000000

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;
 8003942:	2511      	movs	r5, #17
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003944:	6046      	str	r6, [r0, #4]

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;
 8003946:	f884 5021 	strb.w	r5, [r4, #33]	; 0x21

      if(hdma->XferHalfCpltCallback != NULL)
 800394a:	2900      	cmp	r1, #0
 800394c:	f040 80b9 	bne.w	8003ac2 <HAL_DMA_IRQHandler+0x262>
      }
    }
  }
  
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8003950:	6800      	ldr	r0, [r0, #0]
 8003952:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
 8003956:	e031      	b.n	80039bc <HAL_DMA_IRQHandler+0x15c>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
      
      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8003958:	2108      	movs	r1, #8
 800395a:	4871      	ldr	r0, [pc, #452]	; (8003b20 <HAL_DMA_IRQHandler+0x2c0>)
      hdma->State = HAL_DMA_STATE_ERROR;
      
      /* Process Unlocked */
      __HAL_UNLOCK(hdma); 
      
      if (hdma->XferErrorCallback != NULL)
 800395c:	6b25      	ldr	r5, [r4, #48]	; 0x30
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
      
      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 800395e:	6041      	str	r1, [r0, #4]
      
      /* Update error code */
      SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_TE);
 8003960:	6b61      	ldr	r1, [r4, #52]	; 0x34
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 8003962:	2604      	movs	r6, #4
      
      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
      
      /* Update error code */
      SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_TE);
 8003964:	f041 0101 	orr.w	r1, r1, #1
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
      
      /* Process Unlocked */
      __HAL_UNLOCK(hdma); 
 8003968:	2000      	movs	r0, #0
      
      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
      
      /* Update error code */
      SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_TE);
 800396a:	6361      	str	r1, [r4, #52]	; 0x34
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_ERROR;
 800396c:	f884 6021 	strb.w	r6, [r4, #33]	; 0x21
      
      /* Process Unlocked */
      __HAL_UNLOCK(hdma); 
 8003970:	f884 0020 	strb.w	r0, [r4, #32]
      
      if (hdma->XferErrorCallback != NULL)
 8003974:	b11d      	cbz	r5, 800397e <HAL_DMA_IRQHandler+0x11e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 8003976:	4620      	mov	r0, r4
 8003978:	47a8      	blx	r5
 800397a:	6823      	ldr	r3, [r4, #0]
 800397c:	461a      	mov	r2, r3
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 800397e:	4867      	ldr	r0, [pc, #412]	; (8003b1c <HAL_DMA_IRQHandler+0x2bc>)
 8003980:	4967      	ldr	r1, [pc, #412]	; (8003b20 <HAL_DMA_IRQHandler+0x2c0>)
 8003982:	4283      	cmp	r3, r0
 8003984:	6809      	ldr	r1, [r1, #0]
 8003986:	d0b0      	beq.n	80038ea <HAL_DMA_IRQHandler+0x8a>
 8003988:	3014      	adds	r0, #20
 800398a:	4283      	cmp	r3, r0
 800398c:	d04f      	beq.n	8003a2e <HAL_DMA_IRQHandler+0x1ce>
 800398e:	3014      	adds	r0, #20
 8003990:	4283      	cmp	r3, r0
 8003992:	d059      	beq.n	8003a48 <HAL_DMA_IRQHandler+0x1e8>
 8003994:	3014      	adds	r0, #20
 8003996:	4283      	cmp	r3, r0
 8003998:	d07e      	beq.n	8003a98 <HAL_DMA_IRQHandler+0x238>
 800399a:	3014      	adds	r0, #20
 800399c:	4283      	cmp	r3, r0
 800399e:	d06e      	beq.n	8003a7e <HAL_DMA_IRQHandler+0x21e>
 80039a0:	3014      	adds	r0, #20
 80039a2:	4283      	cmp	r3, r0
 80039a4:	f000 809d 	beq.w	8003ae2 <HAL_DMA_IRQHandler+0x282>
 80039a8:	014e      	lsls	r6, r1, #5
 80039aa:	d503      	bpl.n	80039b4 <HAL_DMA_IRQHandler+0x154>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 80039ac:	6819      	ldr	r1, [r3, #0]
 80039ae:	074e      	lsls	r6, r1, #29
 80039b0:	f100 8109 	bmi.w	8003bc6 <HAL_DMA_IRQHandler+0x366>
      }
    }
  }
  
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 80039b4:	485a      	ldr	r0, [pc, #360]	; (8003b20 <HAL_DMA_IRQHandler+0x2c0>)
 80039b6:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
 80039ba:	6800      	ldr	r0, [r0, #0]
 80039bc:	4201      	tst	r1, r0
 80039be:	d03e      	beq.n	8003a3e <HAL_DMA_IRQHandler+0x1de>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 80039c0:	6819      	ldr	r1, [r3, #0]
 80039c2:	0788      	lsls	r0, r1, #30
 80039c4:	d53b      	bpl.n	8003a3e <HAL_DMA_IRQHandler+0x1de>
    {
      if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
 80039c6:	6819      	ldr	r1, [r3, #0]
 80039c8:	0689      	lsls	r1, r1, #26
 80039ca:	d403      	bmi.n	80039d4 <HAL_DMA_IRQHandler+0x174>
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
 80039cc:	6819      	ldr	r1, [r3, #0]
 80039ce:	f021 0102 	bic.w	r1, r1, #2
 80039d2:	6019      	str	r1, [r3, #0]
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 80039d4:	4b51      	ldr	r3, [pc, #324]	; (8003b1c <HAL_DMA_IRQHandler+0x2bc>)
 80039d6:	429a      	cmp	r2, r3
 80039d8:	d067      	beq.n	8003aaa <HAL_DMA_IRQHandler+0x24a>
 80039da:	3314      	adds	r3, #20
 80039dc:	429a      	cmp	r2, r3
 80039de:	d066      	beq.n	8003aae <HAL_DMA_IRQHandler+0x24e>
 80039e0:	3314      	adds	r3, #20
 80039e2:	429a      	cmp	r2, r3
 80039e4:	f000 8085 	beq.w	8003af2 <HAL_DMA_IRQHandler+0x292>
 80039e8:	3314      	adds	r3, #20
 80039ea:	429a      	cmp	r2, r3
 80039ec:	f000 80b5 	beq.w	8003b5a <HAL_DMA_IRQHandler+0x2fa>
 80039f0:	3314      	adds	r3, #20
 80039f2:	429a      	cmp	r2, r3
 80039f4:	f000 80c5 	beq.w	8003b82 <HAL_DMA_IRQHandler+0x322>
 80039f8:	3314      	adds	r3, #20
 80039fa:	429a      	cmp	r2, r3
 80039fc:	bf14      	ite	ne
 80039fe:	f04f 7200 	movne.w	r2, #33554432	; 0x2000000
 8003a02:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
 8003a06:	4946      	ldr	r1, [pc, #280]	; (8003b20 <HAL_DMA_IRQHandler+0x2c0>)
      hdma->State = HAL_DMA_STATE_READY;
    
      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
    
      if(hdma->XferCpltCallback != NULL)
 8003a08:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8003a0a:	604a      	str	r2, [r1, #4]
    
      /* Update error code */
      SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_NONE);
 8003a0c:	6b60      	ldr	r0, [r4, #52]	; 0x34

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 8003a0e:	2101      	movs	r1, #1
    
      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 8003a10:	2200      	movs	r2, #0
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
    
      /* Update error code */
      SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_NONE);
 8003a12:	6360      	str	r0, [r4, #52]	; 0x34

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 8003a14:	f884 1021 	strb.w	r1, [r4, #33]	; 0x21
    
      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 8003a18:	f884 2020 	strb.w	r2, [r4, #32]
    
      if(hdma->XferCpltCallback != NULL)
 8003a1c:	b17b      	cbz	r3, 8003a3e <HAL_DMA_IRQHandler+0x1de>
      {       
        /* Transfer complete callback */
        hdma->XferCpltCallback(hdma);
 8003a1e:	4620      	mov	r0, r4
      }
    }
  }
}
 8003a20:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      __HAL_UNLOCK(hdma);
    
      if(hdma->XferCpltCallback != NULL)
      {       
        /* Transfer complete callback */
        hdma->XferCpltCallback(hdma);
 8003a24:	4718      	bx	r3
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8003a26:	062d      	lsls	r5, r5, #24
 8003a28:	f53f af3a 	bmi.w	80038a0 <HAL_DMA_IRQHandler+0x40>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8003a2c:	6809      	ldr	r1, [r1, #0]
 8003a2e:	064e      	lsls	r6, r1, #25
 8003a30:	d413      	bmi.n	8003a5a <HAL_DMA_IRQHandler+0x1fa>
      }
    }
  }
  
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8003a32:	493b      	ldr	r1, [pc, #236]	; (8003b20 <HAL_DMA_IRQHandler+0x2c0>)
 8003a34:	4a3b      	ldr	r2, [pc, #236]	; (8003b24 <HAL_DMA_IRQHandler+0x2c4>)
 8003a36:	6808      	ldr	r0, [r1, #0]
 8003a38:	2120      	movs	r1, #32
 8003a3a:	4201      	tst	r1, r0
 8003a3c:	d1c0      	bne.n	80039c0 <HAL_DMA_IRQHandler+0x160>
 8003a3e:	bd70      	pop	{r4, r5, r6, pc}
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8003a40:	0528      	lsls	r0, r5, #20
 8003a42:	f53f af2d 	bmi.w	80038a0 <HAL_DMA_IRQHandler+0x40>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8003a46:	6809      	ldr	r1, [r1, #0]
 8003a48:	0549      	lsls	r1, r1, #21
 8003a4a:	f100 80eb 	bmi.w	8003c24 <HAL_DMA_IRQHandler+0x3c4>
      }
    }
  }
  
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8003a4e:	4934      	ldr	r1, [pc, #208]	; (8003b20 <HAL_DMA_IRQHandler+0x2c0>)
 8003a50:	4a35      	ldr	r2, [pc, #212]	; (8003b28 <HAL_DMA_IRQHandler+0x2c8>)
 8003a52:	6808      	ldr	r0, [r1, #0]
 8003a54:	f44f 7100 	mov.w	r1, #512	; 0x200
 8003a58:	e7b0      	b.n	80039bc <HAL_DMA_IRQHandler+0x15c>
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8003a5a:	681a      	ldr	r2, [r3, #0]
 8003a5c:	0752      	lsls	r2, r2, #29
 8003a5e:	d5e8      	bpl.n	8003a32 <HAL_DMA_IRQHandler+0x1d2>
 8003a60:	4a30      	ldr	r2, [pc, #192]	; (8003b24 <HAL_DMA_IRQHandler+0x2c4>)
    { 
      /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
      if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
 8003a62:	6819      	ldr	r1, [r3, #0]
 8003a64:	0689      	lsls	r1, r1, #26
 8003a66:	f53f af54 	bmi.w	8003912 <HAL_DMA_IRQHandler+0xb2>
 8003a6a:	e74a      	b.n	8003902 <HAL_DMA_IRQHandler+0xa2>
      }
    }
  }
  
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8003a6c:	492c      	ldr	r1, [pc, #176]	; (8003b20 <HAL_DMA_IRQHandler+0x2c0>)
 8003a6e:	4a2b      	ldr	r2, [pc, #172]	; (8003b1c <HAL_DMA_IRQHandler+0x2bc>)
 8003a70:	6808      	ldr	r0, [r1, #0]
 8003a72:	2102      	movs	r1, #2
 8003a74:	e7a2      	b.n	80039bc <HAL_DMA_IRQHandler+0x15c>
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8003a76:	032d      	lsls	r5, r5, #12
 8003a78:	f53f af12 	bmi.w	80038a0 <HAL_DMA_IRQHandler+0x40>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8003a7c:	6809      	ldr	r1, [r1, #0]
 8003a7e:	034d      	lsls	r5, r1, #13
 8003a80:	f100 80ab 	bmi.w	8003bda <HAL_DMA_IRQHandler+0x37a>
      }
    }
  }
  
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8003a84:	4926      	ldr	r1, [pc, #152]	; (8003b20 <HAL_DMA_IRQHandler+0x2c0>)
 8003a86:	4a29      	ldr	r2, [pc, #164]	; (8003b2c <HAL_DMA_IRQHandler+0x2cc>)
 8003a88:	6808      	ldr	r0, [r1, #0]
 8003a8a:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8003a8e:	e795      	b.n	80039bc <HAL_DMA_IRQHandler+0x15c>
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8003a90:	042e      	lsls	r6, r5, #16
 8003a92:	f53f af05 	bmi.w	80038a0 <HAL_DMA_IRQHandler+0x40>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8003a96:	6809      	ldr	r1, [r1, #0]
 8003a98:	044a      	lsls	r2, r1, #17
 8003a9a:	f100 80bd 	bmi.w	8003c18 <HAL_DMA_IRQHandler+0x3b8>
      }
    }
  }
  
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8003a9e:	4920      	ldr	r1, [pc, #128]	; (8003b20 <HAL_DMA_IRQHandler+0x2c0>)
 8003aa0:	4a23      	ldr	r2, [pc, #140]	; (8003b30 <HAL_DMA_IRQHandler+0x2d0>)
 8003aa2:	6808      	ldr	r0, [r1, #0]
 8003aa4:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8003aa8:	e788      	b.n	80039bc <HAL_DMA_IRQHandler+0x15c>
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8003aaa:	2202      	movs	r2, #2
 8003aac:	e7ab      	b.n	8003a06 <HAL_DMA_IRQHandler+0x1a6>
 8003aae:	2220      	movs	r2, #32
 8003ab0:	e7a9      	b.n	8003a06 <HAL_DMA_IRQHandler+0x1a6>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003ab2:	4a1b      	ldr	r2, [pc, #108]	; (8003b20 <HAL_DMA_IRQHandler+0x2c0>)

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;

      if(hdma->XferHalfCpltCallback != NULL)
 8003ab4:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003ab6:	2504      	movs	r5, #4

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;
 8003ab8:	2011      	movs	r0, #17
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003aba:	6055      	str	r5, [r2, #4]

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;
 8003abc:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21

      if(hdma->XferHalfCpltCallback != NULL)
 8003ac0:	b341      	cbz	r1, 8003b14 <HAL_DMA_IRQHandler+0x2b4>
      {
        /* Half transfer callback */
        hdma->XferHalfCpltCallback(hdma);
 8003ac2:	4620      	mov	r0, r4
 8003ac4:	4788      	blx	r1
 8003ac6:	6823      	ldr	r3, [r4, #0]
      }
    }
  }
  
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8003ac8:	4914      	ldr	r1, [pc, #80]	; (8003b1c <HAL_DMA_IRQHandler+0x2bc>)
 8003aca:	4815      	ldr	r0, [pc, #84]	; (8003b20 <HAL_DMA_IRQHandler+0x2c0>)
 8003acc:	428b      	cmp	r3, r1
 8003ace:	461a      	mov	r2, r3
 8003ad0:	6800      	ldr	r0, [r0, #0]
 8003ad2:	f040 808a 	bne.w	8003bea <HAL_DMA_IRQHandler+0x38a>
 8003ad6:	2102      	movs	r1, #2
 8003ad8:	e770      	b.n	80039bc <HAL_DMA_IRQHandler+0x15c>
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
 8003ada:	0228      	lsls	r0, r5, #8
 8003adc:	f53f aee0 	bmi.w	80038a0 <HAL_DMA_IRQHandler+0x40>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8003ae0:	6809      	ldr	r1, [r1, #0]
 8003ae2:	0248      	lsls	r0, r1, #9
 8003ae4:	d474      	bmi.n	8003bd0 <HAL_DMA_IRQHandler+0x370>
      }
    }
  }
  
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8003ae6:	490e      	ldr	r1, [pc, #56]	; (8003b20 <HAL_DMA_IRQHandler+0x2c0>)
 8003ae8:	4a12      	ldr	r2, [pc, #72]	; (8003b34 <HAL_DMA_IRQHandler+0x2d4>)
 8003aea:	6808      	ldr	r0, [r1, #0]
 8003aec:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8003af0:	e764      	b.n	80039bc <HAL_DMA_IRQHandler+0x15c>
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8003af2:	f44f 7200 	mov.w	r2, #512	; 0x200
 8003af6:	e786      	b.n	8003a06 <HAL_DMA_IRQHandler+0x1a6>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
      
      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8003af8:	2180      	movs	r1, #128	; 0x80
 8003afa:	e72e      	b.n	800395a <HAL_DMA_IRQHandler+0xfa>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003afc:	4808      	ldr	r0, [pc, #32]	; (8003b20 <HAL_DMA_IRQHandler+0x2c0>)

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;

      if(hdma->XferHalfCpltCallback != NULL)
 8003afe:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003b00:	2640      	movs	r6, #64	; 0x40

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;
 8003b02:	2511      	movs	r5, #17
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003b04:	6046      	str	r6, [r0, #4]

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;
 8003b06:	f884 5021 	strb.w	r5, [r4, #33]	; 0x21

      if(hdma->XferHalfCpltCallback != NULL)
 8003b0a:	2900      	cmp	r1, #0
 8003b0c:	d1d9      	bne.n	8003ac2 <HAL_DMA_IRQHandler+0x262>
      }
    }
  }
  
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8003b0e:	6800      	ldr	r0, [r0, #0]
 8003b10:	2120      	movs	r1, #32
 8003b12:	e753      	b.n	80039bc <HAL_DMA_IRQHandler+0x15c>
 8003b14:	6810      	ldr	r0, [r2, #0]
 8003b16:	4a01      	ldr	r2, [pc, #4]	; (8003b1c <HAL_DMA_IRQHandler+0x2bc>)
 8003b18:	e7dd      	b.n	8003ad6 <HAL_DMA_IRQHandler+0x276>
 8003b1a:	bf00      	nop
 8003b1c:	40020008 	.word	0x40020008
 8003b20:	40020000 	.word	0x40020000
 8003b24:	4002001c 	.word	0x4002001c
 8003b28:	40020030 	.word	0x40020030
 8003b2c:	40020058 	.word	0x40020058
 8003b30:	40020044 	.word	0x40020044
 8003b34:	4002006c 	.word	0x4002006c
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003b38:	483f      	ldr	r0, [pc, #252]	; (8003c38 <HAL_DMA_IRQHandler+0x3d8>)

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;

      if(hdma->XferHalfCpltCallback != NULL)
 8003b3a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003b3c:	f44f 2680 	mov.w	r6, #262144	; 0x40000

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;
 8003b40:	2511      	movs	r5, #17
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003b42:	6046      	str	r6, [r0, #4]

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;
 8003b44:	f884 5021 	strb.w	r5, [r4, #33]	; 0x21

      if(hdma->XferHalfCpltCallback != NULL)
 8003b48:	2900      	cmp	r1, #0
 8003b4a:	d1ba      	bne.n	8003ac2 <HAL_DMA_IRQHandler+0x262>
      }
    }
  }
  
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8003b4c:	6800      	ldr	r0, [r0, #0]
 8003b4e:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8003b52:	e733      	b.n	80039bc <HAL_DMA_IRQHandler+0x15c>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
      
      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8003b54:	f44f 2100 	mov.w	r1, #524288	; 0x80000
 8003b58:	e6ff      	b.n	800395a <HAL_DMA_IRQHandler+0xfa>
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8003b5a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8003b5e:	e752      	b.n	8003a06 <HAL_DMA_IRQHandler+0x1a6>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
      
      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8003b60:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8003b64:	e6f9      	b.n	800395a <HAL_DMA_IRQHandler+0xfa>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003b66:	4834      	ldr	r0, [pc, #208]	; (8003c38 <HAL_DMA_IRQHandler+0x3d8>)

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;

      if(hdma->XferHalfCpltCallback != NULL)
 8003b68:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003b6a:	f44f 6680 	mov.w	r6, #1024	; 0x400

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;
 8003b6e:	2511      	movs	r5, #17
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003b70:	6046      	str	r6, [r0, #4]

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;
 8003b72:	f884 5021 	strb.w	r5, [r4, #33]	; 0x21

      if(hdma->XferHalfCpltCallback != NULL)
 8003b76:	2900      	cmp	r1, #0
 8003b78:	d1a3      	bne.n	8003ac2 <HAL_DMA_IRQHandler+0x262>
      }
    }
  }
  
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8003b7a:	6800      	ldr	r0, [r0, #0]
 8003b7c:	f44f 7100 	mov.w	r1, #512	; 0x200
 8003b80:	e71c      	b.n	80039bc <HAL_DMA_IRQHandler+0x15c>
      {
        /* Disable the transfer complete interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
      }
      /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8003b82:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8003b86:	e73e      	b.n	8003a06 <HAL_DMA_IRQHandler+0x1a6>
    {
      /* Disable the transfer error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
      
      /* Clear the transfer error flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
 8003b88:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8003b8c:	e6e5      	b.n	800395a <HAL_DMA_IRQHandler+0xfa>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003b8e:	482a      	ldr	r0, [pc, #168]	; (8003c38 <HAL_DMA_IRQHandler+0x3d8>)

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;

      if(hdma->XferHalfCpltCallback != NULL)
 8003b90:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003b92:	f44f 4680 	mov.w	r6, #16384	; 0x4000

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;
 8003b96:	2511      	movs	r5, #17
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003b98:	6046      	str	r6, [r0, #4]

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;
 8003b9a:	f884 5021 	strb.w	r5, [r4, #33]	; 0x21

      if(hdma->XferHalfCpltCallback != NULL)
 8003b9e:	2900      	cmp	r1, #0
 8003ba0:	d18f      	bne.n	8003ac2 <HAL_DMA_IRQHandler+0x262>
      }
    }
  }
  
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8003ba2:	6800      	ldr	r0, [r0, #0]
 8003ba4:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8003ba8:	e708      	b.n	80039bc <HAL_DMA_IRQHandler+0x15c>
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003baa:	4823      	ldr	r0, [pc, #140]	; (8003c38 <HAL_DMA_IRQHandler+0x3d8>)

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;

      if(hdma->XferHalfCpltCallback != NULL)
 8003bac:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003bae:	f44f 0680 	mov.w	r6, #4194304	; 0x400000

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;
 8003bb2:	2511      	movs	r5, #17
      {
        /* Disable the half transfer interrupt */
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
      }
      /* Clear the half transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8003bb4:	6046      	str	r6, [r0, #4]

      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_READY_HALF;
 8003bb6:	f884 5021 	strb.w	r5, [r4, #33]	; 0x21

      if(hdma->XferHalfCpltCallback != NULL)
 8003bba:	2900      	cmp	r1, #0
 8003bbc:	d181      	bne.n	8003ac2 <HAL_DMA_IRQHandler+0x262>
      }
    }
  }
  
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8003bbe:	6800      	ldr	r0, [r0, #0]
 8003bc0:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8003bc4:	e6fa      	b.n	80039bc <HAL_DMA_IRQHandler+0x15c>
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
    { 
      /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
      if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
 8003bc6:	6819      	ldr	r1, [r3, #0]
 8003bc8:	068d      	lsls	r5, r1, #26
 8003bca:	f53f ae9e 	bmi.w	800390a <HAL_DMA_IRQHandler+0xaa>
 8003bce:	e698      	b.n	8003902 <HAL_DMA_IRQHandler+0xa2>
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8003bd0:	681a      	ldr	r2, [r3, #0]
 8003bd2:	0751      	lsls	r1, r2, #29
 8003bd4:	d587      	bpl.n	8003ae6 <HAL_DMA_IRQHandler+0x286>
 8003bd6:	4a19      	ldr	r2, [pc, #100]	; (8003c3c <HAL_DMA_IRQHandler+0x3dc>)
 8003bd8:	e743      	b.n	8003a62 <HAL_DMA_IRQHandler+0x202>
 8003bda:	681a      	ldr	r2, [r3, #0]
 8003bdc:	0755      	lsls	r5, r2, #29
 8003bde:	f57f af51 	bpl.w	8003a84 <HAL_DMA_IRQHandler+0x224>
 8003be2:	4a17      	ldr	r2, [pc, #92]	; (8003c40 <HAL_DMA_IRQHandler+0x3e0>)
 8003be4:	e73d      	b.n	8003a62 <HAL_DMA_IRQHandler+0x202>
      }
    }
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
 8003be6:	6809      	ldr	r1, [r1, #0]
 8003be8:	e6de      	b.n	80039a8 <HAL_DMA_IRQHandler+0x148>
      }
    }
  }
  
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8003bea:	3114      	adds	r1, #20
 8003bec:	428b      	cmp	r3, r1
 8003bee:	f43f af23 	beq.w	8003a38 <HAL_DMA_IRQHandler+0x1d8>
 8003bf2:	3114      	adds	r1, #20
 8003bf4:	428b      	cmp	r3, r1
 8003bf6:	f43f af2d 	beq.w	8003a54 <HAL_DMA_IRQHandler+0x1f4>
 8003bfa:	3114      	adds	r1, #20
 8003bfc:	428b      	cmp	r3, r1
 8003bfe:	f43f af51 	beq.w	8003aa4 <HAL_DMA_IRQHandler+0x244>
 8003c02:	3114      	adds	r1, #20
 8003c04:	428b      	cmp	r3, r1
 8003c06:	d013      	beq.n	8003c30 <HAL_DMA_IRQHandler+0x3d0>
 8003c08:	3114      	adds	r1, #20
 8003c0a:	428b      	cmp	r3, r1
 8003c0c:	bf14      	ite	ne
 8003c0e:	f04f 7100 	movne.w	r1, #33554432	; 0x2000000
 8003c12:	f44f 1100 	moveq.w	r1, #2097152	; 0x200000
 8003c16:	e6d1      	b.n	80039bc <HAL_DMA_IRQHandler+0x15c>
  }

  /* Half Transfer Complete Interrupt management ******************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8003c18:	681a      	ldr	r2, [r3, #0]
 8003c1a:	0755      	lsls	r5, r2, #29
 8003c1c:	f57f af3f 	bpl.w	8003a9e <HAL_DMA_IRQHandler+0x23e>
 8003c20:	4a08      	ldr	r2, [pc, #32]	; (8003c44 <HAL_DMA_IRQHandler+0x3e4>)
 8003c22:	e71e      	b.n	8003a62 <HAL_DMA_IRQHandler+0x202>
 8003c24:	681a      	ldr	r2, [r3, #0]
 8003c26:	0750      	lsls	r0, r2, #29
 8003c28:	f57f af11 	bpl.w	8003a4e <HAL_DMA_IRQHandler+0x1ee>
 8003c2c:	4a06      	ldr	r2, [pc, #24]	; (8003c48 <HAL_DMA_IRQHandler+0x3e8>)
 8003c2e:	e718      	b.n	8003a62 <HAL_DMA_IRQHandler+0x202>
      }
    }
  }
  
  /* Transfer Complete Interrupt management ***********************************/
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
 8003c30:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8003c34:	e6c2      	b.n	80039bc <HAL_DMA_IRQHandler+0x15c>
 8003c36:	bf00      	nop
 8003c38:	40020000 	.word	0x40020000
 8003c3c:	4002006c 	.word	0x4002006c
 8003c40:	40020058 	.word	0x40020058
 8003c44:	40020044 	.word	0x40020044
 8003c48:	40020030 	.word	0x40020030

08003c4c <USBD_FS_DeviceDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_DeviceDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
  *length = sizeof(USBD_FS_DeviceDesc);
 8003c4c:	2312      	movs	r3, #18
 8003c4e:	800b      	strh	r3, [r1, #0]
  return USBD_FS_DeviceDesc;
}
 8003c50:	4800      	ldr	r0, [pc, #0]	; (8003c54 <USBD_FS_DeviceDescriptor+0x8>)
 8003c52:	4770      	bx	lr
 8003c54:	2000043c 	.word	0x2000043c

08003c58 <USBD_FS_LangIDStrDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_LangIDStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
  *length =  sizeof(USBD_LangIDDesc);  
 8003c58:	2304      	movs	r3, #4
 8003c5a:	800b      	strh	r3, [r1, #0]
  return USBD_LangIDDesc;
}
 8003c5c:	4800      	ldr	r0, [pc, #0]	; (8003c60 <USBD_FS_LangIDStrDescriptor+0x8>)
 8003c5e:	4770      	bx	lr
 8003c60:	20000450 	.word	0x20000450

08003c64 <USBD_FS_ManufacturerStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ManufacturerStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8003c64:	b510      	push	{r4, lr}
  USBD_GetString (USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8003c66:	4c04      	ldr	r4, [pc, #16]	; (8003c78 <USBD_FS_ManufacturerStrDescriptor+0x14>)
 8003c68:	460a      	mov	r2, r1
 8003c6a:	4804      	ldr	r0, [pc, #16]	; (8003c7c <USBD_FS_ManufacturerStrDescriptor+0x18>)
 8003c6c:	4621      	mov	r1, r4
 8003c6e:	f001 ff3d 	bl	8005aec <USBD_GetString>
  return USBD_StrDesc;
}
 8003c72:	4620      	mov	r0, r4
 8003c74:	bd10      	pop	{r4, pc}
 8003c76:	bf00      	nop
 8003c78:	20001e8c 	.word	0x20001e8c
 8003c7c:	08006290 	.word	0x08006290

08003c80 <USBD_FS_ProductStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ProductStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8003c80:	b510      	push	{r4, lr}
  if(speed == 0)
  {   
    USBD_GetString (USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8003c82:	4c04      	ldr	r4, [pc, #16]	; (8003c94 <USBD_FS_ProductStrDescriptor+0x14>)
 8003c84:	460a      	mov	r2, r1
 8003c86:	4804      	ldr	r0, [pc, #16]	; (8003c98 <USBD_FS_ProductStrDescriptor+0x18>)
 8003c88:	4621      	mov	r1, r4
 8003c8a:	f001 ff2f 	bl	8005aec <USBD_GetString>
  else
  {
    USBD_GetString (USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);    
  }
  return USBD_StrDesc;
}
 8003c8e:	4620      	mov	r0, r4
 8003c90:	bd10      	pop	{r4, pc}
 8003c92:	bf00      	nop
 8003c94:	20001e8c 	.word	0x20001e8c
 8003c98:	080062a4 	.word	0x080062a4

08003c9c <USBD_FS_SerialStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_SerialStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8003c9c:	b510      	push	{r4, lr}
  if(speed  == USBD_SPEED_HIGH)
  {    
    USBD_GetString (USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);
 8003c9e:	4c04      	ldr	r4, [pc, #16]	; (8003cb0 <USBD_FS_SerialStrDescriptor+0x14>)
 8003ca0:	460a      	mov	r2, r1
 8003ca2:	4804      	ldr	r0, [pc, #16]	; (8003cb4 <USBD_FS_SerialStrDescriptor+0x18>)
 8003ca4:	4621      	mov	r1, r4
 8003ca6:	f001 ff21 	bl	8005aec <USBD_GetString>
  else
  {
    USBD_GetString (USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);    
  }
  return USBD_StrDesc;
}
 8003caa:	4620      	mov	r0, r4
 8003cac:	bd10      	pop	{r4, pc}
 8003cae:	bf00      	nop
 8003cb0:	20001e8c 	.word	0x20001e8c
 8003cb4:	080062bc 	.word	0x080062bc

08003cb8 <USBD_FS_ConfigStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ConfigStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8003cb8:	b510      	push	{r4, lr}
  if(speed  == USBD_SPEED_HIGH)
  {  
    USBD_GetString (USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8003cba:	4c04      	ldr	r4, [pc, #16]	; (8003ccc <USBD_FS_ConfigStrDescriptor+0x14>)
 8003cbc:	460a      	mov	r2, r1
 8003cbe:	4804      	ldr	r0, [pc, #16]	; (8003cd0 <USBD_FS_ConfigStrDescriptor+0x18>)
 8003cc0:	4621      	mov	r1, r4
 8003cc2:	f001 ff13 	bl	8005aec <USBD_GetString>
  else
  {
    USBD_GetString (USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length); 
  }
  return USBD_StrDesc;  
}
 8003cc6:	4620      	mov	r0, r4
 8003cc8:	bd10      	pop	{r4, pc}
 8003cca:	bf00      	nop
 8003ccc:	20001e8c 	.word	0x20001e8c
 8003cd0:	080062cc 	.word	0x080062cc

08003cd4 <USBD_FS_InterfaceStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_InterfaceStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8003cd4:	b510      	push	{r4, lr}
  if(speed == 0)
  {
    USBD_GetString (USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 8003cd6:	4c04      	ldr	r4, [pc, #16]	; (8003ce8 <USBD_FS_InterfaceStrDescriptor+0x14>)
 8003cd8:	460a      	mov	r2, r1
 8003cda:	4804      	ldr	r0, [pc, #16]	; (8003cec <USBD_FS_InterfaceStrDescriptor+0x18>)
 8003cdc:	4621      	mov	r1, r4
 8003cde:	f001 ff05 	bl	8005aec <USBD_GetString>
  else
  {
    USBD_GetString (USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
  }
  return USBD_StrDesc;  
}
 8003ce2:	4620      	mov	r0, r4
 8003ce4:	bd10      	pop	{r4, pc}
 8003ce6:	bf00      	nop
 8003ce8:	20001e8c 	.word	0x20001e8c
 8003cec:	080062d8 	.word	0x080062d8

08003cf0 <HAL_PCD_MspInit>:
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* hpcd)
{
  if(hpcd->Instance==USB)
 8003cf0:	6802      	ldr	r2, [r0, #0]
 8003cf2:	4b0e      	ldr	r3, [pc, #56]	; (8003d2c <HAL_PCD_MspInit+0x3c>)
 8003cf4:	429a      	cmp	r2, r3
 8003cf6:	d000      	beq.n	8003cfa <HAL_PCD_MspInit+0xa>
 8003cf8:	4770      	bx	lr
  {
  /* USER CODE BEGIN USB_MspInit 0 */

  /* USER CODE END USB_MspInit 0 */
    /* Peripheral clock enable */
    __USB_CLK_ENABLE();
 8003cfa:	f503 33da 	add.w	r3, r3, #111616	; 0x1b400
 8003cfe:	69d8      	ldr	r0, [r3, #28]
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* hpcd)
{
 8003d00:	b500      	push	{lr}
  {
  /* USER CODE BEGIN USB_MspInit 0 */

  /* USER CODE END USB_MspInit 0 */
    /* Peripheral clock enable */
    __USB_CLK_ENABLE();
 8003d02:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8003d06:	61d8      	str	r0, [r3, #28]
 8003d08:	69db      	ldr	r3, [r3, #28]
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* hpcd)
{
 8003d0a:	b083      	sub	sp, #12
  {
  /* USER CODE BEGIN USB_MspInit 0 */

  /* USER CODE END USB_MspInit 0 */
    /* Peripheral clock enable */
    __USB_CLK_ENABLE();
 8003d0c:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000

    /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(USB_LP_CAN1_RX0_IRQn, 5, 0);
 8003d10:	2200      	movs	r2, #0
 8003d12:	2105      	movs	r1, #5
  {
  /* USER CODE BEGIN USB_MspInit 0 */

  /* USER CODE END USB_MspInit 0 */
    /* Peripheral clock enable */
    __USB_CLK_ENABLE();
 8003d14:	9301      	str	r3, [sp, #4]

    /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(USB_LP_CAN1_RX0_IRQn, 5, 0);
 8003d16:	2014      	movs	r0, #20
  {
  /* USER CODE BEGIN USB_MspInit 0 */

  /* USER CODE END USB_MspInit 0 */
    /* Peripheral clock enable */
    __USB_CLK_ENABLE();
 8003d18:	9b01      	ldr	r3, [sp, #4]

    /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(USB_LP_CAN1_RX0_IRQn, 5, 0);
 8003d1a:	f7fc fb8d 	bl	8000438 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USB_LP_CAN1_RX0_IRQn);
 8003d1e:	2014      	movs	r0, #20
 8003d20:	f7fc fbc2 	bl	80004a8 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_MspInit 1 */

  /* USER CODE END USB_MspInit 1 */
  }
}
 8003d24:	b003      	add	sp, #12
 8003d26:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d2a:	bf00      	nop
 8003d2c:	40005c00 	.word	0x40005c00

08003d30 <HAL_PCD_SetupStageCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SetupStage(hpcd->pData, (uint8_t *)hpcd->Setup);
 8003d30:	f500 717b 	add.w	r1, r0, #1004	; 0x3ec
 8003d34:	f8d0 041c 	ldr.w	r0, [r0, #1052]	; 0x41c
 8003d38:	f7fd bef4 	b.w	8001b24 <USBD_LL_SetupStage>

08003d3c <HAL_PCD_DataOutStageCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataOutStage(hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8003d3c:	eb00 1341 	add.w	r3, r0, r1, lsl #5
 8003d40:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 8003d44:	f8d0 041c 	ldr.w	r0, [r0, #1052]	; 0x41c
 8003d48:	f7fd bf1c 	b.w	8001b84 <USBD_LL_DataOutStage>

08003d4c <HAL_PCD_DataInStageCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataInStage(hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8003d4c:	eb00 1341 	add.w	r3, r0, r1, lsl #5
 8003d50:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8003d52:	f8d0 041c 	ldr.w	r0, [r0, #1052]	; 0x41c
 8003d56:	f7fd bf4b 	b.w	8001bf0 <USBD_LL_DataInStage>
 8003d5a:	bf00      	nop

08003d5c <HAL_PCD_SOFCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SOF(hpcd->pData);
 8003d5c:	f8d0 041c 	ldr.w	r0, [r0, #1052]	; 0x41c
 8003d60:	f7fd bfce 	b.w	8001d00 <USBD_LL_SOF>

08003d64 <HAL_PCD_ResetCallback>:
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 8003d64:	b510      	push	{r4, lr}
 8003d66:	4604      	mov	r4, r0
	
  default:
    speed = USBD_SPEED_FULL;    
    break;    
  }
  USBD_LL_SetSpeed(hpcd->pData, speed);  
 8003d68:	2101      	movs	r1, #1
 8003d6a:	f8d0 041c 	ldr.w	r0, [r0, #1052]	; 0x41c
 8003d6e:	f7fd ffb1 	bl	8001cd4 <USBD_LL_SetSpeed>
  
  /*Reset Device*/
  USBD_LL_Reset(hpcd->pData);
 8003d72:	f8d4 041c 	ldr.w	r0, [r4, #1052]	; 0x41c
}
 8003d76:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    break;    
  }
  USBD_LL_SetSpeed(hpcd->pData, speed);  
  
  /*Reset Device*/
  USBD_LL_Reset(hpcd->pData);
 8003d7a:	f7fd bf8b 	b.w	8001c94 <USBD_LL_Reset>
 8003d7e:	bf00      	nop

08003d80 <HAL_PCD_SuspendCallback>:
  * When Low power mode is enabled the debug cannot be used (IAR, Keil doesn't support it)
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{
 8003d80:	b510      	push	{r4, lr}
 8003d82:	4604      	mov	r4, r0
  /* Inform USB library that core enters in suspend Mode */
  USBD_LL_Suspend(hpcd->pData);
 8003d84:	f8d0 041c 	ldr.w	r0, [r0, #1052]	; 0x41c
 8003d88:	f7fd ffa8 	bl	8001cdc <USBD_LL_Suspend>
  /*Enter in STOP mode */
  /* USER CODE BEGIN 2 */  
  if (hpcd->Init.low_power_enable)
 8003d8c:	69a3      	ldr	r3, [r4, #24]
 8003d8e:	b123      	cbz	r3, 8003d9a <HAL_PCD_SuspendCallback+0x1a>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8003d90:	4a02      	ldr	r2, [pc, #8]	; (8003d9c <HAL_PCD_SuspendCallback+0x1c>)
 8003d92:	6913      	ldr	r3, [r2, #16]
 8003d94:	f043 0306 	orr.w	r3, r3, #6
 8003d98:	6113      	str	r3, [r2, #16]
 8003d9a:	bd10      	pop	{r4, pc}
 8003d9c:	e000ed00 	.word	0xe000ed00

08003da0 <HAL_PCD_ResumeCallback>:
  */
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
  /* USER CODE BEGIN 3 */
  /* USER CODE END 3 */
  USBD_LL_Resume(hpcd->pData);
 8003da0:	f8d0 041c 	ldr.w	r0, [r0, #1052]	; 0x41c
 8003da4:	f7fd bfa4 	b.w	8001cf0 <USBD_LL_Resume>

08003da8 <USBD_LL_Init>:
  * @brief  Initializes the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{ 
 8003da8:	b570      	push	{r4, r5, r6, lr}
 8003daa:	4605      	mov	r5, r0
  /* Init USB_IP */
  /* Link The driver to the stack */
  hpcd_USB_FS.pData = pdev;
 8003dac:	4b1c      	ldr	r3, [pc, #112]	; (8003e20 <USBD_LL_Init+0x78>)
  pdev->pData = &hpcd_USB_FS;

  hpcd_USB_FS.Instance = USB;
 8003dae:	4e1d      	ldr	r6, [pc, #116]	; (8003e24 <USBD_LL_Init+0x7c>)
  hpcd_USB_FS.Init.dev_endpoints = 8;
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
  hpcd_USB_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 8003db0:	2400      	movs	r4, #0
  */
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{ 
  /* Init USB_IP */
  /* Link The driver to the stack */
  hpcd_USB_FS.pData = pdev;
 8003db2:	f8c3 041c 	str.w	r0, [r3, #1052]	; 0x41c
  pdev->pData = &hpcd_USB_FS;

  hpcd_USB_FS.Instance = USB;
  hpcd_USB_FS.Init.dev_endpoints = 8;
 8003db6:	2108      	movs	r1, #8
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{ 
  /* Init USB_IP */
  /* Link The driver to the stack */
  hpcd_USB_FS.pData = pdev;
  pdev->pData = &hpcd_USB_FS;
 8003db8:	f8c0 3220 	str.w	r3, [r0, #544]	; 0x220

  hpcd_USB_FS.Instance = USB;
  hpcd_USB_FS.Init.dev_endpoints = 8;
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
 8003dbc:	2202      	movs	r2, #2
  hpcd_USB_FS.Init.ep0_mps = DEP0CTL_MPS_64;
  hpcd_USB_FS.Init.low_power_enable = DISABLE;
  hpcd_USB_FS.Init.lpm_enable = DISABLE;
  hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
  HAL_PCD_Init(&hpcd_USB_FS);
 8003dbe:	4618      	mov	r0, r3
  /* Init USB_IP */
  /* Link The driver to the stack */
  hpcd_USB_FS.pData = pdev;
  pdev->pData = &hpcd_USB_FS;

  hpcd_USB_FS.Instance = USB;
 8003dc0:	601e      	str	r6, [r3, #0]
  hpcd_USB_FS.Init.dev_endpoints = 8;
 8003dc2:	6059      	str	r1, [r3, #4]
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
 8003dc4:	609a      	str	r2, [r3, #8]
  hpcd_USB_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 8003dc6:	60dc      	str	r4, [r3, #12]
  hpcd_USB_FS.Init.low_power_enable = DISABLE;
 8003dc8:	619c      	str	r4, [r3, #24]
  hpcd_USB_FS.Init.lpm_enable = DISABLE;
 8003dca:	61dc      	str	r4, [r3, #28]
  hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
 8003dcc:	621c      	str	r4, [r3, #32]
  HAL_PCD_Init(&hpcd_USB_FS);
 8003dce:	f7fd fa3b 	bl	8001248 <HAL_PCD_Init>

  HAL_PCDEx_PMAConfig(pdev->pData , 0x00 , PCD_SNG_BUF, 0x18);
 8003dd2:	4622      	mov	r2, r4
 8003dd4:	4621      	mov	r1, r4
 8003dd6:	f8d5 0220 	ldr.w	r0, [r5, #544]	; 0x220
 8003dda:	2318      	movs	r3, #24
 8003ddc:	f001 feac 	bl	8005b38 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig(pdev->pData , 0x80 , PCD_SNG_BUF, 0x58);
 8003de0:	4622      	mov	r2, r4
 8003de2:	f8d5 0220 	ldr.w	r0, [r5, #544]	; 0x220
 8003de6:	2358      	movs	r3, #88	; 0x58
 8003de8:	2180      	movs	r1, #128	; 0x80
 8003dea:	f001 fea5 	bl	8005b38 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig(pdev->pData , 0x81 , PCD_SNG_BUF, 0xC0);  
 8003dee:	4622      	mov	r2, r4
 8003df0:	f8d5 0220 	ldr.w	r0, [r5, #544]	; 0x220
 8003df4:	23c0      	movs	r3, #192	; 0xc0
 8003df6:	2181      	movs	r1, #129	; 0x81
 8003df8:	f001 fe9e 	bl	8005b38 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig(pdev->pData , 0x01 , PCD_SNG_BUF, 0x110);
 8003dfc:	4622      	mov	r2, r4
 8003dfe:	f8d5 0220 	ldr.w	r0, [r5, #544]	; 0x220
 8003e02:	f44f 7388 	mov.w	r3, #272	; 0x110
 8003e06:	2101      	movs	r1, #1
 8003e08:	f001 fe96 	bl	8005b38 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig(pdev->pData , 0x82 , PCD_SNG_BUF, 0x100);  
 8003e0c:	f8d5 0220 	ldr.w	r0, [r5, #544]	; 0x220
 8003e10:	4622      	mov	r2, r4
 8003e12:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003e16:	2182      	movs	r1, #130	; 0x82
 8003e18:	f001 fe8e 	bl	8005b38 <HAL_PCDEx_PMAConfig>
  return USBD_OK;
}
 8003e1c:	4620      	mov	r0, r4
 8003e1e:	bd70      	pop	{r4, r5, r6, pc}
 8003e20:	2000208c 	.word	0x2000208c
 8003e24:	40005c00 	.word	0x40005c00

08003e28 <USBD_LL_Start>:
  * @brief  Starts the Low Level portion of the Device driver. 
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8003e28:	b508      	push	{r3, lr}
  HAL_PCD_Start(pdev->pData);
 8003e2a:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003e2e:	f7fd fa79 	bl	8001324 <HAL_PCD_Start>
  return USBD_OK; 
}
 8003e32:	2000      	movs	r0, #0
 8003e34:	bd08      	pop	{r3, pc}
 8003e36:	bf00      	nop

08003e38 <USBD_LL_OpenEP>:
  */
USBD_StatusTypeDef  USBD_LL_OpenEP  (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  ep_type,
                                      uint16_t ep_mps)
{
 8003e38:	b510      	push	{r4, lr}
 8003e3a:	461c      	mov	r4, r3

  HAL_PCD_EP_Open(pdev->pData, 
 8003e3c:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003e40:	4613      	mov	r3, r2
 8003e42:	4622      	mov	r2, r4
 8003e44:	f7fd fa9a 	bl	800137c <HAL_PCD_EP_Open>
                  ep_addr, 
                  ep_mps, 
                  ep_type);
  
  return USBD_OK; 
}
 8003e48:	2000      	movs	r0, #0
 8003e4a:	bd10      	pop	{r4, pc}

08003e4c <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_CloseEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 8003e4c:	b508      	push	{r3, lr}
  
  HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8003e4e:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003e52:	f7fd fab9 	bl	80013c8 <HAL_PCD_EP_Close>
  return USBD_OK; 
}
 8003e56:	2000      	movs	r0, #0
 8003e58:	bd08      	pop	{r3, pc}
 8003e5a:	bf00      	nop

08003e5c <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_StallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 8003e5c:	b508      	push	{r3, lr}
  
  HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8003e5e:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003e62:	f7fd fdd7 	bl	8001a14 <HAL_PCD_EP_SetStall>
  return USBD_OK; 
}
 8003e66:	2000      	movs	r0, #0
 8003e68:	bd08      	pop	{r3, pc}
 8003e6a:	bf00      	nop

08003e6c <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_ClearStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 8003e6c:	b508      	push	{r3, lr}
  
  HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);  
 8003e6e:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003e72:	f7fd fdfb 	bl	8001a6c <HAL_PCD_EP_ClrStall>
  return USBD_OK; 
}
 8003e76:	2000      	movs	r0, #0
 8003e78:	bd08      	pop	{r3, pc}
 8003e7a:	bf00      	nop

08003e7c <USBD_LL_IsStallEP>:
  */
uint8_t USBD_LL_IsStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
  PCD_HandleTypeDef *hpcd = pdev->pData; 
  
  if((ep_addr & 0x80) == 0x80)
 8003e7c:	060a      	lsls	r2, r1, #24
  * @param  ep_addr: Endpoint Number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
  PCD_HandleTypeDef *hpcd = pdev->pData; 
 8003e7e:	f8d0 3220 	ldr.w	r3, [r0, #544]	; 0x220
  
  if((ep_addr & 0x80) == 0x80)
 8003e82:	d404      	bmi.n	8003e8e <USBD_LL_IsStallEP+0x12>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 8003e84:	eb03 1341 	add.w	r3, r3, r1, lsl #5
 8003e88:	f893 020a 	ldrb.w	r0, [r3, #522]	; 0x20a
  }
}
 8003e8c:	4770      	bx	lr
{
  PCD_HandleTypeDef *hpcd = pdev->pData; 
  
  if((ep_addr & 0x80) == 0x80)
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 8003e8e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8003e92:	eb03 1341 	add.w	r3, r3, r1, lsl #5
 8003e96:	f893 002a 	ldrb.w	r0, [r3, #42]	; 0x2a
 8003e9a:	4770      	bx	lr

08003e9c <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_SetUSBAddress (USBD_HandleTypeDef *pdev, uint8_t dev_addr)   
{
 8003e9c:	b508      	push	{r3, lr}
  
  HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8003e9e:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003ea2:	f7fd fa57 	bl	8001354 <HAL_PCD_SetAddress>
  return USBD_OK; 
}
 8003ea6:	2000      	movs	r0, #0
 8003ea8:	bd08      	pop	{r3, pc}
 8003eaa:	bf00      	nop

08003eac <USBD_LL_Transmit>:
  */
USBD_StatusTypeDef  USBD_LL_Transmit (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  *pbuf,
                                      uint16_t  size)
{
 8003eac:	b508      	push	{r3, lr}

  HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8003eae:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003eb2:	f7fd fad9 	bl	8001468 <HAL_PCD_EP_Transmit>
  return USBD_OK;   
}
 8003eb6:	2000      	movs	r0, #0
 8003eb8:	bd08      	pop	{r3, pc}
 8003eba:	bf00      	nop

08003ebc <USBD_LL_PrepareReceive>:
  */
USBD_StatusTypeDef  USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, 
                                           uint8_t  ep_addr,                                      
                                           uint8_t  *pbuf,
                                           uint16_t  size)
{
 8003ebc:	b508      	push	{r3, lr}

  HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8003ebe:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003ec2:	f7fd faa5 	bl	8001410 <HAL_PCD_EP_Receive>
  return USBD_OK;   
}
 8003ec6:	2000      	movs	r0, #0
 8003ec8:	bd08      	pop	{r3, pc}
 8003eca:	bf00      	nop

08003ecc <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval Recived Data Size
  */
uint32_t USBD_LL_GetRxDataSize  (USBD_HandleTypeDef *pdev, uint8_t  ep_addr)  
{
 8003ecc:	b508      	push	{r3, lr}
  return HAL_PCD_EP_GetRxCount(pdev->pData, ep_addr);
 8003ece:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003ed2:	f7fd fac1 	bl	8001458 <HAL_PCD_EP_GetRxCount>
}
 8003ed6:	bd08      	pop	{r3, pc}

08003ed8 <USBD_static_malloc>:
  */
void *USBD_static_malloc(uint32_t size)
{
  static uint32_t mem[(sizeof(USBD_CDC_HandleTypeDef)/4)+1];//On 32-bit boundary
  return mem;
}
 8003ed8:	4800      	ldr	r0, [pc, #0]	; (8003edc <USBD_static_malloc+0x4>)
 8003eda:	4770      	bx	lr
 8003edc:	20000ac4 	.word	0x20000ac4

08003ee0 <USBD_static_free>:
  * @param  *p pointer to allocated  memory address
  * @retval None
  */
void USBD_static_free(void *p)
{
  free(p);
 8003ee0:	f001 bf4e 	b.w	8005d80 <free>

08003ee4 <HAL_PCDEx_SetConnectionState>:
* @param hpcd: PCD handle
* @param state: connection state (0 : disconnected / 1: connected) 
* @retval None
*/
void HAL_PCDEx_SetConnectionState(PCD_HandleTypeDef *hpcd, uint8_t state)
{
 8003ee4:	4770      	bx	lr
 8003ee6:	bf00      	nop

08003ee8 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003ee8:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8003eec:	f04f 31ff 	mov.w	r1, #4294967295
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8003ef0:	2200      	movs	r2, #0
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8003ef2:	6081      	str	r1, [r0, #8]
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003ef4:	e880 000c 	stmia.w	r0, {r2, r3}
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003ef8:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003efa:	6103      	str	r3, [r0, #16]
 8003efc:	4770      	bx	lr
 8003efe:	bf00      	nop

08003f00 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8003f00:	2300      	movs	r3, #0
 8003f02:	6103      	str	r3, [r0, #16]
 8003f04:	4770      	bx	lr
 8003f06:	bf00      	nop

08003f08 <vListInsertEnd>:
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8003f08:	e890 000c 	ldmia.w	r0, {r2, r3}
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8003f0c:	b410      	push	{r4}

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8003f0e:	689c      	ldr	r4, [r3, #8]
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8003f10:	3201      	adds	r2, #1

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8003f12:	608c      	str	r4, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8003f14:	689c      	ldr	r4, [r3, #8]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8003f16:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8003f18:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8003f1a:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
}
 8003f1c:	bc10      	pop	{r4}

	pxIndex->pxPrevious->pxNext = pxNewListItem;
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8003f1e:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8003f20:	6002      	str	r2, [r0, #0]
}
 8003f22:	4770      	bx	lr

08003f24 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8003f24:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8003f26:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8003f28:	1c6b      	adds	r3, r5, #1
 8003f2a:	d011      	beq.n	8003f50 <vListInsert+0x2c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003f2c:	f100 0208 	add.w	r2, r0, #8
 8003f30:	e000      	b.n	8003f34 <vListInsert+0x10>
 8003f32:	461a      	mov	r2, r3
 8003f34:	6853      	ldr	r3, [r2, #4]
 8003f36:	681c      	ldr	r4, [r3, #0]
 8003f38:	42a5      	cmp	r5, r4
 8003f3a:	d2fa      	bcs.n	8003f32 <vListInsert+0xe>

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8003f3c:	6804      	ldr	r4, [r0, #0]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8003f3e:	604b      	str	r3, [r1, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8003f40:	3401      	adds	r4, #1
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8003f42:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8003f44:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8003f46:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8003f48:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8003f4a:	6004      	str	r4, [r0, #0]
}
 8003f4c:	bc30      	pop	{r4, r5}
 8003f4e:	4770      	bx	lr
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8003f50:	6902      	ldr	r2, [r0, #16]
 8003f52:	6853      	ldr	r3, [r2, #4]
 8003f54:	e7f2      	b.n	8003f3c <vListInsert+0x18>
 8003f56:	bf00      	nop

08003f58 <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8003f58:	6843      	ldr	r3, [r0, #4]
 8003f5a:	6881      	ldr	r1, [r0, #8]

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8003f5c:	6902      	ldr	r2, [r0, #16]
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 8003f5e:	b410      	push	{r4}
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8003f60:	6099      	str	r1, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8003f62:	6881      	ldr	r1, [r0, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8003f64:	6854      	ldr	r4, [r2, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8003f66:	604b      	str	r3, [r1, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
	( pxList->uxNumberOfItems )--;
 8003f68:	6813      	ldr	r3, [r2, #0]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8003f6a:	42a0      	cmp	r0, r4
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8003f6c:	bf08      	it	eq
 8003f6e:	6051      	streq	r1, [r2, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
	( pxList->uxNumberOfItems )--;
 8003f70:	3b01      	subs	r3, #1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8003f72:	2100      	movs	r1, #0
 8003f74:	6101      	str	r1, [r0, #16]
	( pxList->uxNumberOfItems )--;

	return pxList->uxNumberOfItems;
}
 8003f76:	bc10      	pop	{r4}
 8003f78:	4618      	mov	r0, r3
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
	( pxList->uxNumberOfItems )--;
 8003f7a:	6013      	str	r3, [r2, #0]

	return pxList->uxNumberOfItems;
}
 8003f7c:	4770      	bx	lr
 8003f7e:	bf00      	nop

08003f80 <_sbrk>:
caddr_t _sbrk ( int incr )
{
    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
 8003f80:	4a04      	ldr	r2, [pc, #16]	; (8003f94 <_sbrk+0x14>)
 8003f82:	4905      	ldr	r1, [pc, #20]	; (8003f98 <_sbrk+0x18>)
 8003f84:	6813      	ldr	r3, [r2, #0]
 8003f86:	2b00      	cmp	r3, #0
 8003f88:	bf08      	it	eq
 8003f8a:	460b      	moveq	r3, r1
        heap = (unsigned char *)&_end;
    }
    prev_heap = heap;

    heap += incr;
 8003f8c:	4418      	add	r0, r3
 8003f8e:	6010      	str	r0, [r2, #0]

    return (caddr_t) prev_heap;
}
 8003f90:	4618      	mov	r0, r3
 8003f92:	4770      	bx	lr
 8003f94:	20000ce4 	.word	0x20000ce4
 8003f98:	20002818 	.word	0x20002818

08003f9c <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_AFIO_CLK_ENABLE();
 8003f9c:	4b0f      	ldr	r3, [pc, #60]	; (8003fdc <HAL_MspInit+0x40>)

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8003f9e:	b500      	push	{lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_AFIO_CLK_ENABLE();
 8003fa0:	699a      	ldr	r2, [r3, #24]

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8003fa2:	b083      	sub	sp, #12
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_AFIO_CLK_ENABLE();
 8003fa4:	f042 0201 	orr.w	r2, r2, #1
 8003fa8:	619a      	str	r2, [r3, #24]
 8003faa:	699b      	ldr	r3, [r3, #24]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8003fac:	2003      	movs	r0, #3
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_AFIO_CLK_ENABLE();
 8003fae:	f003 0301 	and.w	r3, r3, #1
 8003fb2:	9301      	str	r3, [sp, #4]
 8003fb4:	9b01      	ldr	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8003fb6:	f7fc fa2d 	bl	8000414 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 8003fba:	2200      	movs	r2, #0
 8003fbc:	210f      	movs	r1, #15
 8003fbe:	f04f 30ff 	mov.w	r0, #4294967295
 8003fc2:	f7fc fa39 	bl	8000438 <HAL_NVIC_SetPriority>

    /**NOJTAG: JTAG-DP Disabled and SW-DP Enabled 
    */
  __HAL_AFIO_REMAP_SWJ_NOJTAG();
 8003fc6:	4a06      	ldr	r2, [pc, #24]	; (8003fe0 <HAL_MspInit+0x44>)
 8003fc8:	6853      	ldr	r3, [r2, #4]
 8003fca:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 8003fce:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8003fd2:	6053      	str	r3, [r2, #4]

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8003fd4:	b003      	add	sp, #12
 8003fd6:	f85d fb04 	ldr.w	pc, [sp], #4
 8003fda:	bf00      	nop
 8003fdc:	40021000 	.word	0x40021000
 8003fe0:	40010000 	.word	0x40010000

08003fe4 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hadc->Instance==ADC1)
 8003fe4:	4b19      	ldr	r3, [pc, #100]	; (800404c <HAL_ADC_MspInit+0x68>)
 8003fe6:	6802      	ldr	r2, [r0, #0]
 8003fe8:	429a      	cmp	r2, r3
 8003fea:	d000      	beq.n	8003fee <HAL_ADC_MspInit+0xa>
 8003fec:	4770      	bx	lr
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* Peripheral clock enable */
    __ADC1_CLK_ENABLE();
 8003fee:	f503 436c 	add.w	r3, r3, #60416	; 0xec00
 8003ff2:	699a      	ldr	r2, [r3, #24]

  /* USER CODE END MspInit 1 */
}

void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8003ff4:	b5f0      	push	{r4, r5, r6, r7, lr}
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* Peripheral clock enable */
    __ADC1_CLK_ENABLE();
 8003ff6:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8003ffa:	619a      	str	r2, [r3, #24]
 8003ffc:	699b      	ldr	r3, [r3, #24]

  /* USER CODE END MspInit 1 */
}

void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8003ffe:	b087      	sub	sp, #28
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* Peripheral clock enable */
    __ADC1_CLK_ENABLE();
 8004000:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8004004:	4604      	mov	r4, r0
    PA1     ------> ADC1_IN1
    PA2     ------> ADC1_IN2 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8004006:	a902      	add	r1, sp, #8
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* Peripheral clock enable */
    __ADC1_CLK_ENABLE();
 8004008:	9301      	str	r3, [sp, #4]
    /**ADC1 GPIO Configuration    
    PA0-WKUP     ------> ADC1_IN0
    PA1     ------> ADC1_IN1
    PA2     ------> ADC1_IN2 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2;
 800400a:	2707      	movs	r7, #7
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800400c:	2603      	movs	r6, #3
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800400e:	4810      	ldr	r0, [pc, #64]	; (8004050 <HAL_ADC_MspInit+0x6c>)

    /* Peripheral DMA init*/
  
    hdma_adc1.Instance = DMA1_Channel1;
 8004010:	4d10      	ldr	r5, [pc, #64]	; (8004054 <HAL_ADC_MspInit+0x70>)
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* Peripheral clock enable */
    __ADC1_CLK_ENABLE();
 8004012:	9b01      	ldr	r3, [sp, #4]
    /**ADC1 GPIO Configuration    
    PA0-WKUP     ------> ADC1_IN0
    PA1     ------> ADC1_IN1
    PA2     ------> ADC1_IN2 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2;
 8004014:	9702      	str	r7, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8004016:	9603      	str	r6, [sp, #12]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8004018:	f7ff fb0a 	bl	8003630 <HAL_GPIO_Init>

    /* Peripheral DMA init*/
  
    hdma_adc1.Instance = DMA1_Channel1;
 800401c:	4b0e      	ldr	r3, [pc, #56]	; (8004058 <HAL_ADC_MspInit+0x74>)
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 800401e:	f44f 6180 	mov.w	r1, #1024	; 0x400
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
 8004022:	2220      	movs	r2, #32
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* Peripheral DMA init*/
  
    hdma_adc1.Instance = DMA1_Channel1;
 8004024:	602b      	str	r3, [r5, #0]
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
 8004026:	2780      	movs	r7, #128	; 0x80
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* Peripheral DMA init*/
  
    hdma_adc1.Instance = DMA1_Channel1;
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8004028:	2300      	movs	r3, #0
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 800402a:	f44f 7680 	mov.w	r6, #256	; 0x100
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
    hdma_adc1.Init.Priority = DMA_PRIORITY_LOW;
    HAL_DMA_Init(&hdma_adc1);
 800402e:	4628      	mov	r0, r5
    /* Peripheral DMA init*/
  
    hdma_adc1.Instance = DMA1_Channel1;
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
 8004030:	60ef      	str	r7, [r5, #12]
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 8004032:	612e      	str	r6, [r5, #16]
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 8004034:	6169      	str	r1, [r5, #20]
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
 8004036:	61aa      	str	r2, [r5, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* Peripheral DMA init*/
  
    hdma_adc1.Instance = DMA1_Channel1;
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8004038:	606b      	str	r3, [r5, #4]
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
 800403a:	60ab      	str	r3, [r5, #8]
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
    hdma_adc1.Init.Priority = DMA_PRIORITY_LOW;
 800403c:	61eb      	str	r3, [r5, #28]
    HAL_DMA_Init(&hdma_adc1);
 800403e:	f7ff fbe7 	bl	8003810 <HAL_DMA_Init>

    __HAL_LINKDMA(hadc,DMA_Handle,hdma_adc1);
 8004042:	6225      	str	r5, [r4, #32]
 8004044:	626c      	str	r4, [r5, #36]	; 0x24
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }

}
 8004046:	b007      	add	sp, #28
 8004048:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800404a:	bf00      	nop
 800404c:	40012400 	.word	0x40012400
 8004050:	40010800 	.word	0x40010800
 8004054:	20001dfc 	.word	0x20001dfc
 8004058:	40020008 	.word	0x40020008

0800405c <HAL_CRC_MspInit>:
}

void HAL_CRC_MspInit(CRC_HandleTypeDef* hcrc)
{

  if(hcrc->Instance==CRC)
 800405c:	6802      	ldr	r2, [r0, #0]
 800405e:	4b09      	ldr	r3, [pc, #36]	; (8004084 <HAL_CRC_MspInit+0x28>)
 8004060:	429a      	cmp	r2, r3
 8004062:	d000      	beq.n	8004066 <HAL_CRC_MspInit+0xa>
  /* USER CODE BEGIN CRC_MspInit 1 */

  /* USER CODE END CRC_MspInit 1 */
  }

}
 8004064:	4770      	bx	lr
  {
  /* USER CODE BEGIN CRC_MspInit 0 */

  /* USER CODE END CRC_MspInit 0 */
    /* Peripheral clock enable */
    __CRC_CLK_ENABLE();
 8004066:	f5a3 5300 	sub.w	r3, r3, #8192	; 0x2000
 800406a:	695a      	ldr	r2, [r3, #20]
  /* USER CODE END ADC1_MspDeInit 1 */

}

void HAL_CRC_MspInit(CRC_HandleTypeDef* hcrc)
{
 800406c:	b082      	sub	sp, #8
  {
  /* USER CODE BEGIN CRC_MspInit 0 */

  /* USER CODE END CRC_MspInit 0 */
    /* Peripheral clock enable */
    __CRC_CLK_ENABLE();
 800406e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8004072:	615a      	str	r2, [r3, #20]
 8004074:	695b      	ldr	r3, [r3, #20]
 8004076:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800407a:	9301      	str	r3, [sp, #4]
 800407c:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN CRC_MspInit 1 */

  /* USER CODE END CRC_MspInit 1 */
  }

}
 800407e:	b002      	add	sp, #8
 8004080:	4770      	bx	lr
 8004082:	bf00      	nop
 8004084:	40023000 	.word	0x40023000

08004088 <HAL_IWDG_MspInit>:
  /* USER CODE END CRC_MspDeInit 1 */

}

void HAL_IWDG_MspInit(IWDG_HandleTypeDef* hiwdg)
{
 8004088:	4770      	bx	lr
 800408a:	bf00      	nop

0800408c <HAL_RTC_MspInit>:
}

void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{

  if(hrtc->Instance==RTC)
 800408c:	6802      	ldr	r2, [r0, #0]
 800408e:	4b0f      	ldr	r3, [pc, #60]	; (80040cc <HAL_RTC_MspInit+0x40>)
 8004090:	429a      	cmp	r2, r3
 8004092:	d000      	beq.n	8004096 <HAL_RTC_MspInit+0xa>
 8004094:	4770      	bx	lr
{

}

void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{
 8004096:	b500      	push	{lr}
 8004098:	b083      	sub	sp, #12
  if(hrtc->Instance==RTC)
  {
  /* USER CODE BEGIN RTC_MspInit 0 */

  /* USER CODE END RTC_MspInit 0 */
    HAL_PWR_EnableBkUpAccess();
 800409a:	f7fc f951 	bl	8000340 <HAL_PWR_EnableBkUpAccess>
    /* Enable BKP CLK enable for backup registers */
    __HAL_RCC_BKP_CLK_ENABLE();
 800409e:	4a0c      	ldr	r2, [pc, #48]	; (80040d0 <HAL_RTC_MspInit+0x44>)
 80040a0:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80040a4:	69d1      	ldr	r1, [r2, #28]
 80040a6:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
 80040aa:	61d1      	str	r1, [r2, #28]
 80040ac:	69d2      	ldr	r2, [r2, #28]
 80040ae:	f002 6200 	and.w	r2, r2, #134217728	; 0x8000000
 80040b2:	9201      	str	r2, [sp, #4]
 80040b4:	9a01      	ldr	r2, [sp, #4]
 80040b6:	fa93 f3a3 	rbit	r3, r3
    /* Peripheral clock enable */
    __HAL_RCC_RTC_ENABLE();
 80040ba:	fab3 f383 	clz	r3, r3
 80040be:	4a05      	ldr	r2, [pc, #20]	; (80040d4 <HAL_RTC_MspInit+0x48>)
 80040c0:	2101      	movs	r1, #1
 80040c2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }

}
 80040c6:	b003      	add	sp, #12
 80040c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80040cc:	40002800 	.word	0x40002800
 80040d0:	40021000 	.word	0x40021000
 80040d4:	42420400 	.word	0x42420400

080040d8 <HAL_TIM_Base_MspInit>:
  /* USER CODE END RTC_MspDeInit 1 */

}

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 80040d8:	b500      	push	{lr}

  if(htim_base->Instance==TIM2)
 80040da:	6803      	ldr	r3, [r0, #0]
  /* USER CODE END RTC_MspDeInit 1 */

}

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 80040dc:	b085      	sub	sp, #20

  if(htim_base->Instance==TIM2)
 80040de:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80040e2:	d020      	beq.n	8004126 <HAL_TIM_Base_MspInit+0x4e>
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }
  else if(htim_base->Instance==TIM3)
 80040e4:	4a1a      	ldr	r2, [pc, #104]	; (8004150 <HAL_TIM_Base_MspInit+0x78>)
 80040e6:	4293      	cmp	r3, r2
 80040e8:	d012      	beq.n	8004110 <HAL_TIM_Base_MspInit+0x38>
    __TIM3_CLK_ENABLE();
  /* USER CODE BEGIN TIM3_MspInit 1 */

  /* USER CODE END TIM3_MspInit 1 */
  }
  else if(htim_base->Instance==TIM4)
 80040ea:	4a1a      	ldr	r2, [pc, #104]	; (8004154 <HAL_TIM_Base_MspInit+0x7c>)
 80040ec:	4293      	cmp	r3, r2
 80040ee:	d002      	beq.n	80040f6 <HAL_TIM_Base_MspInit+0x1e>
  /* USER CODE BEGIN TIM4_MspInit 1 */

  /* USER CODE END TIM4_MspInit 1 */
  }

}
 80040f0:	b005      	add	sp, #20
 80040f2:	f85d fb04 	ldr.w	pc, [sp], #4
  {
  /* USER CODE BEGIN TIM4_MspInit 0 */

  /* USER CODE END TIM4_MspInit 0 */
    /* Peripheral clock enable */
    __TIM4_CLK_ENABLE();
 80040f6:	4b18      	ldr	r3, [pc, #96]	; (8004158 <HAL_TIM_Base_MspInit+0x80>)
 80040f8:	69da      	ldr	r2, [r3, #28]
 80040fa:	f042 0204 	orr.w	r2, r2, #4
 80040fe:	61da      	str	r2, [r3, #28]
 8004100:	69db      	ldr	r3, [r3, #28]
 8004102:	f003 0304 	and.w	r3, r3, #4
 8004106:	9303      	str	r3, [sp, #12]
 8004108:	9b03      	ldr	r3, [sp, #12]
  /* USER CODE BEGIN TIM4_MspInit 1 */

  /* USER CODE END TIM4_MspInit 1 */
  }

}
 800410a:	b005      	add	sp, #20
 800410c:	f85d fb04 	ldr.w	pc, [sp], #4
  {
  /* USER CODE BEGIN TIM3_MspInit 0 */

  /* USER CODE END TIM3_MspInit 0 */
    /* Peripheral clock enable */
    __TIM3_CLK_ENABLE();
 8004110:	4b11      	ldr	r3, [pc, #68]	; (8004158 <HAL_TIM_Base_MspInit+0x80>)
 8004112:	69da      	ldr	r2, [r3, #28]
 8004114:	f042 0202 	orr.w	r2, r2, #2
 8004118:	61da      	str	r2, [r3, #28]
 800411a:	69db      	ldr	r3, [r3, #28]
 800411c:	f003 0302 	and.w	r3, r3, #2
 8004120:	9302      	str	r3, [sp, #8]
 8004122:	9b02      	ldr	r3, [sp, #8]
 8004124:	e7e4      	b.n	80040f0 <HAL_TIM_Base_MspInit+0x18>
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* Peripheral clock enable */
    __TIM2_CLK_ENABLE();
 8004126:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 800412a:	69d8      	ldr	r0, [r3, #28]
  /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(TIM2_IRQn, 5, 0);
 800412c:	2200      	movs	r2, #0
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* Peripheral clock enable */
    __TIM2_CLK_ENABLE();
 800412e:	f040 0001 	orr.w	r0, r0, #1
 8004132:	61d8      	str	r0, [r3, #28]
 8004134:	69db      	ldr	r3, [r3, #28]
  /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(TIM2_IRQn, 5, 0);
 8004136:	2105      	movs	r1, #5
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* Peripheral clock enable */
    __TIM2_CLK_ENABLE();
 8004138:	f003 0301 	and.w	r3, r3, #1
 800413c:	9301      	str	r3, [sp, #4]
  /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(TIM2_IRQn, 5, 0);
 800413e:	201c      	movs	r0, #28
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* Peripheral clock enable */
    __TIM2_CLK_ENABLE();
 8004140:	9b01      	ldr	r3, [sp, #4]
  /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(TIM2_IRQn, 5, 0);
 8004142:	f7fc f979 	bl	8000438 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
 8004146:	201c      	movs	r0, #28
 8004148:	f7fc f9ae 	bl	80004a8 <HAL_NVIC_EnableIRQ>
 800414c:	e7d0      	b.n	80040f0 <HAL_TIM_Base_MspInit+0x18>
 800414e:	bf00      	nop
 8004150:	40000400 	.word	0x40000400
 8004154:	40000800 	.word	0x40000800
 8004158:	40021000 	.word	0x40021000

0800415c <HAL_TIM_MspPostInit>:
  }

}

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
 800415c:	b500      	push	{lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(htim->Instance==TIM3)
 800415e:	6803      	ldr	r3, [r0, #0]
 8004160:	4a12      	ldr	r2, [pc, #72]	; (80041ac <HAL_TIM_MspPostInit+0x50>)
  }

}

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
 8004162:	b085      	sub	sp, #20

  GPIO_InitTypeDef GPIO_InitStruct;
  if(htim->Instance==TIM3)
 8004164:	4293      	cmp	r3, r2
 8004166:	d010      	beq.n	800418a <HAL_TIM_MspPostInit+0x2e>
    __HAL_AFIO_REMAP_TIM3_PARTIAL();
  /* USER CODE BEGIN TIM3_MspPostInit 1 */

  /* USER CODE END TIM3_MspPostInit 1 */
  }
  else if(htim->Instance==TIM4)
 8004168:	4a11      	ldr	r2, [pc, #68]	; (80041b0 <HAL_TIM_MspPostInit+0x54>)
 800416a:	4293      	cmp	r3, r2
 800416c:	d002      	beq.n	8004174 <HAL_TIM_MspPostInit+0x18>
  /* USER CODE BEGIN TIM4_MspPostInit 1 */

  /* USER CODE END TIM4_MspPostInit 1 */
  }

}
 800416e:	b005      	add	sp, #20
 8004170:	f85d fb04 	ldr.w	pc, [sp], #4
    PB6     ------> TIM4_CH1
    PB7     ------> TIM4_CH2
    PB8     ------> TIM4_CH3 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8004174:	2302      	movs	r3, #2
    /**TIM4 GPIO Configuration    
    PB6     ------> TIM4_CH1
    PB7     ------> TIM4_CH2
    PB8     ------> TIM4_CH3 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
 8004176:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800417a:	4669      	mov	r1, sp
 800417c:	480d      	ldr	r0, [pc, #52]	; (80041b4 <HAL_TIM_MspPostInit+0x58>)
    PB6     ------> TIM4_CH1
    PB7     ------> TIM4_CH2
    PB8     ------> TIM4_CH3 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800417e:	e88d 000c 	stmia.w	sp, {r2, r3}
    GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 8004182:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8004184:	f7ff fa54 	bl	8003630 <HAL_GPIO_Init>
  /* USER CODE BEGIN TIM4_MspPostInit 1 */

  /* USER CODE END TIM4_MspPostInit 1 */
  }

}
 8004188:	e7f1      	b.n	800416e <HAL_TIM_MspPostInit+0x12>
    PB0     ------> TIM3_CH3
    PB4     ------> TIM3_CH1
    PB5     ------> TIM3_CH2 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800418a:	2302      	movs	r3, #2
    /**TIM3 GPIO Configuration    
    PB0     ------> TIM3_CH3
    PB4     ------> TIM3_CH1
    PB5     ------> TIM3_CH2 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4|GPIO_PIN_5;
 800418c:	2231      	movs	r2, #49	; 0x31
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800418e:	4669      	mov	r1, sp
 8004190:	4808      	ldr	r0, [pc, #32]	; (80041b4 <HAL_TIM_MspPostInit+0x58>)
    PB0     ------> TIM3_CH3
    PB4     ------> TIM3_CH1
    PB5     ------> TIM3_CH2 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8004192:	e88d 000c 	stmia.w	sp, {r2, r3}
    GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 8004196:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8004198:	f7ff fa4a 	bl	8003630 <HAL_GPIO_Init>

    __HAL_AFIO_REMAP_TIM3_PARTIAL();
 800419c:	4a06      	ldr	r2, [pc, #24]	; (80041b8 <HAL_TIM_MspPostInit+0x5c>)
 800419e:	6853      	ldr	r3, [r2, #4]
 80041a0:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 80041a4:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80041a8:	6053      	str	r3, [r2, #4]
 80041aa:	e7e0      	b.n	800416e <HAL_TIM_MspPostInit+0x12>
 80041ac:	40000400 	.word	0x40000400
 80041b0:	40000800 	.word	0x40000800
 80041b4:	40010c00 	.word	0x40010c00
 80041b8:	40010000 	.word	0x40010000

080041bc <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 80041bc:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 80041be:	f7fe ff07 	bl	8002fd0 <vTaskStartScheduler>
  
  return osOK;
}
 80041c2:	2000      	movs	r0, #0
 80041c4:	bd08      	pop	{r3, pc}
 80041c6:	bf00      	nop

080041c8 <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 80041c8:	4602      	mov	r2, r0
 80041ca:	b570      	push	{r4, r5, r6, lr}
/* Convert from CMSIS type osPriority to FreeRTOS priority number */
static unsigned portBASE_TYPE makeFreeRtosPriority (osPriority priority)
{
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
  
  if (priority != osPriorityError) {
 80041cc:	f9b0 4008 	ldrsh.w	r4, [r0, #8]
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 80041d0:	b086      	sub	sp, #24
/* Convert from CMSIS type osPriority to FreeRTOS priority number */
static unsigned portBASE_TYPE makeFreeRtosPriority (osPriority priority)
{
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
  
  if (priority != osPriorityError) {
 80041d2:	2c84      	cmp	r4, #132	; 0x84
    fpriority += (priority - osPriorityIdle);
 80041d4:	bf14      	ite	ne
 80041d6:	1ce5      	addne	r5, r4, #3
extern void xPortSysTickHandler(void);

/* Convert from CMSIS type osPriority to FreeRTOS priority number */
static unsigned portBASE_TYPE makeFreeRtosPriority (osPriority priority)
{
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 80041d8:	2500      	moveq	r5, #0
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
  TaskHandle_t handle;
  
  
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 80041da:	2400      	movs	r4, #0
 80041dc:	ae05      	add	r6, sp, #20
 80041de:	6840      	ldr	r0, [r0, #4]
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 80041e0:	460b      	mov	r3, r1
  TaskHandle_t handle;
  
  
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 80041e2:	6811      	ldr	r1, [r2, #0]
 80041e4:	8a12      	ldrh	r2, [r2, #16]
 80041e6:	9500      	str	r5, [sp, #0]
 80041e8:	9403      	str	r4, [sp, #12]
 80041ea:	9402      	str	r4, [sp, #8]
 80041ec:	9601      	str	r6, [sp, #4]
 80041ee:	f7fe fe1d 	bl	8002e2c <xTaskGenericCreate>
 80041f2:	2801      	cmp	r0, #1
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              &handle) != pdPASS)  {
    return NULL;
 80041f4:	bf14      	ite	ne
 80041f6:	4620      	movne	r0, r4
  }
  
  return handle;
 80041f8:	9805      	ldreq	r0, [sp, #20]
}
 80041fa:	b006      	add	sp, #24
 80041fc:	bd70      	pop	{r4, r5, r6, pc}
 80041fe:	bf00      	nop

08004200 <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 8004200:	b508      	push	{r3, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 8004202:	2800      	cmp	r0, #0
 8004204:	bf08      	it	eq
 8004206:	2001      	moveq	r0, #1
 8004208:	f7ff f820 	bl	800324c <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 800420c:	2000      	movs	r0, #0
 800420e:	bd08      	pop	{r3, pc}

08004210 <osSemaphoreCreate>:
osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)
{
  (void) semaphore_def;
  osSemaphoreId sema;
  
  if (count == 1) {
 8004210:	2901      	cmp	r1, #1
 8004212:	d003      	beq.n	800421c <osSemaphoreCreate+0xc>
    vSemaphoreCreateBinary(sema);
    return sema;
  }

#if (configUSE_COUNTING_SEMAPHORES == 1 )	
  return xSemaphoreCreateCounting(count, 0);
 8004214:	4608      	mov	r0, r1
 8004216:	2100      	movs	r1, #0
 8004218:	f000 b912 	b.w	8004440 <xQueueCreateCountingSemaphore>
* @param count         number of available resources.
* @retval  semaphore ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreCreate shall be consistent in every CMSIS-RTOS.
*/
osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)
{
 800421c:	b510      	push	{r4, lr}
 800421e:	4608      	mov	r0, r1
  (void) semaphore_def;
  osSemaphoreId sema;
  
  if (count == 1) {
    vSemaphoreCreateBinary(sema);
 8004220:	2203      	movs	r2, #3
 8004222:	2100      	movs	r1, #0
 8004224:	f000 f8e4 	bl	80043f0 <xQueueGenericCreate>
 8004228:	4604      	mov	r4, r0
 800422a:	b120      	cbz	r0, 8004236 <osSemaphoreCreate+0x26>
 800422c:	2300      	movs	r3, #0
 800422e:	461a      	mov	r2, r3
 8004230:	4619      	mov	r1, r3
 8004232:	f000 f91b 	bl	800446c <xQueueGenericSend>
#if (configUSE_COUNTING_SEMAPHORES == 1 )	
  return xSemaphoreCreateCounting(count, 0);
#else
  return NULL;
#endif
}
 8004236:	4620      	mov	r0, r4
 8004238:	bd10      	pop	{r4, pc}
 800423a:	bf00      	nop

0800423c <osMessageCreate>:
*/
osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id)
{
  (void) thread_id;
  
  return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
 800423c:	2200      	movs	r2, #0
 800423e:	c803      	ldmia	r0, {r0, r1}
 8004240:	f000 b8d6 	b.w	80043f0 <xQueueGenericCreate>

08004244 <osSystickHandler>:
* @brief  Handles the tick increment
* @param  none.
* @retval none.
*/
void osSystickHandler(void)
{
 8004244:	b508      	push	{r3, lr}

#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
 8004246:	f7ff f93f 	bl	80034c8 <xTaskGetSchedulerState>
 800424a:	2801      	cmp	r0, #1
 800424c:	d003      	beq.n	8004256 <osSystickHandler+0x12>
#endif  /* INCLUDE_xTaskGetSchedulerState */  
    xPortSysTickHandler();
#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  }
#endif  /* INCLUDE_xTaskGetSchedulerState */  
}
 800424e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
  {
#endif  /* INCLUDE_xTaskGetSchedulerState */  
    xPortSysTickHandler();
 8004252:	f000 bb7f 	b.w	8004954 <xPortSysTickHandler>
 8004256:	bd08      	pop	{r3, pc}

08004258 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 8004258:	b538      	push	{r3, r4, r5, lr}
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800425a:	6c03      	ldr	r3, [r0, #64]	; 0x40

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 800425c:	4604      	mov	r4, r0
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800425e:	b93b      	cbnz	r3, 8004270 <prvCopyDataToQueue+0x18>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8004260:	6805      	ldr	r5, [r0, #0]
 8004262:	2d00      	cmp	r5, #0
 8004264:	d030      	beq.n	80042c8 <prvCopyDataToQueue+0x70>
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
 8004266:	2000      	movs	r0, #0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
 8004268:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800426a:	3301      	adds	r3, #1
 800426c:	63a3      	str	r3, [r4, #56]	; 0x38

	return xReturn;
}
 800426e:	bd38      	pop	{r3, r4, r5, pc}
 8004270:	4615      	mov	r5, r2
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8004272:	461a      	mov	r2, r3
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 8004274:	b985      	cbnz	r5, 8004298 <prvCopyDataToQueue+0x40>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8004276:	6880      	ldr	r0, [r0, #8]
 8004278:	f001 fd8a 	bl	8005d90 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800427c:	68a1      	ldr	r1, [r4, #8]
 800427e:	6c23      	ldr	r3, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8004280:	6862      	ldr	r2, [r4, #4]
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8004282:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8004284:	4293      	cmp	r3, r2
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8004286:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8004288:	d3ed      	bcc.n	8004266 <prvCopyDataToQueue+0xe>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800428a:	6823      	ldr	r3, [r4, #0]
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
 800428c:	4628      	mov	r0, r5
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800428e:	60a3      	str	r3, [r4, #8]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
 8004290:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8004292:	3301      	adds	r3, #1
 8004294:	63a3      	str	r3, [r4, #56]	; 0x38

	return xReturn;
}
 8004296:	bd38      	pop	{r3, r4, r5, pc}
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004298:	68c0      	ldr	r0, [r0, #12]
 800429a:	f001 fd79 	bl	8005d90 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 800429e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80042a0:	68e2      	ldr	r2, [r4, #12]
 80042a2:	425b      	negs	r3, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80042a4:	6821      	ldr	r1, [r4, #0]
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80042a6:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80042a8:	428a      	cmp	r2, r1
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80042aa:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80042ac:	d202      	bcs.n	80042b4 <prvCopyDataToQueue+0x5c>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 80042ae:	6862      	ldr	r2, [r4, #4]
 80042b0:	4413      	add	r3, r2
 80042b2:	60e3      	str	r3, [r4, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 80042b4:	2d02      	cmp	r5, #2
 80042b6:	d1d6      	bne.n	8004266 <prvCopyDataToQueue+0xe>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 80042b8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80042ba:	2b00      	cmp	r3, #0
 80042bc:	d0d3      	beq.n	8004266 <prvCopyDataToQueue+0xe>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
 80042be:	6ba3      	ldr	r3, [r4, #56]	; 0x38
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
 80042c0:	2000      	movs	r0, #0
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
 80042c2:	3b01      	subs	r3, #1
 80042c4:	63a3      	str	r3, [r4, #56]	; 0x38
 80042c6:	e7cf      	b.n	8004268 <prvCopyDataToQueue+0x10>
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 80042c8:	6840      	ldr	r0, [r0, #4]
 80042ca:	f7ff f95b 	bl	8003584 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 80042ce:	6065      	str	r5, [r4, #4]
 80042d0:	e7ca      	b.n	8004268 <prvCopyDataToQueue+0x10>
 80042d2:	bf00      	nop

080042d4 <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 80042d4:	6c02      	ldr	r2, [r0, #64]	; 0x40
 80042d6:	b172      	cbz	r2, 80042f6 <prvCopyDataFromQueue+0x22>
 80042d8:	4603      	mov	r3, r0
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 80042da:	b410      	push	{r4}
 80042dc:	4608      	mov	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 80042de:	68d9      	ldr	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 80042e0:	685c      	ldr	r4, [r3, #4]

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 80042e2:	4411      	add	r1, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 80042e4:	42a1      	cmp	r1, r4

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 80042e6:	60d9      	str	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 80042e8:	bf24      	itt	cs
 80042ea:	6819      	ldrcs	r1, [r3, #0]
 80042ec:	60d9      	strcs	r1, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 80042ee:	68d9      	ldr	r1, [r3, #12]
	}
}
 80042f0:	bc10      	pop	{r4}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 80042f2:	f001 bd4d 	b.w	8005d90 <memcpy>
 80042f6:	4770      	bx	lr

080042f8 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 80042f8:	b538      	push	{r3, r4, r5, lr}
 80042fa:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 80042fc:	f000 fad8 	bl	80048b0 <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8004300:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8004302:	2b00      	cmp	r3, #0
 8004304:	dd14      	ble.n	8004330 <prvUnlockQueue+0x38>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004306:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004308:	b193      	cbz	r3, 8004330 <prvUnlockQueue+0x38>
 800430a:	f104 0524 	add.w	r5, r4, #36	; 0x24
 800430e:	e007      	b.n	8004320 <prvUnlockQueue+0x28>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
 8004310:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8004312:	3b01      	subs	r3, #1
 8004314:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8004316:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8004318:	2b00      	cmp	r3, #0
 800431a:	dd09      	ble.n	8004330 <prvUnlockQueue+0x38>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800431c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800431e:	b13b      	cbz	r3, 8004330 <prvUnlockQueue+0x38>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004320:	4628      	mov	r0, r5
 8004322:	f7ff f849 	bl	80033b8 <xTaskRemoveFromEventList>
 8004326:	2800      	cmp	r0, #0
 8004328:	d0f2      	beq.n	8004310 <prvUnlockQueue+0x18>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
 800432a:	f7ff f8c5 	bl	80034b8 <vTaskMissedYield>
 800432e:	e7ef      	b.n	8004310 <prvUnlockQueue+0x18>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
 8004330:	f04f 33ff 	mov.w	r3, #4294967295
 8004334:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 8004336:	f000 fad9 	bl	80048ec <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 800433a:	f000 fab9 	bl	80048b0 <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 800433e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8004340:	2b00      	cmp	r3, #0
 8004342:	dd14      	ble.n	800436e <prvUnlockQueue+0x76>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8004344:	6923      	ldr	r3, [r4, #16]
 8004346:	b193      	cbz	r3, 800436e <prvUnlockQueue+0x76>
 8004348:	f104 0510 	add.w	r5, r4, #16
 800434c:	e007      	b.n	800435e <prvUnlockQueue+0x66>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
 800434e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8004350:	3b01      	subs	r3, #1
 8004352:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8004354:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8004356:	2b00      	cmp	r3, #0
 8004358:	dd09      	ble.n	800436e <prvUnlockQueue+0x76>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800435a:	6923      	ldr	r3, [r4, #16]
 800435c:	b13b      	cbz	r3, 800436e <prvUnlockQueue+0x76>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800435e:	4628      	mov	r0, r5
 8004360:	f7ff f82a 	bl	80033b8 <xTaskRemoveFromEventList>
 8004364:	2800      	cmp	r0, #0
 8004366:	d0f2      	beq.n	800434e <prvUnlockQueue+0x56>
				{
					vTaskMissedYield();
 8004368:	f7ff f8a6 	bl	80034b8 <vTaskMissedYield>
 800436c:	e7ef      	b.n	800434e <prvUnlockQueue+0x56>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 800436e:	f04f 33ff 	mov.w	r3, #4294967295
 8004372:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
}
 8004374:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
	}
	taskEXIT_CRITICAL();
 8004378:	f000 bab8 	b.w	80048ec <vPortExitCritical>

0800437c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 800437c:	b570      	push	{r4, r5, r6, lr}
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 800437e:	2800      	cmp	r0, #0
 8004380:	d033      	beq.n	80043ea <xQueueGenericReset+0x6e>
 8004382:	4604      	mov	r4, r0
 8004384:	460e      	mov	r6, r1

	taskENTER_CRITICAL();
 8004386:	f000 fa93 	bl	80048b0 <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800438a:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800438c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800438e:	6820      	ldr	r0, [r4, #0]
 8004390:	fb03 f302 	mul.w	r3, r3, r2
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8004394:	1a9a      	subs	r2, r3, r2
		pxQueue->xRxLock = queueUNLOCKED;
 8004396:	f04f 35ff 	mov.w	r5, #4294967295
	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 800439a:	4402      	add	r2, r0

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800439c:	4403      	add	r3, r0
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800439e:	2100      	movs	r1, #0
 80043a0:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 80043a2:	60e2      	str	r2, [r4, #12]
		pxQueue->xRxLock = queueUNLOCKED;
 80043a4:	6465      	str	r5, [r4, #68]	; 0x44

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 80043a6:	6063      	str	r3, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
 80043a8:	60a0      	str	r0, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->xRxLock = queueUNLOCKED;
		pxQueue->xTxLock = queueUNLOCKED;
 80043aa:	64a5      	str	r5, [r4, #72]	; 0x48

		if( xNewQueue == pdFALSE )
 80043ac:	b98e      	cbnz	r6, 80043d2 <xQueueGenericReset+0x56>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80043ae:	6923      	ldr	r3, [r4, #16]
 80043b0:	b91b      	cbnz	r3, 80043ba <xQueueGenericReset+0x3e>
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
		}
	}
	taskEXIT_CRITICAL();
 80043b2:	f000 fa9b 	bl	80048ec <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
 80043b6:	2001      	movs	r0, #1
 80043b8:	bd70      	pop	{r4, r5, r6, pc}
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 80043ba:	f104 0010 	add.w	r0, r4, #16
 80043be:	f7fe fffb 	bl	80033b8 <xTaskRemoveFromEventList>
 80043c2:	2801      	cmp	r0, #1
 80043c4:	d1f5      	bne.n	80043b2 <xQueueGenericReset+0x36>
				{
					queueYIELD_IF_USING_PREEMPTION();
 80043c6:	f000 fa51 	bl	800486c <vPortYield>
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
		}
	}
	taskEXIT_CRITICAL();
 80043ca:	f000 fa8f 	bl	80048ec <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
 80043ce:	2001      	movs	r0, #1
 80043d0:	bd70      	pop	{r4, r5, r6, pc}
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80043d2:	f104 0010 	add.w	r0, r4, #16
 80043d6:	f7ff fd87 	bl	8003ee8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 80043da:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80043de:	f7ff fd83 	bl	8003ee8 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 80043e2:	f000 fa83 	bl	80048ec <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
 80043e6:	2001      	movs	r0, #1
 80043e8:	bd70      	pop	{r4, r5, r6, pc}

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 80043ea:	f000 fa4b 	bl	8004884 <ulPortSetInterruptMask>
 80043ee:	e7fe      	b.n	80043ee <xQueueGenericReset+0x72>

080043f0 <xQueueGenericCreate>:
	return pdPASS;
}
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
 80043f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 80043f2:	b1b8      	cbz	r0, 8004424 <xQueueGenericCreate+0x34>
 80043f4:	460e      	mov	r6, r1
 80043f6:	4617      	mov	r7, r2
 80043f8:	4605      	mov	r5, r0

	if( uxItemSize == ( UBaseType_t ) 0 )
 80043fa:	b1b1      	cbz	r1, 800442a <xQueueGenericCreate+0x3a>
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}

	/* Allocate the new queue structure and storage area. */
	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 80043fc:	fb01 f000 	mul.w	r0, r1, r0
 8004400:	3055      	adds	r0, #85	; 0x55
 8004402:	f001 fbfd 	bl	8005c00 <pvPortMalloc>

	if( pcAllocatedBuffer != NULL )
 8004406:	4604      	mov	r4, r0
 8004408:	b1b0      	cbz	r0, 8004438 <xQueueGenericCreate+0x48>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area - adding the padding bytes to get a better alignment. */
			pxNewQueue->pcHead = pcAllocatedBuffer + sizeof( Queue_t );
 800440a:	f100 0354 	add.w	r3, r0, #84	; 0x54
 800440e:	6003      	str	r3, [r0, #0]
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
 8004410:	63e5      	str	r5, [r4, #60]	; 0x3c
		pxNewQueue->uxItemSize = uxItemSize;
 8004412:	6426      	str	r6, [r4, #64]	; 0x40
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8004414:	2101      	movs	r1, #1
 8004416:	4620      	mov	r0, r4
 8004418:	f7ff ffb0 	bl	800437c <xQueueGenericReset>

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			pxNewQueue->ucQueueType = ucQueueType;
 800441c:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
	}

	configASSERT( xReturn );

	return xReturn;
}
 8004420:	4620      	mov	r0, r4
 8004422:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8004424:	f000 fa2e 	bl	8004884 <ulPortSetInterruptMask>
 8004428:	e7fe      	b.n	8004428 <xQueueGenericCreate+0x38>
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}

	/* Allocate the new queue structure and storage area. */
	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 800442a:	2054      	movs	r0, #84	; 0x54
 800442c:	f001 fbe8 	bl	8005c00 <pvPortMalloc>

	if( pcAllocatedBuffer != NULL )
 8004430:	4604      	mov	r4, r0
 8004432:	b108      	cbz	r0, 8004438 <xQueueGenericCreate+0x48>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8004434:	6024      	str	r4, [r4, #0]
 8004436:	e7eb      	b.n	8004410 <xQueueGenericCreate+0x20>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
 8004438:	f000 fa24 	bl	8004884 <ulPortSetInterruptMask>
 800443c:	e7fe      	b.n	800443c <xQueueGenericCreate+0x4c>
 800443e:	bf00      	nop

08004440 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
 8004440:	b510      	push	{r4, lr}
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
 8004442:	b160      	cbz	r0, 800445e <xQueueCreateCountingSemaphore+0x1e>
		configASSERT( uxInitialCount <= uxMaxCount );
 8004444:	4288      	cmp	r0, r1
 8004446:	460c      	mov	r4, r1
 8004448:	d202      	bcs.n	8004450 <xQueueCreateCountingSemaphore+0x10>
 800444a:	f000 fa1b 	bl	8004884 <ulPortSetInterruptMask>
 800444e:	e7fe      	b.n	800444e <xQueueCreateCountingSemaphore+0xe>

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 8004450:	2202      	movs	r2, #2
 8004452:	2100      	movs	r1, #0
 8004454:	f7ff ffcc 	bl	80043f0 <xQueueGenericCreate>

		if( xHandle != NULL )
 8004458:	b120      	cbz	r0, 8004464 <xQueueCreateCountingSemaphore+0x24>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 800445a:	6384      	str	r4, [r0, #56]	; 0x38
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
		return xHandle;
 800445c:	bd10      	pop	{r4, pc}

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
 800445e:	f000 fa11 	bl	8004884 <ulPortSetInterruptMask>
 8004462:	e7fe      	b.n	8004462 <xQueueCreateCountingSemaphore+0x22>
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
 8004464:	f000 fa0e 	bl	8004884 <ulPortSetInterruptMask>
 8004468:	e7fe      	b.n	8004468 <xQueueCreateCountingSemaphore+0x28>
 800446a:	bf00      	nop

0800446c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 800446c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004470:	b085      	sub	sp, #20
 8004472:	9201      	str	r2, [sp, #4]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 8004474:	2800      	cmp	r0, #0
 8004476:	d05f      	beq.n	8004538 <xQueueGenericSend+0xcc>
 8004478:	4689      	mov	r9, r1
 800447a:	461f      	mov	r7, r3
 800447c:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800447e:	2900      	cmp	r1, #0
 8004480:	d07d      	beq.n	800457e <xQueueGenericSend+0x112>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8004482:	2f02      	cmp	r7, #2
 8004484:	d03f      	beq.n	8004506 <xQueueGenericSend+0x9a>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8004486:	f7ff f81f 	bl	80034c8 <xTaskGetSchedulerState>
 800448a:	2800      	cmp	r0, #0
 800448c:	d152      	bne.n	8004534 <xQueueGenericSend+0xc8>
 800448e:	9e01      	ldr	r6, [sp, #4]
 8004490:	2e00      	cmp	r6, #0
 8004492:	d171      	bne.n	8004578 <xQueueGenericSend+0x10c>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
 8004494:	f04f 0800 	mov.w	r8, #0
 8004498:	e025      	b.n	80044e6 <xQueueGenericSend+0x7a>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 800449a:	f000 fa27 	bl	80048ec <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 800449e:	f7fe fdc5 	bl	800302c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80044a2:	f000 fa05 	bl	80048b0 <vPortEnterCritical>
 80044a6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80044a8:	3301      	adds	r3, #1
 80044aa:	bf08      	it	eq
 80044ac:	f8c4 8044 	streq.w	r8, [r4, #68]	; 0x44
 80044b0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80044b2:	3301      	adds	r3, #1
 80044b4:	bf08      	it	eq
 80044b6:	f8c4 8048 	streq.w	r8, [r4, #72]	; 0x48
 80044ba:	f000 fa17 	bl	80048ec <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80044be:	a901      	add	r1, sp, #4
 80044c0:	a802      	add	r0, sp, #8
 80044c2:	f7fe ffc1 	bl	8003448 <xTaskCheckForTimeOut>
 80044c6:	2800      	cmp	r0, #0
 80044c8:	d139      	bne.n	800453e <xQueueGenericSend+0xd2>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 80044ca:	f000 f9f1 	bl	80048b0 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 80044ce:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80044d0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80044d2:	429a      	cmp	r2, r3
 80044d4:	d01d      	beq.n	8004512 <xQueueGenericSend+0xa6>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 80044d6:	f000 fa09 	bl	80048ec <vPortExitCritical>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 80044da:	4620      	mov	r0, r4
 80044dc:	f7ff ff0c 	bl	80042f8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80044e0:	f7fe fe46 	bl	8003170 <xTaskResumeAll>
 80044e4:	2601      	movs	r6, #1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 80044e6:	f000 f9e3 	bl	80048b0 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80044ea:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80044ec:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80044ee:	429a      	cmp	r2, r3
 80044f0:	d334      	bcc.n	800455c <xQueueGenericSend+0xf0>
 80044f2:	2f02      	cmp	r7, #2
 80044f4:	d032      	beq.n	800455c <xQueueGenericSend+0xf0>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 80044f6:	9d01      	ldr	r5, [sp, #4]
 80044f8:	b355      	cbz	r5, 8004550 <xQueueGenericSend+0xe4>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
 80044fa:	2e00      	cmp	r6, #0
 80044fc:	d1cd      	bne.n	800449a <xQueueGenericSend+0x2e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 80044fe:	a802      	add	r0, sp, #8
 8004500:	f7fe ff92 	bl	8003428 <vTaskSetTimeOutState>
 8004504:	e7c9      	b.n	800449a <xQueueGenericSend+0x2e>
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8004506:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004508:	2b01      	cmp	r3, #1
 800450a:	d0bc      	beq.n	8004486 <xQueueGenericSend+0x1a>
 800450c:	f000 f9ba 	bl	8004884 <ulPortSetInterruptMask>
 8004510:	e7fe      	b.n	8004510 <xQueueGenericSend+0xa4>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8004512:	f000 f9eb 	bl	80048ec <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8004516:	9901      	ldr	r1, [sp, #4]
 8004518:	f104 0010 	add.w	r0, r4, #16
 800451c:	f7fe fef4 	bl	8003308 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 8004520:	4620      	mov	r0, r4
 8004522:	f7ff fee9 	bl	80042f8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 8004526:	f7fe fe23 	bl	8003170 <xTaskResumeAll>
 800452a:	2800      	cmp	r0, #0
 800452c:	d1da      	bne.n	80044e4 <xQueueGenericSend+0x78>
				{
					portYIELD_WITHIN_API();
 800452e:	f000 f99d 	bl	800486c <vPortYield>
 8004532:	e7d7      	b.n	80044e4 <xQueueGenericSend+0x78>
 8004534:	2600      	movs	r6, #0
 8004536:	e7ad      	b.n	8004494 <xQueueGenericSend+0x28>
{
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 8004538:	f000 f9a4 	bl	8004884 <ulPortSetInterruptMask>
 800453c:	e7fe      	b.n	800453c <xQueueGenericSend+0xd0>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 800453e:	4620      	mov	r0, r4
 8004540:	f7ff feda 	bl	80042f8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8004544:	f7fe fe14 	bl	8003170 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 8004548:	2000      	movs	r0, #0
		}
	}
}
 800454a:	b005      	add	sp, #20
 800454c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			{
				if( xTicksToWait == ( TickType_t ) 0 )
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8004550:	f000 f9cc 	bl	80048ec <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 8004554:	4628      	mov	r0, r5
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
 8004556:	b005      	add	sp, #20
 8004558:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800455c:	463a      	mov	r2, r7
 800455e:	4649      	mov	r1, r9
 8004560:	4620      	mov	r0, r4
 8004562:	f7ff fe79 	bl	8004258 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004566:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004568:	b983      	cbnz	r3, 800458c <xQueueGenericSend+0x120>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 800456a:	b9a8      	cbnz	r0, 8004598 <xQueueGenericSend+0x12c>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 800456c:	f000 f9be 	bl	80048ec <vPortExitCritical>
				return pdPASS;
 8004570:	2001      	movs	r0, #1
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
 8004572:	b005      	add	sp, #20
 8004574:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8004578:	f000 f984 	bl	8004884 <ulPortSetInterruptMask>
 800457c:	e7fe      	b.n	800457c <xQueueGenericSend+0x110>
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800457e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8004580:	2b00      	cmp	r3, #0
 8004582:	f43f af7e 	beq.w	8004482 <xQueueGenericSend+0x16>
 8004586:	f000 f97d 	bl	8004884 <ulPortSetInterruptMask>
 800458a:	e7fe      	b.n	800458a <xQueueGenericSend+0x11e>
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 800458c:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004590:	f7fe ff12 	bl	80033b8 <xTaskRemoveFromEventList>
 8004594:	2801      	cmp	r0, #1
 8004596:	d1e9      	bne.n	800456c <xQueueGenericSend+0x100>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 8004598:	f000 f968 	bl	800486c <vPortYield>
 800459c:	e7e6      	b.n	800456c <xQueueGenericSend+0x100>
 800459e:	bf00      	nop

080045a0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
 80045a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 80045a4:	2800      	cmp	r0, #0
 80045a6:	d036      	beq.n	8004616 <xQueueGenericSendFromISR+0x76>
 80045a8:	460d      	mov	r5, r1
 80045aa:	4617      	mov	r7, r2
 80045ac:	4698      	mov	r8, r3
 80045ae:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80045b0:	2900      	cmp	r1, #0
 80045b2:	d046      	beq.n	8004642 <xQueueGenericSendFromISR+0xa2>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80045b4:	f1b8 0f02 	cmp.w	r8, #2
 80045b8:	d00f      	beq.n	80045da <xQueueGenericSendFromISR+0x3a>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80045ba:	f000 fa3b 	bl	8004a34 <vPortValidateInterruptPriority>
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80045be:	f000 f961 	bl	8004884 <ulPortSetInterruptMask>
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80045c2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80045c4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80045c6:	4606      	mov	r6, r0
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80045c8:	429a      	cmp	r2, r3
 80045ca:	d812      	bhi.n	80045f2 <xQueueGenericSendFromISR+0x52>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 80045cc:	2500      	movs	r5, #0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80045ce:	4630      	mov	r0, r6
 80045d0:	f000 f988 	bl	80048e4 <vPortClearInterruptMask>

	return xReturn;
}
 80045d4:	4628      	mov	r0, r5
 80045d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80045da:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80045dc:	2b01      	cmp	r3, #1
 80045de:	d002      	beq.n	80045e6 <xQueueGenericSendFromISR+0x46>
 80045e0:	f000 f950 	bl	8004884 <ulPortSetInterruptMask>
 80045e4:	e7fe      	b.n	80045e4 <xQueueGenericSendFromISR+0x44>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80045e6:	f000 fa25 	bl	8004a34 <vPortValidateInterruptPriority>
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80045ea:	f000 f94b 	bl	8004884 <ulPortSetInterruptMask>
 80045ee:	4606      	mov	r6, r0
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80045f0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80045f2:	4642      	mov	r2, r8
 80045f4:	4629      	mov	r1, r5
 80045f6:	4620      	mov	r0, r4
 80045f8:	f7ff fe2e 	bl	8004258 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
 80045fc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80045fe:	3301      	adds	r3, #1
 8004600:	d00c      	beq.n	800461c <xQueueGenericSendFromISR+0x7c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 8004602:	6ca3      	ldr	r3, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
 8004604:	2501      	movs	r5, #1
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 8004606:	442b      	add	r3, r5
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8004608:	4630      	mov	r0, r6
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 800460a:	64a3      	str	r3, [r4, #72]	; 0x48
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800460c:	f000 f96a 	bl	80048e4 <vPortClearInterruptMask>

	return xReturn;
}
 8004610:	4628      	mov	r0, r5
 8004612:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 8004616:	f000 f935 	bl	8004884 <ulPortSetInterruptMask>
 800461a:	e7fe      	b.n	800461a <xQueueGenericSendFromISR+0x7a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800461c:	6a63      	ldr	r3, [r4, #36]	; 0x24
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 800461e:	2501      	movs	r5, #1
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004620:	2b00      	cmp	r3, #0
 8004622:	d0d4      	beq.n	80045ce <xQueueGenericSendFromISR+0x2e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004624:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004628:	f7fe fec6 	bl	80033b8 <xTaskRemoveFromEventList>
 800462c:	2800      	cmp	r0, #0
 800462e:	d0ce      	beq.n	80045ce <xQueueGenericSendFromISR+0x2e>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 8004630:	2f00      	cmp	r7, #0
 8004632:	d0cc      	beq.n	80045ce <xQueueGenericSendFromISR+0x2e>
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8004634:	4630      	mov	r0, r6
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 8004636:	603d      	str	r5, [r7, #0]
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8004638:	f000 f954 	bl	80048e4 <vPortClearInterruptMask>

	return xReturn;
}
 800463c:	4628      	mov	r0, r5
 800463e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004642:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8004644:	2b00      	cmp	r3, #0
 8004646:	d0b5      	beq.n	80045b4 <xQueueGenericSendFromISR+0x14>
 8004648:	f000 f91c 	bl	8004884 <ulPortSetInterruptMask>
 800464c:	e7fe      	b.n	800464c <xQueueGenericSendFromISR+0xac>
 800464e:	bf00      	nop

08004650 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
 8004650:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004654:	b085      	sub	sp, #20
 8004656:	9201      	str	r2, [sp, #4]
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 8004658:	2800      	cmp	r0, #0
 800465a:	d052      	beq.n	8004702 <xQueueGenericReceive+0xb2>
 800465c:	4688      	mov	r8, r1
 800465e:	4699      	mov	r9, r3
 8004660:	4604      	mov	r4, r0
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004662:	2900      	cmp	r1, #0
 8004664:	f000 8093 	beq.w	800478e <xQueueGenericReceive+0x13e>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8004668:	f7fe ff2e 	bl	80034c8 <xTaskGetSchedulerState>
 800466c:	b920      	cbnz	r0, 8004678 <xQueueGenericReceive+0x28>
 800466e:	9e01      	ldr	r6, [sp, #4]
 8004670:	b11e      	cbz	r6, 800467a <xQueueGenericReceive+0x2a>
 8004672:	f000 f907 	bl	8004884 <ulPortSetInterruptMask>
 8004676:	e7fe      	b.n	8004676 <xQueueGenericReceive+0x26>
 8004678:	2600      	movs	r6, #0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
 800467a:	2700      	movs	r7, #0
 800467c:	e007      	b.n	800468e <xQueueGenericReceive+0x3e>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 800467e:	f000 f935 	bl	80048ec <vPortExitCritical>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 8004682:	4620      	mov	r0, r4
 8004684:	f7ff fe38 	bl	80042f8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8004688:	f7fe fd72 	bl	8003170 <xTaskResumeAll>
 800468c:	2601      	movs	r6, #1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 800468e:	f000 f90f 	bl	80048b0 <vPortEnterCritical>
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 8004692:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8004694:	2b00      	cmp	r3, #0
 8004696:	d14e      	bne.n	8004736 <xQueueGenericReceive+0xe6>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 8004698:	9d01      	ldr	r5, [sp, #4]
 800469a:	2d00      	cmp	r5, #0
 800469c:	d045      	beq.n	800472a <xQueueGenericReceive+0xda>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
 800469e:	b366      	cbz	r6, 80046fa <xQueueGenericReceive+0xaa>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 80046a0:	f000 f924 	bl	80048ec <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 80046a4:	f7fe fcc2 	bl	800302c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80046a8:	f000 f902 	bl	80048b0 <vPortEnterCritical>
 80046ac:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80046ae:	3301      	adds	r3, #1
 80046b0:	bf08      	it	eq
 80046b2:	6467      	streq	r7, [r4, #68]	; 0x44
 80046b4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80046b6:	3301      	adds	r3, #1
 80046b8:	bf08      	it	eq
 80046ba:	64a7      	streq	r7, [r4, #72]	; 0x48
 80046bc:	f000 f916 	bl	80048ec <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80046c0:	a901      	add	r1, sp, #4
 80046c2:	a802      	add	r0, sp, #8
 80046c4:	f7fe fec0 	bl	8003448 <xTaskCheckForTimeOut>
 80046c8:	bb30      	cbnz	r0, 8004718 <xQueueGenericReceive+0xc8>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 80046ca:	f000 f8f1 	bl	80048b0 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 80046ce:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80046d0:	2b00      	cmp	r3, #0
 80046d2:	d1d4      	bne.n	800467e <xQueueGenericReceive+0x2e>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 80046d4:	f000 f90a 	bl	80048ec <vPortExitCritical>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80046d8:	6823      	ldr	r3, [r4, #0]
 80046da:	b1ab      	cbz	r3, 8004708 <xQueueGenericReceive+0xb8>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80046dc:	9901      	ldr	r1, [sp, #4]
 80046de:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80046e2:	f7fe fe11 	bl	8003308 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 80046e6:	4620      	mov	r0, r4
 80046e8:	f7ff fe06 	bl	80042f8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 80046ec:	f7fe fd40 	bl	8003170 <xTaskResumeAll>
 80046f0:	2800      	cmp	r0, #0
 80046f2:	d1cb      	bne.n	800468c <xQueueGenericReceive+0x3c>
				{
					portYIELD_WITHIN_API();
 80046f4:	f000 f8ba 	bl	800486c <vPortYield>
 80046f8:	e7c8      	b.n	800468c <xQueueGenericReceive+0x3c>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 80046fa:	a802      	add	r0, sp, #8
 80046fc:	f7fe fe94 	bl	8003428 <vTaskSetTimeOutState>
 8004700:	e7ce      	b.n	80046a0 <xQueueGenericReceive+0x50>
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
 8004702:	f000 f8bf 	bl	8004884 <ulPortSetInterruptMask>
 8004706:	e7fe      	b.n	8004706 <xQueueGenericReceive+0xb6>

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
					{
						taskENTER_CRITICAL();
 8004708:	f000 f8d2 	bl	80048b0 <vPortEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 800470c:	6860      	ldr	r0, [r4, #4]
 800470e:	f7fe feeb 	bl	80034e8 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
 8004712:	f000 f8eb 	bl	80048ec <vPortExitCritical>
 8004716:	e7e1      	b.n	80046dc <xQueueGenericReceive+0x8c>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 8004718:	4620      	mov	r0, r4
 800471a:	f7ff fded 	bl	80042f8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800471e:	f7fe fd27 	bl	8003170 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
 8004722:	2000      	movs	r0, #0
		}
	}
}
 8004724:	b005      	add	sp, #20
 8004726:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			{
				if( xTicksToWait == ( TickType_t ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 800472a:	f000 f8df 	bl	80048ec <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 800472e:	4628      	mov	r0, r5
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
 8004730:	b005      	add	sp, #20
 8004732:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8004736:	4641      	mov	r1, r8
 8004738:	4620      	mov	r0, r4
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 800473a:	68e5      	ldr	r5, [r4, #12]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800473c:	f7ff fdca 	bl	80042d4 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
 8004740:	f1b9 0f00 	cmp.w	r9, #0
 8004744:	d10f      	bne.n	8004766 <xQueueGenericReceive+0x116>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
 8004746:	6ba3      	ldr	r3, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8004748:	6822      	ldr	r2, [r4, #0]
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
 800474a:	3b01      	subs	r3, #1
 800474c:	63a3      	str	r3, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800474e:	b912      	cbnz	r2, 8004756 <xQueueGenericReceive+0x106>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 8004750:	f7fe ff60 	bl	8003614 <pvTaskIncrementMutexHeldCount>
 8004754:	6060      	str	r0, [r4, #4]
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8004756:	6923      	ldr	r3, [r4, #16]
 8004758:	b993      	cbnz	r3, 8004780 <xQueueGenericReceive+0x130>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
 800475a:	f000 f8c7 	bl	80048ec <vPortExitCritical>
				return pdPASS;
 800475e:	2001      	movs	r0, #1
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
 8004760:	b005      	add	sp, #20
 8004762:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004766:	6a63      	ldr	r3, [r4, #36]	; 0x24
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 8004768:	60e5      	str	r5, [r4, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800476a:	2b00      	cmp	r3, #0
 800476c:	d0f5      	beq.n	800475a <xQueueGenericReceive+0x10a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800476e:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004772:	f7fe fe21 	bl	80033b8 <xTaskRemoveFromEventList>
 8004776:	2800      	cmp	r0, #0
 8004778:	d0ef      	beq.n	800475a <xQueueGenericReceive+0x10a>

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
						{
							queueYIELD_IF_USING_PREEMPTION();
 800477a:	f000 f877 	bl	800486c <vPortYield>
 800477e:	e7ec      	b.n	800475a <xQueueGenericReceive+0x10a>
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 8004780:	f104 0010 	add.w	r0, r4, #16
 8004784:	f7fe fe18 	bl	80033b8 <xTaskRemoveFromEventList>
 8004788:	2801      	cmp	r0, #1
 800478a:	d1e6      	bne.n	800475a <xQueueGenericReceive+0x10a>
 800478c:	e7f5      	b.n	800477a <xQueueGenericReceive+0x12a>
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800478e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8004790:	2b00      	cmp	r3, #0
 8004792:	f43f af69 	beq.w	8004668 <xQueueGenericReceive+0x18>
 8004796:	f000 f875 	bl	8004884 <ulPortSetInterruptMask>
 800479a:	e7fe      	b.n	800479a <xQueueGenericReceive+0x14a>

0800479c <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 800479c:	b470      	push	{r4, r5, r6}
 800479e:	4a09      	ldr	r2, [pc, #36]	; (80047c4 <vQueueAddToRegistry+0x28>)
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80047a0:	2300      	movs	r3, #0
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 80047a2:	f852 4033 	ldr.w	r4, [r2, r3, lsl #3]
 80047a6:	4e07      	ldr	r6, [pc, #28]	; (80047c4 <vQueueAddToRegistry+0x28>)
 80047a8:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
 80047ac:	b124      	cbz	r4, 80047b8 <vQueueAddToRegistry+0x1c>
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80047ae:	3301      	adds	r3, #1
 80047b0:	2b08      	cmp	r3, #8
 80047b2:	d1f6      	bne.n	80047a2 <vQueueAddToRegistry+0x6>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 80047b4:	bc70      	pop	{r4, r5, r6}
 80047b6:	4770      	bx	lr
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 80047b8:	f846 1033 	str.w	r1, [r6, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 80047bc:	6068      	str	r0, [r5, #4]
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 80047be:	bc70      	pop	{r4, r5, r6}
 80047c0:	4770      	bx	lr
 80047c2:	bf00      	nop
 80047c4:	200024ac 	.word	0x200024ac

080047c8 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
	{
 80047c8:	b538      	push	{r3, r4, r5, lr}
 80047ca:	4604      	mov	r4, r0
 80047cc:	460d      	mov	r5, r1
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 80047ce:	f000 f86f 	bl	80048b0 <vPortEnterCritical>
 80047d2:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80047d4:	3301      	adds	r3, #1
 80047d6:	bf04      	itt	eq
 80047d8:	2300      	moveq	r3, #0
 80047da:	6463      	streq	r3, [r4, #68]	; 0x44
 80047dc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80047de:	3301      	adds	r3, #1
 80047e0:	bf04      	itt	eq
 80047e2:	2300      	moveq	r3, #0
 80047e4:	64a3      	streq	r3, [r4, #72]	; 0x48
 80047e6:	f000 f881 	bl	80048ec <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 80047ea:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80047ec:	b923      	cbnz	r3, 80047f8 <vQueueWaitForMessageRestricted+0x30>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80047ee:	4629      	mov	r1, r5
 80047f0:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80047f4:	f7fe fdba 	bl	800336c <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 80047f8:	4620      	mov	r0, r4
	}
 80047fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 80047fe:	f7ff bd7b 	b.w	80042f8 <prvUnlockQueue>
 8004802:	bf00      	nop

08004804 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8004804:	4806      	ldr	r0, [pc, #24]	; (8004820 <prvPortStartFirstTask+0x1c>)
 8004806:	6800      	ldr	r0, [r0, #0]
 8004808:	6800      	ldr	r0, [r0, #0]
 800480a:	f380 8808 	msr	MSP, r0
 800480e:	b662      	cpsie	i
 8004810:	b661      	cpsie	f
 8004812:	f3bf 8f4f 	dsb	sy
 8004816:	f3bf 8f6f 	isb	sy
 800481a:	df00      	svc	0
 800481c:	bf00      	nop
 800481e:	0000      	.short	0x0000
 8004820:	e000ed08 	.word	0xe000ed08

08004824 <pxPortInitialiseStack>:
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8004824:	4b07      	ldr	r3, [pc, #28]	; (8004844 <pxPortInitialiseStack+0x20>)

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
 8004826:	b410      	push	{r4}
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8004828:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
 800482c:	f840 4c04 	str.w	r4, [r0, #-4]
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
 8004830:	f840 1c08 	str.w	r1, [r0, #-8]
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8004834:	f840 2c20 	str.w	r2, [r0, #-32]
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8004838:	f840 3c0c 	str.w	r3, [r0, #-12]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */

	return pxTopOfStack;
}
 800483c:	bc10      	pop	{r4}
 800483e:	3840      	subs	r0, #64	; 0x40
 8004840:	4770      	bx	lr
 8004842:	bf00      	nop
 8004844:	08004895 	.word	0x08004895

08004848 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8004848:	4b07      	ldr	r3, [pc, #28]	; (8004868 <pxCurrentTCBConst2>)
 800484a:	6819      	ldr	r1, [r3, #0]
 800484c:	6808      	ldr	r0, [r1, #0]
 800484e:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004852:	f380 8809 	msr	PSP, r0
 8004856:	f3bf 8f6f 	isb	sy
 800485a:	f04f 0000 	mov.w	r0, #0
 800485e:	f380 8811 	msr	BASEPRI, r0
 8004862:	f04e 0e0d 	orr.w	lr, lr, #13
 8004866:	4770      	bx	lr

08004868 <pxCurrentTCBConst2>:
 8004868:	20000a6c 	.word	0x20000a6c

0800486c <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 800486c:	4b04      	ldr	r3, [pc, #16]	; (8004880 <vPortYield+0x14>)
 800486e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004872:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
 8004874:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 8004878:	f3bf 8f6f 	isb	sy
 800487c:	4770      	bx	lr
 800487e:	bf00      	nop
 8004880:	e000ed04 	.word	0xe000ed04

08004884 <ulPortSetInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) uint32_t ulPortSetInterruptMask( void )
{
	__asm volatile														\
 8004884:	f3ef 8011 	mrs	r0, BASEPRI
 8004888:	f04f 0150 	mov.w	r1, #80	; 0x50
 800488c:	f381 8811 	msr	BASEPRI, r1
 8004890:	4770      	bx	lr
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
}
 8004892:	2000      	movs	r0, #0

08004894 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8004894:	b508      	push	{r3, lr}
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8004896:	4b05      	ldr	r3, [pc, #20]	; (80048ac <prvTaskExitError+0x18>)
 8004898:	681b      	ldr	r3, [r3, #0]
 800489a:	3301      	adds	r3, #1
 800489c:	d002      	beq.n	80048a4 <prvTaskExitError+0x10>
 800489e:	f7ff fff1 	bl	8004884 <ulPortSetInterruptMask>
 80048a2:	e7fe      	b.n	80048a2 <prvTaskExitError+0xe>
	portDISABLE_INTERRUPTS();
 80048a4:	f7ff ffee 	bl	8004884 <ulPortSetInterruptMask>
 80048a8:	e7fe      	b.n	80048a8 <prvTaskExitError+0x14>
 80048aa:	bf00      	nop
 80048ac:	20000470 	.word	0x20000470

080048b0 <vPortEnterCritical>:
	__asm volatile( "isb" );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 80048b0:	b508      	push	{r3, lr}
	portDISABLE_INTERRUPTS();
 80048b2:	f7ff ffe7 	bl	8004884 <ulPortSetInterruptMask>
	uxCriticalNesting++;
 80048b6:	4a09      	ldr	r2, [pc, #36]	; (80048dc <vPortEnterCritical+0x2c>)
 80048b8:	6813      	ldr	r3, [r2, #0]
 80048ba:	3301      	adds	r3, #1
 80048bc:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" );
 80048be:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 80048c2:	f3bf 8f6f 	isb	sy
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API 
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
 80048c6:	2b01      	cmp	r3, #1
 80048c8:	d000      	beq.n	80048cc <vPortEnterCritical+0x1c>
 80048ca:	bd08      	pop	{r3, pc}
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 80048cc:	4b04      	ldr	r3, [pc, #16]	; (80048e0 <vPortEnterCritical+0x30>)
 80048ce:	681b      	ldr	r3, [r3, #0]
 80048d0:	f013 0fff 	tst.w	r3, #255	; 0xff
 80048d4:	d0f9      	beq.n	80048ca <vPortEnterCritical+0x1a>
 80048d6:	f7ff ffd5 	bl	8004884 <ulPortSetInterruptMask>
 80048da:	e7fe      	b.n	80048da <vPortEnterCritical+0x2a>
 80048dc:	20000470 	.word	0x20000470
 80048e0:	e000ed04 	.word	0xe000ed04

080048e4 <vPortClearInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( uint32_t ulNewMaskValue )
{
	__asm volatile													\
 80048e4:	f380 8811 	msr	BASEPRI, r0
 80048e8:	4770      	bx	lr
 80048ea:	bf00      	nop

080048ec <vPortExitCritical>:
	}
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 80048ec:	b508      	push	{r3, lr}
	configASSERT( uxCriticalNesting );
 80048ee:	4b07      	ldr	r3, [pc, #28]	; (800490c <vPortExitCritical+0x20>)
 80048f0:	6818      	ldr	r0, [r3, #0]
 80048f2:	b118      	cbz	r0, 80048fc <vPortExitCritical+0x10>
	uxCriticalNesting--;
 80048f4:	3801      	subs	r0, #1
 80048f6:	6018      	str	r0, [r3, #0]
	if( uxCriticalNesting == 0 )
 80048f8:	b118      	cbz	r0, 8004902 <vPortExitCritical+0x16>
 80048fa:	bd08      	pop	{r3, pc}
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
 80048fc:	f7ff ffc2 	bl	8004884 <ulPortSetInterruptMask>
 8004900:	e7fe      	b.n	8004900 <vPortExitCritical+0x14>
	uxCriticalNesting--;
	if( uxCriticalNesting == 0 )
	{
		portENABLE_INTERRUPTS();
	}
}
 8004902:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
	configASSERT( uxCriticalNesting );
	uxCriticalNesting--;
	if( uxCriticalNesting == 0 )
	{
		portENABLE_INTERRUPTS();
 8004906:	f7ff bfed 	b.w	80048e4 <vPortClearInterruptMask>
 800490a:	bf00      	nop
 800490c:	20000470 	.word	0x20000470

08004910 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8004910:	f3ef 8009 	mrs	r0, PSP
 8004914:	f3bf 8f6f 	isb	sy
 8004918:	4b0d      	ldr	r3, [pc, #52]	; (8004950 <pxCurrentTCBConst>)
 800491a:	681a      	ldr	r2, [r3, #0]
 800491c:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004920:	6010      	str	r0, [r2, #0]
 8004922:	e92d 4008 	stmdb	sp!, {r3, lr}
 8004926:	f04f 0050 	mov.w	r0, #80	; 0x50
 800492a:	f380 8811 	msr	BASEPRI, r0
 800492e:	f7fe fcbf 	bl	80032b0 <vTaskSwitchContext>
 8004932:	f04f 0000 	mov.w	r0, #0
 8004936:	f380 8811 	msr	BASEPRI, r0
 800493a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800493e:	6819      	ldr	r1, [r3, #0]
 8004940:	6808      	ldr	r0, [r1, #0]
 8004942:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004946:	f380 8809 	msr	PSP, r0
 800494a:	f3bf 8f6f 	isb	sy
 800494e:	4770      	bx	lr

08004950 <pxCurrentTCBConst>:
 8004950:	20000a6c 	.word	0x20000a6c

08004954 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8004954:	b508      	push	{r3, lr}
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
 8004956:	f7ff ff95 	bl	8004884 <ulPortSetInterruptMask>
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 800495a:	f7fe fb77 	bl	800304c <xTaskIncrementTick>
 800495e:	b118      	cbz	r0, 8004968 <xPortSysTickHandler+0x14>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8004960:	4b04      	ldr	r3, [pc, #16]	; (8004974 <xPortSysTickHandler+0x20>)
 8004962:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004966:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 8004968:	2000      	movs	r0, #0
}
 800496a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 800496e:	f7ff bfb9 	b.w	80048e4 <vPortClearInterruptMask>
 8004972:	bf00      	nop
 8004974:	e000ed04 	.word	0xe000ed04

08004978 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8004978:	4b06      	ldr	r3, [pc, #24]	; (8004994 <vPortSetupTimerInterrupt+0x1c>)
 800497a:	4a07      	ldr	r2, [pc, #28]	; (8004998 <vPortSetupTimerInterrupt+0x20>)
 800497c:	681b      	ldr	r3, [r3, #0]
 800497e:	4807      	ldr	r0, [pc, #28]	; (800499c <vPortSetupTimerInterrupt+0x24>)
 8004980:	fba2 2303 	umull	r2, r3, r2, r3
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8004984:	4a06      	ldr	r2, [pc, #24]	; (80049a0 <vPortSetupTimerInterrupt+0x28>)
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8004986:	099b      	lsrs	r3, r3, #6
 8004988:	3b01      	subs	r3, #1
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 800498a:	2107      	movs	r1, #7
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800498c:	6003      	str	r3, [r0, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 800498e:	6011      	str	r1, [r2, #0]
 8004990:	4770      	bx	lr
 8004992:	bf00      	nop
 8004994:	20000000 	.word	0x20000000
 8004998:	10624dd3 	.word	0x10624dd3
 800499c:	e000e014 	.word	0xe000e014
 80049a0:	e000e010 	.word	0xe000e010

080049a4 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 80049a4:	b510      	push	{r4, lr}
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 80049a6:	4b1f      	ldr	r3, [pc, #124]	; (8004a24 <xPortStartScheduler+0x80>)

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 80049a8:	b082      	sub	sp, #8
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 80049aa:	781a      	ldrb	r2, [r3, #0]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 80049ac:	21ff      	movs	r1, #255	; 0xff
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 80049ae:	b2d2      	uxtb	r2, r2
 80049b0:	9201      	str	r2, [sp, #4]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 80049b2:	7019      	strb	r1, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 80049b4:	781b      	ldrb	r3, [r3, #0]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 80049b6:	481c      	ldr	r0, [pc, #112]	; (8004a28 <xPortStartScheduler+0x84>)
		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 80049b8:	b2db      	uxtb	r3, r3
 80049ba:	f88d 3003 	strb.w	r3, [sp, #3]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 80049be:	f89d 3003 	ldrb.w	r3, [sp, #3]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80049c2:	f89d 1003 	ldrb.w	r1, [sp, #3]
		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 80049c6:	2207      	movs	r2, #7

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 80049c8:	f003 0350 	and.w	r3, r3, #80	; 0x50

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80049cc:	0609      	lsls	r1, r1, #24

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 80049ce:	7003      	strb	r3, [r0, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 80049d0:	6042      	str	r2, [r0, #4]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80049d2:	d50d      	bpl.n	80049f0 <xPortStartScheduler+0x4c>
 80049d4:	2206      	movs	r2, #6
 80049d6:	e000      	b.n	80049da <xPortStartScheduler+0x36>
 80049d8:	460a      	mov	r2, r1
		{
			ulMaxPRIGROUPValue--;
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 80049da:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80049de:	1e51      	subs	r1, r2, #1
 80049e0:	005b      	lsls	r3, r3, #1
 80049e2:	b2db      	uxtb	r3, r3
 80049e4:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80049e8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80049ec:	061b      	lsls	r3, r3, #24
 80049ee:	d4f3      	bmi.n	80049d8 <xPortStartScheduler+0x34>
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 80049f0:	9901      	ldr	r1, [sp, #4]
 80049f2:	4c0c      	ldr	r4, [pc, #48]	; (8004a24 <xPortStartScheduler+0x80>)
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 80049f4:	4b0d      	ldr	r3, [pc, #52]	; (8004a2c <xPortStartScheduler+0x88>)
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 80049f6:	b2c9      	uxtb	r1, r1
 80049f8:	7021      	strb	r1, [r4, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 80049fa:	6819      	ldr	r1, [r3, #0]
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 80049fc:	0212      	lsls	r2, r2, #8
		*pucFirstUserPriorityRegister = ulOriginalPriority;
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 80049fe:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8004a02:	6019      	str	r1, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8004a04:	6819      	ldr	r1, [r3, #0]
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8004a06:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8004a0a:	f041 4170 	orr.w	r1, r1, #4026531840	; 0xf0000000
 8004a0e:	6019      	str	r1, [r3, #0]
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8004a10:	6042      	str	r2, [r0, #4]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 8004a12:	f7ff ffb1 	bl	8004978 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8004a16:	4b06      	ldr	r3, [pc, #24]	; (8004a30 <xPortStartScheduler+0x8c>)
 8004a18:	2200      	movs	r2, #0
 8004a1a:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 8004a1c:	f7ff fef2 	bl	8004804 <prvPortStartFirstTask>

	/* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS. */
	prvTaskExitError();
 8004a20:	f7ff ff38 	bl	8004894 <prvTaskExitError>
 8004a24:	e000e400 	.word	0xe000e400
 8004a28:	20000ce8 	.word	0x20000ce8
 8004a2c:	e000ed20 	.word	0xe000ed20
 8004a30:	20000470 	.word	0x20000470

08004a34 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
 8004a34:	b508      	push	{r3, lr}
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 8004a36:	f3ef 8205 	mrs	r2, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8004a3a:	2a0f      	cmp	r2, #15
 8004a3c:	d808      	bhi.n	8004a50 <vPortValidateInterruptPriority+0x1c>
 8004a3e:	4b0a      	ldr	r3, [pc, #40]	; (8004a68 <vPortValidateInterruptPriority+0x34>)
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8004a40:	490a      	ldr	r1, [pc, #40]	; (8004a6c <vPortValidateInterruptPriority+0x38>)
 8004a42:	685a      	ldr	r2, [r3, #4]
 8004a44:	680b      	ldr	r3, [r1, #0]
 8004a46:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8004a4a:	4293      	cmp	r3, r2
 8004a4c:	d809      	bhi.n	8004a62 <vPortValidateInterruptPriority+0x2e>
 8004a4e:	bd08      	pop	{r3, pc}

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8004a50:	4907      	ldr	r1, [pc, #28]	; (8004a70 <vPortValidateInterruptPriority+0x3c>)
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8004a52:	4b05      	ldr	r3, [pc, #20]	; (8004a68 <vPortValidateInterruptPriority+0x34>)

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8004a54:	5c52      	ldrb	r2, [r2, r1]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8004a56:	7819      	ldrb	r1, [r3, #0]
 8004a58:	4291      	cmp	r1, r2
 8004a5a:	d9f1      	bls.n	8004a40 <vPortValidateInterruptPriority+0xc>
 8004a5c:	f7ff ff12 	bl	8004884 <ulPortSetInterruptMask>
 8004a60:	e7fe      	b.n	8004a60 <vPortValidateInterruptPriority+0x2c>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8004a62:	f7ff ff0f 	bl	8004884 <ulPortSetInterruptMask>
 8004a66:	e7fe      	b.n	8004a66 <vPortValidateInterruptPriority+0x32>
 8004a68:	20000ce8 	.word	0x20000ce8
 8004a6c:	e000ed0c 	.word	0xe000ed0c
 8004a70:	e000e3f0 	.word	0xe000e3f0

08004a74 <USBD_CDC_DataIn>:
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  USBD_CDC_DataIn (USBD_HandleTypeDef *pdev, uint8_t epnum)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 8004a74:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  
  if(pdev->pClassData != NULL)
 8004a78:	b11b      	cbz	r3, 8004a82 <USBD_CDC_DataIn+0xe>
  {
    
    hcdc->TxState = 0;
 8004a7a:	2000      	movs	r0, #0
 8004a7c:	f8c3 0214 	str.w	r0, [r3, #532]	; 0x214

    return USBD_OK;
 8004a80:	4770      	bx	lr
  }
  else
  {
    return USBD_FAIL;
 8004a82:	2002      	movs	r0, #2
  }
}
 8004a84:	4770      	bx	lr
 8004a86:	bf00      	nop

08004a88 <USBD_CDC_EP0_RxReady>:
  */
static uint8_t  USBD_CDC_EP0_RxReady (USBD_HandleTypeDef *pdev)
{ 
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  if((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFF))
 8004a88:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  USBD_CDC_EP0_RxReady (USBD_HandleTypeDef *pdev)
{ 
 8004a8c:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 8004a8e:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  
  if((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFF))
 8004a92:	b15b      	cbz	r3, 8004aac <USBD_CDC_EP0_RxReady+0x24>
 8004a94:	f894 0200 	ldrb.w	r0, [r4, #512]	; 0x200
 8004a98:	28ff      	cmp	r0, #255	; 0xff
 8004a9a:	d007      	beq.n	8004aac <USBD_CDC_EP0_RxReady+0x24>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(hcdc->CmdOpCode,
 8004a9c:	689b      	ldr	r3, [r3, #8]
 8004a9e:	f894 2201 	ldrb.w	r2, [r4, #513]	; 0x201
 8004aa2:	4621      	mov	r1, r4
 8004aa4:	4798      	blx	r3
                                                      (uint8_t *)hcdc->data,
                                                      hcdc->CmdLength);
      hcdc->CmdOpCode = 0xFF; 
 8004aa6:	23ff      	movs	r3, #255	; 0xff
 8004aa8:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
      
  }
  return USBD_OK;
}
 8004aac:	2000      	movs	r0, #0
 8004aae:	bd10      	pop	{r4, pc}

08004ab0 <USBD_CDC_GetFSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetFSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_CDC_CfgFSDesc);
 8004ab0:	2343      	movs	r3, #67	; 0x43
 8004ab2:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_CfgFSDesc;
}
 8004ab4:	4800      	ldr	r0, [pc, #0]	; (8004ab8 <USBD_CDC_GetFSCfgDesc+0x8>)
 8004ab6:	4770      	bx	lr
 8004ab8:	20000474 	.word	0x20000474

08004abc <USBD_CDC_GetHSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetHSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_CDC_CfgHSDesc);
 8004abc:	2343      	movs	r3, #67	; 0x43
 8004abe:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_CfgHSDesc;
}
 8004ac0:	4800      	ldr	r0, [pc, #0]	; (8004ac4 <USBD_CDC_GetHSCfgDesc+0x8>)
 8004ac2:	4770      	bx	lr
 8004ac4:	200004b8 	.word	0x200004b8

08004ac8 <USBD_CDC_GetOtherSpeedCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetOtherSpeedCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_CDC_OtherSpeedCfgDesc);
 8004ac8:	2343      	movs	r3, #67	; 0x43
 8004aca:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_OtherSpeedCfgDesc;
}
 8004acc:	4800      	ldr	r0, [pc, #0]	; (8004ad0 <USBD_CDC_GetOtherSpeedCfgDesc+0x8>)
 8004ace:	4770      	bx	lr
 8004ad0:	200004fc 	.word	0x200004fc

08004ad4 <USBD_CDC_GetDeviceQualifierDescriptor>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_CDC_GetDeviceQualifierDescriptor (uint16_t *length)
{
  *length = sizeof (USBD_CDC_DeviceQualifierDesc);
 8004ad4:	230a      	movs	r3, #10
 8004ad6:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_DeviceQualifierDesc;
}
 8004ad8:	4800      	ldr	r0, [pc, #0]	; (8004adc <USBD_CDC_GetDeviceQualifierDescriptor+0x8>)
 8004ada:	4770      	bx	lr
 8004adc:	20000540 	.word	0x20000540

08004ae0 <USBD_CDC_DataOut>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  USBD_CDC_DataOut (USBD_HandleTypeDef *pdev, uint8_t epnum)
{      
 8004ae0:	b538      	push	{r3, r4, r5, lr}
 8004ae2:	4604      	mov	r4, r0
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 8004ae4:	f8d0 5218 	ldr.w	r5, [r0, #536]	; 0x218
  
  /* Get the received data length */
  hcdc->RxLength = USBD_LL_GetRxDataSize (pdev, epnum);
 8004ae8:	f7ff f9f0 	bl	8003ecc <USBD_LL_GetRxDataSize>
  
  /* USB data will be immediately processed, this allow next USB traffic being 
  NAKed till the end of the application Xfer */
  if(pdev->pClassData != NULL)
 8004aec:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
static uint8_t  USBD_CDC_DataOut (USBD_HandleTypeDef *pdev, uint8_t epnum)
{      
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  /* Get the received data length */
  hcdc->RxLength = USBD_LL_GetRxDataSize (pdev, epnum);
 8004af0:	f8c5 020c 	str.w	r0, [r5, #524]	; 0x20c
  
  /* USB data will be immediately processed, this allow next USB traffic being 
  NAKed till the end of the application Xfer */
  if(pdev->pClassData != NULL)
 8004af4:	b14b      	cbz	r3, 8004b0a <USBD_CDC_DataOut+0x2a>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 8004af6:	f8d4 321c 	ldr.w	r3, [r4, #540]	; 0x21c
 8004afa:	f505 7103 	add.w	r1, r5, #524	; 0x20c
 8004afe:	68db      	ldr	r3, [r3, #12]
 8004b00:	f8d5 0204 	ldr.w	r0, [r5, #516]	; 0x204
 8004b04:	4798      	blx	r3

    return USBD_OK;
 8004b06:	2000      	movs	r0, #0
 8004b08:	bd38      	pop	{r3, r4, r5, pc}
  }
  else
  {
    return USBD_FAIL;
 8004b0a:	2002      	movs	r0, #2
  }
}
 8004b0c:	bd38      	pop	{r3, r4, r5, pc}
 8004b0e:	bf00      	nop

08004b10 <USBD_CDC_Setup>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t  USBD_CDC_Setup (USBD_HandleTypeDef *pdev, 
                                USBD_SetupReqTypedef *req)
{
 8004b10:	b570      	push	{r4, r5, r6, lr}
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  static uint8_t ifalt = 0;
    
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8004b12:	780b      	ldrb	r3, [r1, #0]
  * @param  req: usb requests
  * @retval status
  */
static uint8_t  USBD_CDC_Setup (USBD_HandleTypeDef *pdev, 
                                USBD_SetupReqTypedef *req)
{
 8004b14:	460c      	mov	r4, r1
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  static uint8_t ifalt = 0;
    
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8004b16:	f013 0260 	ands.w	r2, r3, #96	; 0x60
 8004b1a:	d014      	beq.n	8004b46 <USBD_CDC_Setup+0x36>
 8004b1c:	2a20      	cmp	r2, #32
 8004b1e:	d110      	bne.n	8004b42 <USBD_CDC_Setup+0x32>
  {
  case USB_REQ_TYPE_CLASS :
    if (req->wLength)
 8004b20:	88ca      	ldrh	r2, [r1, #6]
 8004b22:	4605      	mov	r5, r0
 8004b24:	b322      	cbz	r2, 8004b70 <USBD_CDC_Setup+0x60>
    {
      if (req->bmRequest & 0x80)
 8004b26:	061b      	lsls	r3, r3, #24
  * @retval status
  */
static uint8_t  USBD_CDC_Setup (USBD_HandleTypeDef *pdev, 
                                USBD_SetupReqTypedef *req)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 8004b28:	f8d0 6218 	ldr.w	r6, [r0, #536]	; 0x218
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
  {
  case USB_REQ_TYPE_CLASS :
    if (req->wLength)
    {
      if (req->bmRequest & 0x80)
 8004b2c:	d414      	bmi.n	8004b58 <USBD_CDC_Setup+0x48>
                            (uint8_t *)hcdc->data,
                            req->wLength);
      }
      else
      {
        hcdc->CmdOpCode = req->bRequest;
 8004b2e:	784b      	ldrb	r3, [r1, #1]
        hcdc->CmdLength = req->wLength;
        
        USBD_CtlPrepareRx (pdev, 
 8004b30:	4631      	mov	r1, r6
                            (uint8_t *)hcdc->data,
                            req->wLength);
      }
      else
      {
        hcdc->CmdOpCode = req->bRequest;
 8004b32:	f886 3200 	strb.w	r3, [r6, #512]	; 0x200
        hcdc->CmdLength = req->wLength;
 8004b36:	88e3      	ldrh	r3, [r4, #6]
 8004b38:	f886 3201 	strb.w	r3, [r6, #513]	; 0x201
        
        USBD_CtlPrepareRx (pdev, 
 8004b3c:	88e2      	ldrh	r2, [r4, #6]
 8004b3e:	f001 f8a9 	bl	8005c94 <USBD_CtlPrepareRx>
 
  default: 
    break;
  }
  return USBD_OK;
}
 8004b42:	2000      	movs	r0, #0
 8004b44:	bd70      	pop	{r4, r5, r6, pc}
                                                        0);
    }
    break;

  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
 8004b46:	784b      	ldrb	r3, [r1, #1]
 8004b48:	2b0a      	cmp	r3, #10
 8004b4a:	d1fa      	bne.n	8004b42 <USBD_CDC_Setup+0x32>
    {      
    case USB_REQ_GET_INTERFACE :
      USBD_CtlSendData (pdev,
 8004b4c:	2201      	movs	r2, #1
 8004b4e:	490b      	ldr	r1, [pc, #44]	; (8004b7c <USBD_CDC_Setup+0x6c>)
 8004b50:	f001 f88a 	bl	8005c68 <USBD_CtlSendData>
 
  default: 
    break;
  }
  return USBD_OK;
}
 8004b54:	2000      	movs	r0, #0
 8004b56:	bd70      	pop	{r4, r5, r6, pc}
  case USB_REQ_TYPE_CLASS :
    if (req->wLength)
    {
      if (req->bmRequest & 0x80)
      {
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 8004b58:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
 8004b5c:	4631      	mov	r1, r6
 8004b5e:	689b      	ldr	r3, [r3, #8]
 8004b60:	7860      	ldrb	r0, [r4, #1]
 8004b62:	4798      	blx	r3
                                                          (uint8_t *)hcdc->data,
                                                          req->wLength);
          USBD_CtlSendData (pdev, 
 8004b64:	88e2      	ldrh	r2, [r4, #6]
 8004b66:	4631      	mov	r1, r6
 8004b68:	4628      	mov	r0, r5
 8004b6a:	f001 f87d 	bl	8005c68 <USBD_CtlSendData>
 8004b6e:	e7e8      	b.n	8004b42 <USBD_CDC_Setup+0x32>
      }
      
    }
    else
    {
      ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 8004b70:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
 8004b74:	7848      	ldrb	r0, [r1, #1]
 8004b76:	689b      	ldr	r3, [r3, #8]
 8004b78:	4798      	blx	r3
 8004b7a:	e7e2      	b.n	8004b42 <USBD_CDC_Setup+0x32>
 8004b7c:	20000cf0 	.word	0x20000cf0

08004b80 <USBD_CDC_DeInit>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_CDC_DeInit (USBD_HandleTypeDef *pdev, 
                                 uint8_t cfgidx)
{
 8004b80:	b510      	push	{r4, lr}
 8004b82:	4604      	mov	r4, r0
  uint8_t ret = 0;
  
  /* Open EP IN */
  USBD_LL_CloseEP(pdev,
 8004b84:	2181      	movs	r1, #129	; 0x81
 8004b86:	f7ff f961 	bl	8003e4c <USBD_LL_CloseEP>
              CDC_IN_EP);
  
  /* Open EP OUT */
  USBD_LL_CloseEP(pdev,
 8004b8a:	2101      	movs	r1, #1
 8004b8c:	4620      	mov	r0, r4
 8004b8e:	f7ff f95d 	bl	8003e4c <USBD_LL_CloseEP>
              CDC_OUT_EP);
  
  /* Open Command IN EP */
  USBD_LL_CloseEP(pdev,
 8004b92:	4620      	mov	r0, r4
 8004b94:	2182      	movs	r1, #130	; 0x82
 8004b96:	f7ff f959 	bl	8003e4c <USBD_LL_CloseEP>
              CDC_CMD_EP);
  
  
  /* DeInit  physical Interface components */
  if(pdev->pClassData != NULL)
 8004b9a:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
 8004b9e:	b153      	cbz	r3, 8004bb6 <USBD_CDC_DeInit+0x36>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->DeInit();
 8004ba0:	f8d4 321c 	ldr.w	r3, [r4, #540]	; 0x21c
 8004ba4:	685b      	ldr	r3, [r3, #4]
 8004ba6:	4798      	blx	r3
    USBD_free(pdev->pClassData);
 8004ba8:	f8d4 0218 	ldr.w	r0, [r4, #536]	; 0x218
 8004bac:	f7ff f998 	bl	8003ee0 <USBD_static_free>
    pdev->pClassData = NULL;
 8004bb0:	2300      	movs	r3, #0
 8004bb2:	f8c4 3218 	str.w	r3, [r4, #536]	; 0x218
  }
  
  return ret;
}
 8004bb6:	2000      	movs	r0, #0
 8004bb8:	bd10      	pop	{r4, pc}
 8004bba:	bf00      	nop

08004bbc <USBD_CDC_Init>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
 8004bbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint8_t ret = 0;
  USBD_CDC_HandleTypeDef   *hcdc;
  
  if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8004bbe:	7c03      	ldrb	r3, [r0, #16]
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
 8004bc0:	4604      	mov	r4, r0
  uint8_t ret = 0;
  USBD_CDC_HandleTypeDef   *hcdc;
  
  if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8004bc2:	bb73      	cbnz	r3, 8004c22 <USBD_CDC_Init+0x66>
  {  
    /* Open EP IN */
    USBD_LL_OpenEP(pdev,
 8004bc4:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004bc8:	2202      	movs	r2, #2
 8004bca:	2181      	movs	r1, #129	; 0x81
 8004bcc:	f7ff f934 	bl	8003e38 <USBD_LL_OpenEP>
                   CDC_IN_EP,
                   USBD_EP_TYPE_BULK,
                   CDC_DATA_HS_IN_PACKET_SIZE);
    
    /* Open EP OUT */
    USBD_LL_OpenEP(pdev,
 8004bd0:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004bd4:	2202      	movs	r2, #2
 8004bd6:	2101      	movs	r1, #1
 8004bd8:	4620      	mov	r0, r4
 8004bda:	f7ff f92d 	bl	8003e38 <USBD_LL_OpenEP>
                   CDC_OUT_EP,
                   USBD_EP_TYPE_BULK,
                   CDC_DATA_FS_OUT_PACKET_SIZE);
  }
  /* Open Command IN EP */
  USBD_LL_OpenEP(pdev,
 8004bde:	2308      	movs	r3, #8
 8004be0:	2203      	movs	r2, #3
 8004be2:	2182      	movs	r1, #130	; 0x82
 8004be4:	4620      	mov	r0, r4
 8004be6:	f7ff f927 	bl	8003e38 <USBD_LL_OpenEP>
                 CDC_CMD_EP,
                 USBD_EP_TYPE_INTR,
                 CDC_CMD_PACKET_SIZE);
  
    
  pdev->pClassData = USBD_malloc(sizeof (USBD_CDC_HandleTypeDef));
 8004bea:	f44f 7007 	mov.w	r0, #540	; 0x21c
 8004bee:	f7ff f973 	bl	8003ed8 <USBD_static_malloc>
 8004bf2:	4605      	mov	r5, r0
 8004bf4:	f8c4 0218 	str.w	r0, [r4, #536]	; 0x218
  
  if(pdev->pClassData == NULL)
 8004bf8:	b330      	cbz	r0, 8004c48 <USBD_CDC_Init+0x8c>
  else
  {
    hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
    
    /* Init  physical Interface components */
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
 8004bfa:	f8d4 321c 	ldr.w	r3, [r4, #540]	; 0x21c
    
    /* Init Xfer states */
    hcdc->TxState =0;
 8004bfe:	2600      	movs	r6, #0
  else
  {
    hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
    
    /* Init  physical Interface components */
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
 8004c00:	681b      	ldr	r3, [r3, #0]
 8004c02:	4798      	blx	r3
    
    /* Init Xfer states */
    hcdc->TxState =0;
    hcdc->RxState =0;
       
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8004c04:	7c27      	ldrb	r7, [r4, #16]
    {      
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 8004c06:	f8d5 2204 	ldr.w	r2, [r5, #516]	; 0x204
    
    /* Init  physical Interface components */
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
    
    /* Init Xfer states */
    hcdc->TxState =0;
 8004c0a:	f8c5 6214 	str.w	r6, [r5, #532]	; 0x214
    hcdc->RxState =0;
       
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
    {      
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 8004c0e:	4620      	mov	r0, r4
    /* Init  physical Interface components */
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
    
    /* Init Xfer states */
    hcdc->TxState =0;
    hcdc->RxState =0;
 8004c10:	f8c5 6218 	str.w	r6, [r5, #536]	; 0x218
       
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8004c14:	b18f      	cbz	r7, 8004c3a <USBD_CDC_Init+0x7e>
                             CDC_DATA_HS_OUT_PACKET_SIZE);
    }
    else
    {
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 8004c16:	2340      	movs	r3, #64	; 0x40
 8004c18:	2101      	movs	r1, #1
 8004c1a:	f7ff f94f 	bl	8003ebc <USBD_LL_PrepareReceive>
  * @retval status
  */
static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
  uint8_t ret = 0;
 8004c1e:	4630      	mov	r0, r6
 8004c20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    
  }
  else
  {
    /* Open EP IN */
    USBD_LL_OpenEP(pdev,
 8004c22:	2340      	movs	r3, #64	; 0x40
 8004c24:	2202      	movs	r2, #2
 8004c26:	2181      	movs	r1, #129	; 0x81
 8004c28:	f7ff f906 	bl	8003e38 <USBD_LL_OpenEP>
                   CDC_IN_EP,
                   USBD_EP_TYPE_BULK,
                   CDC_DATA_FS_IN_PACKET_SIZE);
    
    /* Open EP OUT */
    USBD_LL_OpenEP(pdev,
 8004c2c:	2340      	movs	r3, #64	; 0x40
 8004c2e:	2202      	movs	r2, #2
 8004c30:	2101      	movs	r1, #1
 8004c32:	4620      	mov	r0, r4
 8004c34:	f7ff f900 	bl	8003e38 <USBD_LL_OpenEP>
 8004c38:	e7d1      	b.n	8004bde <USBD_CDC_Init+0x22>
    hcdc->RxState =0;
       
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
    {      
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 8004c3a:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004c3e:	2101      	movs	r1, #1
 8004c40:	f7ff f93c 	bl	8003ebc <USBD_LL_PrepareReceive>
  * @retval status
  */
static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
  uint8_t ret = 0;
 8004c44:	4638      	mov	r0, r7
 8004c46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    
  pdev->pClassData = USBD_malloc(sizeof (USBD_CDC_HandleTypeDef));
  
  if(pdev->pClassData == NULL)
  {
    ret = 1; 
 8004c48:	2001      	movs	r0, #1
    }
    
    
  }
  return ret;
}
 8004c4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08004c4c <USBD_CDC_RegisterInterface>:
uint8_t  USBD_CDC_RegisterInterface  (USBD_HandleTypeDef   *pdev, 
                                      USBD_CDC_ItfTypeDef *fops)
{
  uint8_t  ret = USBD_FAIL;
  
  if(fops != NULL)
 8004c4c:	b119      	cbz	r1, 8004c56 <USBD_CDC_RegisterInterface+0xa>
  {
    pdev->pUserData= fops;
 8004c4e:	f8c0 121c 	str.w	r1, [r0, #540]	; 0x21c
    ret = USBD_OK;    
 8004c52:	2000      	movs	r0, #0
 8004c54:	4770      	bx	lr
  * @retval status
  */
uint8_t  USBD_CDC_RegisterInterface  (USBD_HandleTypeDef   *pdev, 
                                      USBD_CDC_ItfTypeDef *fops)
{
  uint8_t  ret = USBD_FAIL;
 8004c56:	2002      	movs	r0, #2
    pdev->pUserData= fops;
    ret = USBD_OK;    
  }
  
  return ret;
}
 8004c58:	4770      	bx	lr
 8004c5a:	bf00      	nop

08004c5c <USBD_CDC_SetTxBuffer>:
  */
uint8_t  USBD_CDC_SetTxBuffer  (USBD_HandleTypeDef   *pdev,
                                uint8_t  *pbuff,
                                uint16_t length)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 8004c5c:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  
  hcdc->TxBuffer = pbuff;
  hcdc->TxLength = length;  
  
  return USBD_OK;  
}
 8004c60:	2000      	movs	r0, #0
                                uint8_t  *pbuff,
                                uint16_t length)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  hcdc->TxBuffer = pbuff;
 8004c62:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
  hcdc->TxLength = length;  
 8004c66:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
  
  return USBD_OK;  
}
 8004c6a:	4770      	bx	lr

08004c6c <USBD_CDC_SetRxBuffer>:
uint8_t  USBD_CDC_SetRxBuffer  (USBD_HandleTypeDef   *pdev,
                                   uint8_t  *pbuff)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  hcdc->RxBuffer = pbuff;
 8004c6c:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  
  return USBD_OK;
}
 8004c70:	2000      	movs	r0, #0
uint8_t  USBD_CDC_SetRxBuffer  (USBD_HandleTypeDef   *pdev,
                                   uint8_t  *pbuff)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  hcdc->RxBuffer = pbuff;
 8004c72:	f8c3 1204 	str.w	r1, [r3, #516]	; 0x204
  
  return USBD_OK;
}
 8004c76:	4770      	bx	lr

08004c78 <USBD_CDC_TransmitPacket>:
  * @param  epnum: endpoint number
  * @retval status
  */
uint8_t  USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
{      
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 8004c78:	f8d0 2218 	ldr.w	r2, [r0, #536]	; 0x218
  
  if(pdev->pClassData != NULL)
 8004c7c:	b18a      	cbz	r2, 8004ca2 <USBD_CDC_TransmitPacket+0x2a>
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
uint8_t  USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
{      
 8004c7e:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  if(pdev->pClassData != NULL)
  {
    if(hcdc->TxState == 0)
 8004c80:	f8d2 4214 	ldr.w	r4, [r2, #532]	; 0x214
 8004c84:	b10c      	cbz	r4, 8004c8a <USBD_CDC_TransmitPacket+0x12>
      
      return USBD_OK;
    }
    else
    {
      return USBD_BUSY;
 8004c86:	2001      	movs	r0, #1
  }
  else
  {
    return USBD_FAIL;
  }
}
 8004c88:	bd10      	pop	{r4, pc}
  if(pdev->pClassData != NULL)
  {
    if(hcdc->TxState == 0)
    {
      /* Tx Transfer in progress */
      hcdc->TxState = 1;
 8004c8a:	2301      	movs	r3, #1
 8004c8c:	f8c2 3214 	str.w	r3, [r2, #532]	; 0x214
      
      /* Transmit next packet */
      USBD_LL_Transmit(pdev,
 8004c90:	2181      	movs	r1, #129	; 0x81
 8004c92:	f8b2 3210 	ldrh.w	r3, [r2, #528]	; 0x210
 8004c96:	f8d2 2208 	ldr.w	r2, [r2, #520]	; 0x208
 8004c9a:	f7ff f907 	bl	8003eac <USBD_LL_Transmit>
                       CDC_IN_EP,
                       hcdc->TxBuffer,
                       hcdc->TxLength);
      
      return USBD_OK;
 8004c9e:	4620      	mov	r0, r4
 8004ca0:	bd10      	pop	{r4, pc}
      return USBD_BUSY;
    }
  }
  else
  {
    return USBD_FAIL;
 8004ca2:	2002      	movs	r0, #2
  }
}
 8004ca4:	4770      	bx	lr
 8004ca6:	bf00      	nop

08004ca8 <USBD_CDC_ReceivePacket>:
  * @param  pdev: device instance
  * @retval status
  */
uint8_t  USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{      
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 8004ca8:	f8d0 2218 	ldr.w	r2, [r0, #536]	; 0x218
  
  /* Suspend or Resume USB Out process */
  if(pdev->pClassData != NULL)
 8004cac:	b18a      	cbz	r2, 8004cd2 <USBD_CDC_ReceivePacket+0x2a>
  *         prepare OUT Endpoint for reception
  * @param  pdev: device instance
  * @retval status
  */
uint8_t  USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{      
 8004cae:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  /* Suspend or Resume USB Out process */
  if(pdev->pClassData != NULL)
  {
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8004cb0:	7c04      	ldrb	r4, [r0, #16]
    {      
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 8004cb2:	f8d2 2204 	ldr.w	r2, [r2, #516]	; 0x204
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  /* Suspend or Resume USB Out process */
  if(pdev->pClassData != NULL)
  {
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8004cb6:	b12c      	cbz	r4, 8004cc4 <USBD_CDC_ReceivePacket+0x1c>
                             CDC_DATA_HS_OUT_PACKET_SIZE);
    }
    else
    {
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 8004cb8:	2340      	movs	r3, #64	; 0x40
 8004cba:	2101      	movs	r1, #1
 8004cbc:	f7ff f8fe 	bl	8003ebc <USBD_LL_PrepareReceive>
                             CDC_OUT_EP,
                             hcdc->RxBuffer,
                             CDC_DATA_FS_OUT_PACKET_SIZE);
    }
    return USBD_OK;
 8004cc0:	2000      	movs	r0, #0
 8004cc2:	bd10      	pop	{r4, pc}
  if(pdev->pClassData != NULL)
  {
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
    {      
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 8004cc4:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004cc8:	2101      	movs	r1, #1
 8004cca:	f7ff f8f7 	bl	8003ebc <USBD_LL_PrepareReceive>
      USBD_LL_PrepareReceive(pdev,
                             CDC_OUT_EP,
                             hcdc->RxBuffer,
                             CDC_DATA_FS_OUT_PACKET_SIZE);
    }
    return USBD_OK;
 8004cce:	4620      	mov	r0, r4
 8004cd0:	bd10      	pop	{r4, pc}
  }
  else
  {
    return USBD_FAIL;
 8004cd2:	2002      	movs	r0, #2
 8004cd4:	4770      	bx	lr
 8004cd6:	bf00      	nop

08004cd8 <RTC_WeekDayNum>:
{
  uint32_t year = 0, weekday = 0;

  year = 2000 + nYear;
  
  if(nMonth < 3)
 8004cd8:	2902      	cmp	r1, #2
  *         @arg RTC_WEEKDAY_FRIDAY
  *         @arg RTC_WEEKDAY_SATURDAY
  *         @arg RTC_WEEKDAY_SUNDAY
  */
static uint8_t RTC_WeekDayNum(uint32_t nYear, uint8_t nMonth, uint8_t nDay)
{
 8004cda:	b530      	push	{r4, r5, lr}
  uint32_t year = 0, weekday = 0;

  year = 2000 + nYear;
  
  if(nMonth < 3)
 8004cdc:	d924      	bls.n	8004d28 <RTC_WeekDayNum+0x50>
    weekday = (((23 * nMonth)/9) + nDay + 4 + year + ((year-1)/4) - ((year-1)/100) + ((year-1)/400)) % 7;
  }
  else
  {
    /*D = { [(23 x month)/9] + day + 4 + year + [year/4] - [year/100] + [year/400] - 2 } mod 7*/
    weekday = (((23 * nMonth)/9) + nDay + 4 + year + (year/4) - (year/100) + (year/400) - 2 ) % 7; 
 8004cde:	eb01 0341 	add.w	r3, r1, r1, lsl #1
 8004ce2:	4d24      	ldr	r5, [pc, #144]	; (8004d74 <RTC_WeekDayNum+0x9c>)
 8004ce4:	4c24      	ldr	r4, [pc, #144]	; (8004d78 <RTC_WeekDayNum+0xa0>)
 8004ce6:	ebc1 01c3 	rsb	r1, r1, r3, lsl #3
  */
static uint8_t RTC_WeekDayNum(uint32_t nYear, uint8_t nMonth, uint8_t nDay)
{
  uint32_t year = 0, weekday = 0;

  year = 2000 + nYear;
 8004cea:	f500 63fa 	add.w	r3, r0, #2000	; 0x7d0
    weekday = (((23 * nMonth)/9) + nDay + 4 + year + ((year-1)/4) - ((year-1)/100) + ((year-1)/400)) % 7;
  }
  else
  {
    /*D = { [(23 x month)/9] + day + 4 + year + [year/4] - [year/100] + [year/400] - 2 } mod 7*/
    weekday = (((23 * nMonth)/9) + nDay + 4 + year + (year/4) - (year/100) + (year/400) - 2 ) % 7; 
 8004cee:	fba4 e403 	umull	lr, r4, r4, r3
 8004cf2:	fb85 e501 	smull	lr, r5, r5, r1
 8004cf6:	f200 70d2 	addw	r0, r0, #2002	; 0x7d2
 8004cfa:	eb00 0393 	add.w	r3, r0, r3, lsr #2
 8004cfe:	17c9      	asrs	r1, r1, #31
 8004d00:	eb03 13d4 	add.w	r3, r3, r4, lsr #7
 8004d04:	ebc1 0165 	rsb	r1, r1, r5, asr #1
 8004d08:	eba3 1054 	sub.w	r0, r3, r4, lsr #5
 8004d0c:	4411      	add	r1, r2
 8004d0e:	4a1b      	ldr	r2, [pc, #108]	; (8004d7c <RTC_WeekDayNum+0xa4>)
 8004d10:	4401      	add	r1, r0
 8004d12:	fba1 2302 	umull	r2, r3, r1, r2
 8004d16:	1ac8      	subs	r0, r1, r3
 8004d18:	eb03 0050 	add.w	r0, r3, r0, lsr #1
 8004d1c:	0880      	lsrs	r0, r0, #2
 8004d1e:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 8004d22:	1a08      	subs	r0, r1, r0
  }

  return (uint8_t)weekday;
}
 8004d24:	b2c0      	uxtb	r0, r0
 8004d26:	bd30      	pop	{r4, r5, pc}
  year = 2000 + nYear;
  
  if(nMonth < 3)
  {
    /*D = { [(23 x month)/9] + day + 4 + year + [(year-1)/4] - [(year-1)/100] + [(year-1)/400] } mod 7*/
    weekday = (((23 * nMonth)/9) + nDay + 4 + year + ((year-1)/4) - ((year-1)/100) + ((year-1)/400)) % 7;
 8004d28:	eb01 0441 	add.w	r4, r1, r1, lsl #1
 8004d2c:	4b11      	ldr	r3, [pc, #68]	; (8004d74 <RTC_WeekDayNum+0x9c>)
 8004d2e:	4d12      	ldr	r5, [pc, #72]	; (8004d78 <RTC_WeekDayNum+0xa0>)
 8004d30:	ebc1 01c4 	rsb	r1, r1, r4, lsl #3
 8004d34:	f200 74cf 	addw	r4, r0, #1999	; 0x7cf
 8004d38:	fba5 e504 	umull	lr, r5, r5, r4
 8004d3c:	fb83 e301 	smull	lr, r3, r3, r1
 8004d40:	f200 70d4 	addw	r0, r0, #2004	; 0x7d4
 8004d44:	17c9      	asrs	r1, r1, #31
 8004d46:	eb00 0494 	add.w	r4, r0, r4, lsr #2
 8004d4a:	ebc1 0363 	rsb	r3, r1, r3, asr #1
 8004d4e:	eb04 14d5 	add.w	r4, r4, r5, lsr #7
 8004d52:	1899      	adds	r1, r3, r2
 8004d54:	4809      	ldr	r0, [pc, #36]	; (8004d7c <RTC_WeekDayNum+0xa4>)
 8004d56:	eba4 1255 	sub.w	r2, r4, r5, lsr #5
 8004d5a:	440a      	add	r2, r1
 8004d5c:	fba2 0100 	umull	r0, r1, r2, r0
 8004d60:	1a50      	subs	r0, r2, r1
 8004d62:	eb01 0050 	add.w	r0, r1, r0, lsr #1
 8004d66:	0880      	lsrs	r0, r0, #2
 8004d68:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 8004d6c:	1a10      	subs	r0, r2, r0
    /*D = { [(23 x month)/9] + day + 4 + year + [year/4] - [year/100] + [year/400] - 2 } mod 7*/
    weekday = (((23 * nMonth)/9) + nDay + 4 + year + (year/4) - (year/100) + (year/400) - 2 ) % 7; 
  }

  return (uint8_t)weekday;
}
 8004d6e:	b2c0      	uxtb	r0, r0
 8004d70:	bd30      	pop	{r4, r5, pc}
 8004d72:	bf00      	nop
 8004d74:	38e38e39 	.word	0x38e38e39
 8004d78:	51eb851f 	.word	0x51eb851f
 8004d7c:	24924925 	.word	0x24924925

08004d80 <RTC_EnterInitMode>:
  * @param  hrtc   pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
static HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
{
 8004d80:	b538      	push	{r3, r4, r5, lr}
 8004d82:	4604      	mov	r4, r0
  uint32_t tickstart = 0;
  
  tickstart = HAL_GetTick();
 8004d84:	f7fb fb18 	bl	80003b8 <HAL_GetTick>
 8004d88:	4605      	mov	r5, r0
  /* Wait till RTC is in INIT state and if Time out is reached exit */
  while((hrtc->Instance->CRL & RTC_CRL_RTOFF) == (uint32_t)RESET)
 8004d8a:	e005      	b.n	8004d98 <RTC_EnterInitMode+0x18>
  {
    if((HAL_GetTick() - tickstart) >  RTC_TIMEOUT_VALUE)
 8004d8c:	f7fb fb14 	bl	80003b8 <HAL_GetTick>
 8004d90:	1b40      	subs	r0, r0, r5
 8004d92:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8004d96:	d809      	bhi.n	8004dac <RTC_EnterInitMode+0x2c>
{
  uint32_t tickstart = 0;
  
  tickstart = HAL_GetTick();
  /* Wait till RTC is in INIT state and if Time out is reached exit */
  while((hrtc->Instance->CRL & RTC_CRL_RTOFF) == (uint32_t)RESET)
 8004d98:	6823      	ldr	r3, [r4, #0]
 8004d9a:	685a      	ldr	r2, [r3, #4]
 8004d9c:	0692      	lsls	r2, r2, #26
 8004d9e:	d5f5      	bpl.n	8004d8c <RTC_EnterInitMode+0xc>
      return HAL_TIMEOUT;
    } 
  }

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8004da0:	685a      	ldr	r2, [r3, #4]
  
  
  return HAL_OK;  
 8004da2:	2000      	movs	r0, #0
      return HAL_TIMEOUT;
    } 
  }

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8004da4:	f042 0210 	orr.w	r2, r2, #16
 8004da8:	605a      	str	r2, [r3, #4]
  
  
  return HAL_OK;  
 8004daa:	bd38      	pop	{r3, r4, r5, pc}
  /* Wait till RTC is in INIT state and if Time out is reached exit */
  while((hrtc->Instance->CRL & RTC_CRL_RTOFF) == (uint32_t)RESET)
  {
    if((HAL_GetTick() - tickstart) >  RTC_TIMEOUT_VALUE)
    {       
      return HAL_TIMEOUT;
 8004dac:	2003      	movs	r0, #3
  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
  
  
  return HAL_OK;  
}
 8004dae:	bd38      	pop	{r3, r4, r5, pc}

08004db0 <RTC_ExitInitMode>:
static HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef* hrtc)
{
  uint32_t tickstart = 0;
  
  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8004db0:	6802      	ldr	r2, [r0, #0]
  * @param  hrtc   pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
static HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef* hrtc)
{
 8004db2:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart = 0;
  
  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8004db4:	6853      	ldr	r3, [r2, #4]
  * @param  hrtc   pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
static HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef* hrtc)
{
 8004db6:	4604      	mov	r4, r0
  uint32_t tickstart = 0;
  
  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8004db8:	f023 0310 	bic.w	r3, r3, #16
 8004dbc:	6053      	str	r3, [r2, #4]
  
  tickstart = HAL_GetTick();
 8004dbe:	f7fb fafb 	bl	80003b8 <HAL_GetTick>
 8004dc2:	4605      	mov	r5, r0
  /* Wait till RTC is in INIT state and if Time out is reached exit */
  while((hrtc->Instance->CRL & RTC_CRL_RTOFF) == (uint32_t)RESET)
 8004dc4:	e005      	b.n	8004dd2 <RTC_ExitInitMode+0x22>
  {
    if((HAL_GetTick() - tickstart) >  RTC_TIMEOUT_VALUE)
 8004dc6:	f7fb faf7 	bl	80003b8 <HAL_GetTick>
 8004dca:	1b40      	subs	r0, r0, r5
 8004dcc:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8004dd0:	d805      	bhi.n	8004dde <RTC_ExitInitMode+0x2e>
  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
  
  tickstart = HAL_GetTick();
  /* Wait till RTC is in INIT state and if Time out is reached exit */
  while((hrtc->Instance->CRL & RTC_CRL_RTOFF) == (uint32_t)RESET)
 8004dd2:	6823      	ldr	r3, [r4, #0]
 8004dd4:	685b      	ldr	r3, [r3, #4]
 8004dd6:	069b      	lsls	r3, r3, #26
 8004dd8:	d5f5      	bpl.n	8004dc6 <RTC_ExitInitMode+0x16>
    {       
      return HAL_TIMEOUT;
    } 
  }
  
  return HAL_OK;  
 8004dda:	2000      	movs	r0, #0
 8004ddc:	bd38      	pop	{r3, r4, r5, pc}
  /* Wait till RTC is in INIT state and if Time out is reached exit */
  while((hrtc->Instance->CRL & RTC_CRL_RTOFF) == (uint32_t)RESET)
  {
    if((HAL_GetTick() - tickstart) >  RTC_TIMEOUT_VALUE)
    {       
      return HAL_TIMEOUT;
 8004dde:	2003      	movs	r0, #3
    } 
  }
  
  return HAL_OK;  
}
 8004de0:	bd38      	pop	{r3, r4, r5, pc}
 8004de2:	bf00      	nop

08004de4 <RTC_WriteTimeCounter>:
  *                the configuration information for RTC.
  * @param  TimeCounter: Counter to write in RTC_CNT registers
  * @retval HAL status
  */
static HAL_StatusTypeDef RTC_WriteTimeCounter(RTC_HandleTypeDef* hrtc, uint32_t TimeCounter)
{
 8004de4:	b538      	push	{r3, r4, r5, lr}
 8004de6:	460c      	mov	r4, r1
 8004de8:	4605      	mov	r5, r0
  HAL_StatusTypeDef status = HAL_OK;
  
  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8004dea:	f7ff ffc9 	bl	8004d80 <RTC_EnterInitMode>
 8004dee:	b108      	cbz	r0, 8004df4 <RTC_WriteTimeCounter+0x10>
  {
    status = HAL_ERROR;
 8004df0:	2001      	movs	r0, #1
      status = HAL_ERROR;
    }
  }

  return status;
}
 8004df2:	bd38      	pop	{r3, r4, r5, pc}
    status = HAL_ERROR;
  } 
  else
  {
    /* Set RTC COUNTER MSB word */
    WRITE_REG(hrtc->Instance->CNTH, (TimeCounter >> 16));
 8004df4:	682b      	ldr	r3, [r5, #0]
 8004df6:	0c22      	lsrs	r2, r4, #16
    /* Set RTC COUNTER LSB word */
    WRITE_REG(hrtc->Instance->CNTL, (TimeCounter & RTC_CNTL_RTC_CNT));
 8004df8:	b2a4      	uxth	r4, r4
    status = HAL_ERROR;
  } 
  else
  {
    /* Set RTC COUNTER MSB word */
    WRITE_REG(hrtc->Instance->CNTH, (TimeCounter >> 16));
 8004dfa:	619a      	str	r2, [r3, #24]
    /* Set RTC COUNTER LSB word */
    WRITE_REG(hrtc->Instance->CNTL, (TimeCounter & RTC_CNTL_RTC_CNT));
    
    /* Wait for synchro */
    if(RTC_ExitInitMode(hrtc) != HAL_OK)
 8004dfc:	4628      	mov	r0, r5
  else
  {
    /* Set RTC COUNTER MSB word */
    WRITE_REG(hrtc->Instance->CNTH, (TimeCounter >> 16));
    /* Set RTC COUNTER LSB word */
    WRITE_REG(hrtc->Instance->CNTL, (TimeCounter & RTC_CNTL_RTC_CNT));
 8004dfe:	61dc      	str	r4, [r3, #28]
    
    /* Wait for synchro */
    if(RTC_ExitInitMode(hrtc) != HAL_OK)
 8004e00:	f7ff ffd6 	bl	8004db0 <RTC_ExitInitMode>
  HAL_StatusTypeDef status = HAL_OK;
  
  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
  {
    status = HAL_ERROR;
 8004e04:	3000      	adds	r0, #0
 8004e06:	bf18      	it	ne
 8004e08:	2001      	movne	r0, #1
 8004e0a:	bd38      	pop	{r3, r4, r5, pc}

08004e0c <RTC_WriteAlarmCounter>:
  *                the configuration information for RTC.
  * @param  AlarmCounter: Counter to write in RTC_ALR registers
  * @retval HAL status
  */
static HAL_StatusTypeDef RTC_WriteAlarmCounter(RTC_HandleTypeDef* hrtc, uint32_t AlarmCounter)
{
 8004e0c:	b538      	push	{r3, r4, r5, lr}
 8004e0e:	460c      	mov	r4, r1
 8004e10:	4605      	mov	r5, r0
  HAL_StatusTypeDef status = HAL_OK;
  
  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8004e12:	f7ff ffb5 	bl	8004d80 <RTC_EnterInitMode>
 8004e16:	b108      	cbz	r0, 8004e1c <RTC_WriteAlarmCounter+0x10>
  {
    status = HAL_ERROR;
 8004e18:	2001      	movs	r0, #1
      status = HAL_ERROR;
    }
  }

  return status;
}
 8004e1a:	bd38      	pop	{r3, r4, r5, pc}
    status = HAL_ERROR;
  } 
  else
  {
    /* Set RTC COUNTER MSB word */
    WRITE_REG(hrtc->Instance->ALRH, (AlarmCounter >> 16));
 8004e1c:	682b      	ldr	r3, [r5, #0]
 8004e1e:	0c22      	lsrs	r2, r4, #16
    /* Set RTC COUNTER LSB word */
    WRITE_REG(hrtc->Instance->ALRL, (AlarmCounter & RTC_ALRL_RTC_ALR));
 8004e20:	b2a4      	uxth	r4, r4
    status = HAL_ERROR;
  } 
  else
  {
    /* Set RTC COUNTER MSB word */
    WRITE_REG(hrtc->Instance->ALRH, (AlarmCounter >> 16));
 8004e22:	621a      	str	r2, [r3, #32]
    /* Set RTC COUNTER LSB word */
    WRITE_REG(hrtc->Instance->ALRL, (AlarmCounter & RTC_ALRL_RTC_ALR));
    
    /* Wait for synchro */
    if(RTC_ExitInitMode(hrtc) != HAL_OK)
 8004e24:	4628      	mov	r0, r5
  else
  {
    /* Set RTC COUNTER MSB word */
    WRITE_REG(hrtc->Instance->ALRH, (AlarmCounter >> 16));
    /* Set RTC COUNTER LSB word */
    WRITE_REG(hrtc->Instance->ALRL, (AlarmCounter & RTC_ALRL_RTC_ALR));
 8004e26:	625c      	str	r4, [r3, #36]	; 0x24
    
    /* Wait for synchro */
    if(RTC_ExitInitMode(hrtc) != HAL_OK)
 8004e28:	f7ff ffc2 	bl	8004db0 <RTC_ExitInitMode>
  HAL_StatusTypeDef status = HAL_OK;
  
  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
  {
    status = HAL_ERROR;
 8004e2c:	3000      	adds	r0, #0
 8004e2e:	bf18      	it	ne
 8004e30:	2001      	movne	r0, #1
 8004e32:	bd38      	pop	{r3, r4, r5, pc}

08004e34 <HAL_RTC_SetTime>:
  *            @arg RTC_FORMAT_BIN: Binary data format 
  *            @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
{
 8004e34:	b570      	push	{r4, r5, r6, lr}
  uint32_t counter_time = 0, counter_alarm = 0;
  
  /* Check input parameters */
  if((hrtc == NULL) || (sTime == NULL))
 8004e36:	2800      	cmp	r0, #0
 8004e38:	d06b      	beq.n	8004f12 <HAL_RTC_SetTime+0xde>
 8004e3a:	2900      	cmp	r1, #0
 8004e3c:	d069      	beq.n	8004f12 <HAL_RTC_SetTime+0xde>
  
 /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));
  
  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8004e3e:	7c03      	ldrb	r3, [r0, #16]
 8004e40:	2b01      	cmp	r3, #1
 8004e42:	d033      	beq.n	8004eac <HAL_RTC_SetTime+0x78>
  
  hrtc->State = HAL_RTC_STATE_BUSY;
 8004e44:	2302      	movs	r3, #2
  
 /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));
  
  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8004e46:	2401      	movs	r4, #1
 8004e48:	7404      	strb	r4, [r0, #16]
  
  hrtc->State = HAL_RTC_STATE_BUSY;
 8004e4a:	7443      	strb	r3, [r0, #17]
  {
    assert_param(IS_RTC_HOUR24(sTime->Hours));
    assert_param(IS_RTC_MINUTES(sTime->Minutes));
    assert_param(IS_RTC_SECONDS(sTime->Seconds));

    counter_time = (uint32_t)(((uint32_t)sTime->Hours * 3600) + \
 8004e4c:	784b      	ldrb	r3, [r1, #1]
  /* Process Locked */ 
  __HAL_LOCK(hrtc);
  
  hrtc->State = HAL_RTC_STATE_BUSY;
  
  if(Format == RTC_FORMAT_BIN)
 8004e4e:	bb82      	cbnz	r2, 8004eb2 <HAL_RTC_SetTime+0x7e>
  {
    assert_param(IS_RTC_HOUR24(sTime->Hours));
    assert_param(IS_RTC_MINUTES(sTime->Minutes));
    assert_param(IS_RTC_SECONDS(sTime->Seconds));

    counter_time = (uint32_t)(((uint32_t)sTime->Hours * 3600) + \
 8004e50:	780a      	ldrb	r2, [r1, #0]
 8004e52:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
 8004e56:	f44f 6461 	mov.w	r4, #3600	; 0xe10
 8004e5a:	009b      	lsls	r3, r3, #2
 8004e5c:	fb04 3302 	mla	r3, r4, r2, r3
 8004e60:	788c      	ldrb	r4, [r1, #2]
 8004e62:	4606      	mov	r6, r0
 8004e64:	441c      	add	r4, r3
              ((uint32_t)(RTC_Bcd2ToByte(sTime->Minutes)) * 60) + \
              ((uint32_t)(RTC_Bcd2ToByte(sTime->Seconds))));   
  }

  /* Write time counter in RTC registers */
  if (RTC_WriteTimeCounter(hrtc, counter_time) != HAL_OK)
 8004e66:	4621      	mov	r1, r4
 8004e68:	f7ff ffbc 	bl	8004de4 <RTC_WriteTimeCounter>
 8004e6c:	4605      	mov	r5, r0
 8004e6e:	2800      	cmp	r0, #0
 8004e70:	d148      	bne.n	8004f04 <HAL_RTC_SetTime+0xd0>
    return HAL_ERROR;
  }
  else
  {
    /* Clear Second and overflow flags */
    CLEAR_BIT(hrtc->Instance->CRL, (RTC_FLAG_SEC | RTC_FLAG_OW));
 8004e72:	6833      	ldr	r3, [r6, #0]
 8004e74:	685a      	ldr	r2, [r3, #4]
 8004e76:	f022 0205 	bic.w	r2, r2, #5
 8004e7a:	605a      	str	r2, [r3, #4]
  */
static uint32_t RTC_ReadAlarmCounter(RTC_HandleTypeDef* hrtc)
{
  uint16_t high1 = 0, low = 0;

  high1 = READ_REG(hrtc->Instance->ALRH & RTC_CNTH_RTC_CNT);
 8004e7c:	6a19      	ldr	r1, [r3, #32]
  low   = READ_REG(hrtc->Instance->ALRL & RTC_CNTL_RTC_CNT);
 8004e7e:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  return (((uint32_t) high1 << 16 ) | low);
 8004e80:	b29b      	uxth	r3, r3
 8004e82:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
    
    /* Read current Alarm counter in RTC registers */
    counter_alarm = RTC_ReadAlarmCounter(hrtc);

    /* Set again alarm to match with new time if enabled */
    if (counter_alarm != RTC_ALARM_RESETVALUE)
 8004e86:	1c4b      	adds	r3, r1, #1
 8004e88:	d00a      	beq.n	8004ea0 <HAL_RTC_SetTime+0x6c>
    {
      if(counter_alarm < counter_time)
 8004e8a:	428c      	cmp	r4, r1
 8004e8c:	d908      	bls.n	8004ea0 <HAL_RTC_SetTime+0x6c>
      {
        /* Add 1 day to alarm counter*/
        counter_alarm += (uint32_t)(24 * 3600);
        
        /* Write new Alarm counter in RTC registers */
        if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
 8004e8e:	f501 31a8 	add.w	r1, r1, #86016	; 0x15000
 8004e92:	f501 71c0 	add.w	r1, r1, #384	; 0x180
 8004e96:	4630      	mov	r0, r6
 8004e98:	f7ff ffb8 	bl	8004e0c <RTC_WriteAlarmCounter>
 8004e9c:	2800      	cmp	r0, #0
 8004e9e:	d13b      	bne.n	8004f18 <HAL_RTC_SetTime+0xe4>
          return HAL_ERROR;
        }
      }
    }
    
    hrtc->State = HAL_RTC_STATE_READY;
 8004ea0:	2201      	movs	r2, #1
  
   __HAL_UNLOCK(hrtc); 
 8004ea2:	2300      	movs	r3, #0
          return HAL_ERROR;
        }
      }
    }
    
    hrtc->State = HAL_RTC_STATE_READY;
 8004ea4:	7472      	strb	r2, [r6, #17]
  
   __HAL_UNLOCK(hrtc); 
 8004ea6:	7433      	strb	r3, [r6, #16]
     
   return HAL_OK;
  }
}
 8004ea8:	4628      	mov	r0, r5
 8004eaa:	bd70      	pop	{r4, r5, r6, pc}
  
 /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));
  
  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8004eac:	2502      	movs	r5, #2
  
   __HAL_UNLOCK(hrtc); 
     
   return HAL_OK;
  }
}
 8004eae:	4628      	mov	r0, r5
 8004eb0:	bd70      	pop	{r4, r5, r6, pc}
  {
    assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));

    counter_time = (((uint32_t)(RTC_Bcd2ToByte(sTime->Hours)) * 3600) + \
 8004eb2:	780a      	ldrb	r2, [r1, #0]
 8004eb4:	091c      	lsrs	r4, r3, #4
 8004eb6:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8004eba:	f003 030f 	and.w	r3, r3, #15
 8004ebe:	eb03 0444 	add.w	r4, r3, r4, lsl #1
 8004ec2:	0913      	lsrs	r3, r2, #4
 8004ec4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8004ec8:	b2e4      	uxtb	r4, r4
 8004eca:	f002 020f 	and.w	r2, r2, #15
              ((uint32_t)(RTC_Bcd2ToByte(sTime->Minutes)) * 60) + \
              ((uint32_t)(RTC_Bcd2ToByte(sTime->Seconds))));   
 8004ece:	7889      	ldrb	r1, [r1, #2]
  {
    assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));

    counter_time = (((uint32_t)(RTC_Bcd2ToByte(sTime->Hours)) * 3600) + \
 8004ed0:	ebc4 1404 	rsb	r4, r4, r4, lsl #4
 8004ed4:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 8004ed8:	b2d2      	uxtb	r2, r2
 8004eda:	00a3      	lsls	r3, r4, #2
 8004edc:	f44f 6461 	mov.w	r4, #3600	; 0xe10
 8004ee0:	fb04 3302 	mla	r3, r4, r2, r3
 8004ee4:	090c      	lsrs	r4, r1, #4
 8004ee6:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8004eea:	f001 010f 	and.w	r1, r1, #15
 8004eee:	eb01 0444 	add.w	r4, r1, r4, lsl #1
 8004ef2:	b2e4      	uxtb	r4, r4
 8004ef4:	441c      	add	r4, r3
              ((uint32_t)(RTC_Bcd2ToByte(sTime->Minutes)) * 60) + \
              ((uint32_t)(RTC_Bcd2ToByte(sTime->Seconds))));   
  }

  /* Write time counter in RTC registers */
  if (RTC_WriteTimeCounter(hrtc, counter_time) != HAL_OK)
 8004ef6:	4621      	mov	r1, r4
 8004ef8:	4606      	mov	r6, r0
 8004efa:	f7ff ff73 	bl	8004de4 <RTC_WriteTimeCounter>
 8004efe:	4605      	mov	r5, r0
 8004f00:	2800      	cmp	r0, #0
 8004f02:	d0b6      	beq.n	8004e72 <HAL_RTC_SetTime+0x3e>
  {
    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_ERROR;
 8004f04:	2204      	movs	r2, #4
    
    /* Process Unlocked */ 
    __HAL_UNLOCK(hrtc);
 8004f06:	2300      	movs	r3, #0
    
    return HAL_ERROR;
 8004f08:	2501      	movs	r5, #1

  /* Write time counter in RTC registers */
  if (RTC_WriteTimeCounter(hrtc, counter_time) != HAL_OK)
  {
    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_ERROR;
 8004f0a:	7472      	strb	r2, [r6, #17]
    
    /* Process Unlocked */ 
    __HAL_UNLOCK(hrtc);
 8004f0c:	7433      	strb	r3, [r6, #16]
  
   __HAL_UNLOCK(hrtc); 
     
   return HAL_OK;
  }
}
 8004f0e:	4628      	mov	r0, r5
 8004f10:	bd70      	pop	{r4, r5, r6, pc}
  uint32_t counter_time = 0, counter_alarm = 0;
  
  /* Check input parameters */
  if((hrtc == NULL) || (sTime == NULL))
  {
     return HAL_ERROR;
 8004f12:	2501      	movs	r5, #1
  
   __HAL_UNLOCK(hrtc); 
     
   return HAL_OK;
  }
}
 8004f14:	4628      	mov	r0, r5
 8004f16:	bd70      	pop	{r4, r5, r6, pc}
        
        /* Write new Alarm counter in RTC registers */
        if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
        {
          /* Set RTC state */
          hrtc->State = HAL_RTC_STATE_ERROR;
 8004f18:	2304      	movs	r3, #4
          
          /* Process Unlocked */ 
          __HAL_UNLOCK(hrtc);
 8004f1a:	7435      	strb	r5, [r6, #16]
        
        /* Write new Alarm counter in RTC registers */
        if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
        {
          /* Set RTC state */
          hrtc->State = HAL_RTC_STATE_ERROR;
 8004f1c:	7473      	strb	r3, [r6, #17]
          
          /* Process Unlocked */ 
          __HAL_UNLOCK(hrtc);
          
          return HAL_ERROR;
 8004f1e:	2501      	movs	r5, #1
 8004f20:	e7c5      	b.n	8004eae <HAL_RTC_SetTime+0x7a>
 8004f22:	bf00      	nop

08004f24 <HAL_RTC_SetDate>:
HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
{
  uint32_t counter_time = 0, counter_alarm = 0, hours = 0;
  
  /* Check input parameters */
  if((hrtc == NULL) || (sDate == NULL))
 8004f24:	2800      	cmp	r0, #0
 8004f26:	d04d      	beq.n	8004fc4 <HAL_RTC_SetDate+0xa0>
 8004f28:	2900      	cmp	r1, #0
 8004f2a:	d04b      	beq.n	8004fc4 <HAL_RTC_SetDate+0xa0>
  
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));
  
 /* Process Locked */ 
 __HAL_LOCK(hrtc);
 8004f2c:	7c03      	ldrb	r3, [r0, #16]
 8004f2e:	2b01      	cmp	r3, #1
 8004f30:	d027      	beq.n	8004f82 <HAL_RTC_SetDate+0x5e>
  *            @arg RTC_FORMAT_BIN: Binary data format 
  *            @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
{
 8004f32:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_RTC_FORMAT(Format));
  
 /* Process Locked */ 
 __HAL_LOCK(hrtc);
  
  hrtc->State = HAL_RTC_STATE_BUSY; 
 8004f34:	2302      	movs	r3, #2
  
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));
  
 /* Process Locked */ 
 __HAL_LOCK(hrtc);
 8004f36:	2401      	movs	r4, #1
 8004f38:	7404      	strb	r4, [r0, #16]
  
  hrtc->State = HAL_RTC_STATE_BUSY; 
 8004f3a:	7443      	strb	r3, [r0, #17]
  
  if(Format == RTC_FORMAT_BIN)
 8004f3c:	bb1a      	cbnz	r2, 8004f86 <HAL_RTC_SetDate+0x62>
    assert_param(IS_RTC_YEAR(sDate->Year));
    assert_param(IS_RTC_MONTH(sDate->Month));
    assert_param(IS_RTC_DATE(sDate->Date)); 

    /* Change the current date */
    hrtc->DateToUpdate.Year  = sDate->Year;
 8004f3e:	78cb      	ldrb	r3, [r1, #3]
 8004f40:	73c3      	strb	r3, [r0, #15]
    hrtc->DateToUpdate.Month = sDate->Month;
 8004f42:	784e      	ldrb	r6, [r1, #1]
 8004f44:	7346      	strb	r6, [r0, #13]
    hrtc->DateToUpdate.Date  = sDate->Date;
 8004f46:	788a      	ldrb	r2, [r1, #2]
 8004f48:	7382      	strb	r2, [r0, #14]
 8004f4a:	4604      	mov	r4, r0
 8004f4c:	460d      	mov	r5, r1
    hrtc->DateToUpdate.Month = RTC_Bcd2ToByte(sDate->Month);
    hrtc->DateToUpdate.Date  = RTC_Bcd2ToByte(sDate->Date);
  }

  /* WeekDay set by user can be ignored because automatically calculated */
  hrtc->DateToUpdate.WeekDay = RTC_WeekDayNum(hrtc->DateToUpdate.Year, hrtc->DateToUpdate.Month, hrtc->DateToUpdate.Date);
 8004f4e:	4618      	mov	r0, r3
 8004f50:	4631      	mov	r1, r6
 8004f52:	f7ff fec1 	bl	8004cd8 <RTC_WeekDayNum>
 8004f56:	7320      	strb	r0, [r4, #12]
  sDate->WeekDay = hrtc->DateToUpdate.WeekDay;
 8004f58:	7028      	strb	r0, [r5, #0]
static uint32_t RTC_ReadTimeCounter(RTC_HandleTypeDef* hrtc)
{
  uint16_t high1 = 0, high2 = 0, low = 0;
  uint32_t timecounter = 0;

  high1 = READ_REG(hrtc->Instance->CNTH & RTC_CNTH_RTC_CNT);
 8004f5a:	6821      	ldr	r1, [r4, #0]
 8004f5c:	698b      	ldr	r3, [r1, #24]
  low   = READ_REG(hrtc->Instance->CNTL & RTC_CNTL_RTC_CNT);
 8004f5e:	69ca      	ldr	r2, [r1, #28]
  high2 = READ_REG(hrtc->Instance->CNTH & RTC_CNTH_RTC_CNT);
 8004f60:	6988      	ldr	r0, [r1, #24]

  if (high1 != high2)
 8004f62:	b29e      	uxth	r6, r3
 8004f64:	b285      	uxth	r5, r0
 8004f66:	42ae      	cmp	r6, r5
 8004f68:	d053      	beq.n	8005012 <HAL_RTC_SetDate+0xee>
  { /* In this case the counter roll over during reading of CNTL and CNTH registers, 
       read again CNTL register then return the counter value */
    timecounter = (((uint32_t) high2 << 16 ) | READ_REG(hrtc->Instance->CNTL & RTC_CNTL_RTC_CNT));
 8004f6a:	69cb      	ldr	r3, [r1, #28]
 8004f6c:	b29b      	uxth	r3, r3
 8004f6e:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
  /* Read the time counter*/
  counter_time = RTC_ReadTimeCounter(hrtc);

  /* Fill the structure fields with the read parameters */
  hours = counter_time / 3600;
  if (hours > 24)
 8004f72:	4a2d      	ldr	r2, [pc, #180]	; (8005028 <HAL_RTC_SetDate+0x104>)
 8004f74:	4293      	cmp	r3, r2
 8004f76:	d827      	bhi.n	8004fc8 <HAL_RTC_SetDate+0xa4>
    }
    

  }

  hrtc->State = HAL_RTC_STATE_READY ;
 8004f78:	2301      	movs	r3, #1
  
  /* Process Unlocked */ 
  __HAL_UNLOCK(hrtc);
 8004f7a:	2000      	movs	r0, #0
    }
    

  }

  hrtc->State = HAL_RTC_STATE_READY ;
 8004f7c:	7463      	strb	r3, [r4, #17]
  
  /* Process Unlocked */ 
  __HAL_UNLOCK(hrtc);
 8004f7e:	7420      	strb	r0, [r4, #16]
  
  return HAL_OK;    
 8004f80:	bd70      	pop	{r4, r5, r6, pc}
  
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));
  
 /* Process Locked */ 
 __HAL_LOCK(hrtc);
 8004f82:	2002      	movs	r0, #2
 8004f84:	4770      	bx	lr
    assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate->Year)));
    assert_param(IS_RTC_MONTH(RTC_Bcd2ToByte(sDate->Month)));
    assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));
    
    /* Change the current date */
    hrtc->DateToUpdate.Year  = RTC_Bcd2ToByte(sDate->Year);
 8004f86:	78ca      	ldrb	r2, [r1, #3]
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint32_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
  return (tmp + (Value & (uint8_t)0x0F));
 8004f88:	0913      	lsrs	r3, r2, #4
 8004f8a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8004f8e:	f002 020f 	and.w	r2, r2, #15
 8004f92:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 8004f96:	b2db      	uxtb	r3, r3
    assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate->Year)));
    assert_param(IS_RTC_MONTH(RTC_Bcd2ToByte(sDate->Month)));
    assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));
    
    /* Change the current date */
    hrtc->DateToUpdate.Year  = RTC_Bcd2ToByte(sDate->Year);
 8004f98:	73c3      	strb	r3, [r0, #15]
    hrtc->DateToUpdate.Month = RTC_Bcd2ToByte(sDate->Month);
 8004f9a:	784a      	ldrb	r2, [r1, #1]
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint32_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
  return (tmp + (Value & (uint8_t)0x0F));
 8004f9c:	0916      	lsrs	r6, r2, #4
 8004f9e:	eb06 0686 	add.w	r6, r6, r6, lsl #2
 8004fa2:	f002 020f 	and.w	r2, r2, #15
 8004fa6:	eb02 0646 	add.w	r6, r2, r6, lsl #1
 8004faa:	b2f6      	uxtb	r6, r6
    assert_param(IS_RTC_MONTH(RTC_Bcd2ToByte(sDate->Month)));
    assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));
    
    /* Change the current date */
    hrtc->DateToUpdate.Year  = RTC_Bcd2ToByte(sDate->Year);
    hrtc->DateToUpdate.Month = RTC_Bcd2ToByte(sDate->Month);
 8004fac:	7346      	strb	r6, [r0, #13]
    hrtc->DateToUpdate.Date  = RTC_Bcd2ToByte(sDate->Date);
 8004fae:	788c      	ldrb	r4, [r1, #2]
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint32_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
  return (tmp + (Value & (uint8_t)0x0F));
 8004fb0:	0922      	lsrs	r2, r4, #4
 8004fb2:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8004fb6:	f004 040f 	and.w	r4, r4, #15
 8004fba:	eb04 0242 	add.w	r2, r4, r2, lsl #1
 8004fbe:	b2d2      	uxtb	r2, r2
    assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));
    
    /* Change the current date */
    hrtc->DateToUpdate.Year  = RTC_Bcd2ToByte(sDate->Year);
    hrtc->DateToUpdate.Month = RTC_Bcd2ToByte(sDate->Month);
    hrtc->DateToUpdate.Date  = RTC_Bcd2ToByte(sDate->Date);
 8004fc0:	7382      	strb	r2, [r0, #14]
 8004fc2:	e7c2      	b.n	8004f4a <HAL_RTC_SetDate+0x26>
  uint32_t counter_time = 0, counter_alarm = 0, hours = 0;
  
  /* Check input parameters */
  if((hrtc == NULL) || (sDate == NULL))
  {
     return HAL_ERROR;
 8004fc4:	2001      	movs	r0, #1
 8004fc6:	4770      	bx	lr
  /* Fill the structure fields with the read parameters */
  hours = counter_time / 3600;
  if (hours > 24)
  {
    /* Set updated time in decreasing counter by number of days elapsed */
    counter_time -= ((hours / 24) * 24 * 3600);
 8004fc8:	4a18      	ldr	r2, [pc, #96]	; (800502c <HAL_RTC_SetDate+0x108>)
 8004fca:	4d19      	ldr	r5, [pc, #100]	; (8005030 <HAL_RTC_SetDate+0x10c>)
 8004fcc:	fba2 1203 	umull	r1, r2, r2, r3
 8004fd0:	0c12      	lsrs	r2, r2, #16
 8004fd2:	fb05 3512 	mls	r5, r5, r2, r3
    /* Write time counter in RTC registers */
    if (RTC_WriteTimeCounter(hrtc, counter_time) != HAL_OK)
 8004fd6:	4620      	mov	r0, r4
 8004fd8:	4629      	mov	r1, r5
 8004fda:	f7ff ff03 	bl	8004de4 <RTC_WriteTimeCounter>
 8004fde:	4606      	mov	r6, r0
 8004fe0:	b9d8      	cbnz	r0, 800501a <HAL_RTC_SetDate+0xf6>
  */
static uint32_t RTC_ReadAlarmCounter(RTC_HandleTypeDef* hrtc)
{
  uint16_t high1 = 0, low = 0;

  high1 = READ_REG(hrtc->Instance->ALRH & RTC_CNTH_RTC_CNT);
 8004fe2:	6823      	ldr	r3, [r4, #0]
 8004fe4:	6a19      	ldr	r1, [r3, #32]
  low   = READ_REG(hrtc->Instance->ALRL & RTC_CNTL_RTC_CNT);
 8004fe6:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  return (((uint32_t) high1 << 16 ) | low);
 8004fe8:	b29b      	uxth	r3, r3
 8004fea:	ea43 4101 	orr.w	r1, r3, r1, lsl #16

    /* Read current Alarm counter in RTC registers */
    counter_alarm = RTC_ReadAlarmCounter(hrtc);

    /* Set again alarm to match with new time if enabled */
    if (counter_alarm != RTC_ALARM_RESETVALUE)
 8004fee:	1c4b      	adds	r3, r1, #1
 8004ff0:	d0c2      	beq.n	8004f78 <HAL_RTC_SetDate+0x54>
    {
      if(counter_alarm < counter_time)
 8004ff2:	428d      	cmp	r5, r1
 8004ff4:	d9c0      	bls.n	8004f78 <HAL_RTC_SetDate+0x54>
      {
        /* Add 1 day to alarm counter*/
        counter_alarm += (uint32_t)(24 * 3600);
        
        /* Write new Alarm counter in RTC registers */
        if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
 8004ff6:	f501 31a8 	add.w	r1, r1, #86016	; 0x15000
 8004ffa:	f501 71c0 	add.w	r1, r1, #384	; 0x180
 8004ffe:	4620      	mov	r0, r4
 8005000:	f7ff ff04 	bl	8004e0c <RTC_WriteAlarmCounter>
 8005004:	2800      	cmp	r0, #0
 8005006:	d0b7      	beq.n	8004f78 <HAL_RTC_SetDate+0x54>
        {
          /* Set RTC state */
          hrtc->State = HAL_RTC_STATE_ERROR;
 8005008:	2304      	movs	r3, #4
          
          /* Process Unlocked */ 
          __HAL_UNLOCK(hrtc);
 800500a:	7426      	strb	r6, [r4, #16]
        
        /* Write new Alarm counter in RTC registers */
        if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
        {
          /* Set RTC state */
          hrtc->State = HAL_RTC_STATE_ERROR;
 800500c:	7463      	strb	r3, [r4, #17]
          
          /* Process Unlocked */ 
          __HAL_UNLOCK(hrtc);
          
          return HAL_ERROR;
 800500e:	2001      	movs	r0, #1
 8005010:	bd70      	pop	{r4, r5, r6, pc}
    timecounter = (((uint32_t) high2 << 16 ) | READ_REG(hrtc->Instance->CNTL & RTC_CNTL_RTC_CNT));
  }
  else
  { /* No counter roll over during reading of CNTL and CNTH registers, counter 
       value is equal to first value of CNTL and CNTH */
    timecounter = (((uint32_t) high1 << 16 ) | low);
 8005012:	b292      	uxth	r2, r2
 8005014:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 8005018:	e7ab      	b.n	8004f72 <HAL_RTC_SetDate+0x4e>
    counter_time -= ((hours / 24) * 24 * 3600);
    /* Write time counter in RTC registers */
    if (RTC_WriteTimeCounter(hrtc, counter_time) != HAL_OK)
    {
      /* Set RTC state */
      hrtc->State = HAL_RTC_STATE_ERROR;
 800501a:	2204      	movs	r2, #4
      
      /* Process Unlocked */ 
      __HAL_UNLOCK(hrtc);
 800501c:	2300      	movs	r3, #0
    counter_time -= ((hours / 24) * 24 * 3600);
    /* Write time counter in RTC registers */
    if (RTC_WriteTimeCounter(hrtc, counter_time) != HAL_OK)
    {
      /* Set RTC state */
      hrtc->State = HAL_RTC_STATE_ERROR;
 800501e:	7462      	strb	r2, [r4, #17]
      
      /* Process Unlocked */ 
      __HAL_UNLOCK(hrtc);
 8005020:	7423      	strb	r3, [r4, #16]
      
      return HAL_ERROR;
 8005022:	2001      	movs	r0, #1
 8005024:	bd70      	pop	{r4, r5, r6, pc}
 8005026:	bf00      	nop
 8005028:	00015f8f 	.word	0x00015f8f
 800502c:	c22e4507 	.word	0xc22e4507
 8005030:	00015180 	.word	0x00015180

08005034 <HAL_RTC_WaitForSynchro>:
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc)
{
  uint32_t tickstart = 0;
  
  /* Check input parameters */
  if(hrtc == NULL)
 8005034:	b1c0      	cbz	r0, 8005068 <HAL_RTC_WaitForSynchro+0x34>
  {
     return HAL_ERROR;
  }
  
  /* Clear RSF flag */
  CLEAR_BIT(hrtc->Instance->CRL, RTC_FLAG_RSF);
 8005036:	6802      	ldr	r2, [r0, #0]
  * @param  hrtc   pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc)
{
 8005038:	b538      	push	{r3, r4, r5, lr}
  {
     return HAL_ERROR;
  }
  
  /* Clear RSF flag */
  CLEAR_BIT(hrtc->Instance->CRL, RTC_FLAG_RSF);
 800503a:	6853      	ldr	r3, [r2, #4]
 800503c:	4604      	mov	r4, r0
 800503e:	f023 0308 	bic.w	r3, r3, #8
 8005042:	6053      	str	r3, [r2, #4]
  
  tickstart = HAL_GetTick();
 8005044:	f7fb f9b8 	bl	80003b8 <HAL_GetTick>
 8005048:	4605      	mov	r5, r0
  
  /* Wait the registers to be synchronised */
  while((hrtc->Instance->CRL & RTC_FLAG_RSF) == (uint32_t)RESET)
 800504a:	e005      	b.n	8005058 <HAL_RTC_WaitForSynchro+0x24>
  {
    if((HAL_GetTick() - tickstart ) >  RTC_TIMEOUT_VALUE)
 800504c:	f7fb f9b4 	bl	80003b8 <HAL_GetTick>
 8005050:	1b40      	subs	r0, r0, r5
 8005052:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8005056:	d805      	bhi.n	8005064 <HAL_RTC_WaitForSynchro+0x30>
  CLEAR_BIT(hrtc->Instance->CRL, RTC_FLAG_RSF);
  
  tickstart = HAL_GetTick();
  
  /* Wait the registers to be synchronised */
  while((hrtc->Instance->CRL & RTC_FLAG_RSF) == (uint32_t)RESET)
 8005058:	6823      	ldr	r3, [r4, #0]
 800505a:	685b      	ldr	r3, [r3, #4]
 800505c:	071b      	lsls	r3, r3, #28
 800505e:	d5f5      	bpl.n	800504c <HAL_RTC_WaitForSynchro+0x18>
    {       
      return HAL_TIMEOUT;
    } 
  }
  
  return HAL_OK;
 8005060:	2000      	movs	r0, #0
 8005062:	bd38      	pop	{r3, r4, r5, pc}
  /* Wait the registers to be synchronised */
  while((hrtc->Instance->CRL & RTC_FLAG_RSF) == (uint32_t)RESET)
  {
    if((HAL_GetTick() - tickstart ) >  RTC_TIMEOUT_VALUE)
    {       
      return HAL_TIMEOUT;
 8005064:	2003      	movs	r0, #3
    } 
  }
  
  return HAL_OK;
}
 8005066:	bd38      	pop	{r3, r4, r5, pc}
  uint32_t tickstart = 0;
  
  /* Check input parameters */
  if(hrtc == NULL)
  {
     return HAL_ERROR;
 8005068:	2001      	movs	r0, #1
      return HAL_TIMEOUT;
    } 
  }
  
  return HAL_OK;
}
 800506a:	4770      	bx	lr

0800506c <HAL_RTC_Init>:
  */
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
  uint32_t prescaler = 0;
  /* Check input parameters */
  if(hrtc == NULL)
 800506c:	2800      	cmp	r0, #0
 800506e:	d04d      	beq.n	800510c <HAL_RTC_Init+0xa0>
  * @param  hrtc   pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
 8005070:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_RTC_ALL_INSTANCE(hrtc->Instance));
  assert_param(IS_RTC_CALIB_OUTPUT(hrtc->Init.OutPut));
  assert_param(IS_RTC_ASYNCH_PREDIV(hrtc->Init.AsynchPrediv));
    
  if(hrtc->State == HAL_RTC_STATE_RESET)
 8005072:	7c43      	ldrb	r3, [r0, #17]
 8005074:	4604      	mov	r4, r0
 8005076:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800507a:	2b00      	cmp	r3, #0
 800507c:	d03a      	beq.n	80050f4 <HAL_RTC_Init+0x88>
    /* Initialize RTC MSP */
    HAL_RTC_MspInit(hrtc);
  }
  
  /* Set RTC state */  
  hrtc->State = HAL_RTC_STATE_BUSY;  
 800507e:	2302      	movs	r3, #2
 8005080:	7463      	strb	r3, [r4, #17]
       
  /* Waiting for synchro */
  if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8005082:	4620      	mov	r0, r4
 8005084:	f7ff ffd6 	bl	8005034 <HAL_RTC_WaitForSynchro>
 8005088:	b118      	cbz	r0, 8005092 <HAL_RTC_Init+0x26>
    MODIFY_REG(hrtc->Instance->PRLL, RTC_PRLL_PRL, (prescaler & RTC_PRLL_PRL));
      
    /* Wait for synchro */
    if(RTC_ExitInitMode(hrtc) != HAL_OK)
    {       
      hrtc->State = HAL_RTC_STATE_ERROR;
 800508a:	2304      	movs	r3, #4
 800508c:	7463      	strb	r3, [r4, #17]
      
      return HAL_ERROR;
 800508e:	2001      	movs	r0, #1
 8005090:	bd38      	pop	{r3, r4, r5, pc}
    
    return HAL_ERROR;
  } 

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8005092:	4620      	mov	r0, r4
 8005094:	f7ff fe74 	bl	8004d80 <RTC_EnterInitMode>
 8005098:	2800      	cmp	r0, #0
 800509a:	d1f6      	bne.n	800508a <HAL_RTC_Init+0x1e>
    return HAL_ERROR;
  } 
  else
  { 
    /* Clear Flags Bits */
    CLEAR_BIT(hrtc->Instance->CRL, (RTC_FLAG_OW | RTC_FLAG_ALRAF | RTC_FLAG_SEC));
 800509c:	6823      	ldr	r3, [r4, #0]
    
    if(hrtc->Init.OutPut != RTC_OUTPUTSOURCE_NONE)
 800509e:	68a2      	ldr	r2, [r4, #8]
    return HAL_ERROR;
  } 
  else
  { 
    /* Clear Flags Bits */
    CLEAR_BIT(hrtc->Instance->CRL, (RTC_FLAG_OW | RTC_FLAG_ALRAF | RTC_FLAG_SEC));
 80050a0:	6859      	ldr	r1, [r3, #4]
 80050a2:	f021 0107 	bic.w	r1, r1, #7
 80050a6:	6059      	str	r1, [r3, #4]
    
    if(hrtc->Init.OutPut != RTC_OUTPUTSOURCE_NONE)
 80050a8:	b122      	cbz	r2, 80050b4 <HAL_RTC_Init+0x48>
    {
      /* Disable the selected Tamper pin */
      CLEAR_BIT(BKP->CR, BKP_CR_TPE);
 80050aa:	4819      	ldr	r0, [pc, #100]	; (8005110 <HAL_RTC_Init+0xa4>)
 80050ac:	6b01      	ldr	r1, [r0, #48]	; 0x30
 80050ae:	f021 0101 	bic.w	r1, r1, #1
 80050b2:	6301      	str	r1, [r0, #48]	; 0x30
    }
    
    /* Set the signal which will be routed to RTC Tamper pin*/
    MODIFY_REG(BKP->RTCCR, (BKP_RTCCR_CCO | BKP_RTCCR_ASOE | BKP_RTCCR_ASOS), hrtc->Init.OutPut);
 80050b4:	4816      	ldr	r0, [pc, #88]	; (8005110 <HAL_RTC_Init+0xa4>)
 80050b6:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 80050b8:	f421 7160 	bic.w	r1, r1, #896	; 0x380
 80050bc:	430a      	orrs	r2, r1
 80050be:	62c2      	str	r2, [r0, #44]	; 0x2c

    if (hrtc->Init.AsynchPrediv != RTC_AUTO_1_SECOND)
 80050c0:	6860      	ldr	r0, [r4, #4]
 80050c2:	1c42      	adds	r2, r0, #1
 80050c4:	d01a      	beq.n	80050fc <HAL_RTC_Init+0x90>
        prescaler = prescaler - 1;
      }
    }
    
    /* Configure the RTC_PRLH / RTC_PRLL */
    MODIFY_REG(hrtc->Instance->PRLH, RTC_PRLH_PRL, (prescaler >> 16));
 80050c6:	6899      	ldr	r1, [r3, #8]
    MODIFY_REG(hrtc->Instance->PRLL, RTC_PRLL_PRL, (prescaler & RTC_PRLL_PRL));
 80050c8:	b285      	uxth	r5, r0
        prescaler = prescaler - 1;
      }
    }
    
    /* Configure the RTC_PRLH / RTC_PRLL */
    MODIFY_REG(hrtc->Instance->PRLH, RTC_PRLH_PRL, (prescaler >> 16));
 80050ca:	f021 010f 	bic.w	r1, r1, #15
 80050ce:	ea41 4010 	orr.w	r0, r1, r0, lsr #16
 80050d2:	6098      	str	r0, [r3, #8]
    MODIFY_REG(hrtc->Instance->PRLL, RTC_PRLL_PRL, (prescaler & RTC_PRLL_PRL));
 80050d4:	68da      	ldr	r2, [r3, #12]
      
    /* Wait for synchro */
    if(RTC_ExitInitMode(hrtc) != HAL_OK)
 80050d6:	4620      	mov	r0, r4
      }
    }
    
    /* Configure the RTC_PRLH / RTC_PRLL */
    MODIFY_REG(hrtc->Instance->PRLH, RTC_PRLH_PRL, (prescaler >> 16));
    MODIFY_REG(hrtc->Instance->PRLL, RTC_PRLL_PRL, (prescaler & RTC_PRLL_PRL));
 80050d8:	0c12      	lsrs	r2, r2, #16
 80050da:	0412      	lsls	r2, r2, #16
 80050dc:	432a      	orrs	r2, r5
 80050de:	60da      	str	r2, [r3, #12]
      
    /* Wait for synchro */
    if(RTC_ExitInitMode(hrtc) != HAL_OK)
 80050e0:	f7ff fe66 	bl	8004db0 <RTC_ExitInitMode>
 80050e4:	2800      	cmp	r0, #0
 80050e6:	d1d0      	bne.n	800508a <HAL_RTC_Init+0x1e>
      return HAL_ERROR;
    }
    
    /* Initialize date to 1st of January 2000 */
    hrtc->DateToUpdate.Year = 0x00;
    hrtc->DateToUpdate.Month = RTC_MONTH_JANUARY;
 80050e8:	2301      	movs	r3, #1
      
      return HAL_ERROR;
    }
    
    /* Initialize date to 1st of January 2000 */
    hrtc->DateToUpdate.Year = 0x00;
 80050ea:	73e0      	strb	r0, [r4, #15]
    hrtc->DateToUpdate.Month = RTC_MONTH_JANUARY;
 80050ec:	7363      	strb	r3, [r4, #13]
    hrtc->DateToUpdate.Date = 0x01;
 80050ee:	73a3      	strb	r3, [r4, #14]

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_READY;
 80050f0:	7463      	strb	r3, [r4, #17]
    
    return HAL_OK;
 80050f2:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_RTC_ASYNCH_PREDIV(hrtc->Init.AsynchPrediv));
    
  if(hrtc->State == HAL_RTC_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    hrtc->Lock = HAL_UNLOCKED;
 80050f4:	7402      	strb	r2, [r0, #16]
    
    /* Initialize RTC MSP */
    HAL_RTC_MspInit(hrtc);
 80050f6:	f7fe ffc9 	bl	800408c <HAL_RTC_MspInit>
 80050fa:	e7c0      	b.n	800507e <HAL_RTC_Init+0x12>
    }
    else
    {
      /* RTC Prescaler will be automatically calculated to get 1 second timebase */
      /* Get the RTCCLK frequency */
      prescaler = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_RTC);
 80050fc:	2001      	movs	r0, #1
 80050fe:	f7fb f891 	bl	8000224 <HAL_RCCEx_GetPeriphCLKFreq>

      /* Check that RTC clock is enabled*/
      if (prescaler == 0)
 8005102:	2800      	cmp	r0, #0
 8005104:	d0c1      	beq.n	800508a <HAL_RTC_Init+0x1e>
 8005106:	6823      	ldr	r3, [r4, #0]
        return HAL_ERROR;
      }
      else
      {
        /* RTC period = RTCCLK/(RTC_PR + 1) */
        prescaler = prescaler - 1;
 8005108:	3801      	subs	r0, #1
 800510a:	e7dc      	b.n	80050c6 <HAL_RTC_Init+0x5a>
{
  uint32_t prescaler = 0;
  /* Check input parameters */
  if(hrtc == NULL)
  {
     return HAL_ERROR;
 800510c:	2001      	movs	r0, #1
 800510e:	4770      	bx	lr
 8005110:	40006c00 	.word	0x40006c00

08005114 <TIM_OC1_SetConfig>:
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

   /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8005114:	6a03      	ldr	r3, [r0, #32]
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8005116:	688a      	ldr	r2, [r1, #8]
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

   /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8005118:	f023 0301 	bic.w	r3, r3, #1
 800511c:	6203      	str	r3, [r0, #32]
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config : The ouput configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800511e:	b4f0      	push	{r4, r5, r6, r7}

   /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8005120:	6a03      	ldr	r3, [r0, #32]
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8005122:	4e11      	ldr	r6, [pc, #68]	; (8005168 <TIM_OC1_SetConfig+0x54>)
  TIMx->CCER &= ~TIM_CCER_CC1E;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8005124:	6847      	ldr	r7, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8005126:	6985      	ldr	r5, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8005128:	680c      	ldr	r4, [r1, #0]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 800512a:	f023 0302 	bic.w	r3, r3, #2
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800512e:	f025 0573 	bic.w	r5, r5, #115	; 0x73
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8005132:	42b0      	cmp	r0, r6
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8005134:	ea43 0302 	orr.w	r3, r3, r2

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8005138:	ea44 0405 	orr.w	r4, r4, r5
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 800513c:	d006      	beq.n	800514c <TIM_OC1_SetConfig+0x38>

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 800513e:	684a      	ldr	r2, [r1, #4]
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8005140:	6047      	str	r7, [r0, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8005142:	6184      	str	r4, [r0, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8005144:	6342      	str	r2, [r0, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 8005146:	bcf0      	pop	{r4, r5, r6, r7}

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8005148:	6203      	str	r3, [r0, #32]
}
 800514a:	4770      	bx	lr
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 800514c:	68cd      	ldr	r5, [r1, #12]
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 800514e:	694e      	ldr	r6, [r1, #20]
 8005150:	698a      	ldr	r2, [r1, #24]
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 8005152:	f023 0308 	bic.w	r3, r3, #8
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8005156:	f427 7740 	bic.w	r7, r7, #768	; 0x300
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 800515a:	432b      	orrs	r3, r5
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 800515c:	4332      	orrs	r2, r6
    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 800515e:	f023 0304 	bic.w	r3, r3, #4
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8005162:	4317      	orrs	r7, r2
 8005164:	e7eb      	b.n	800513e <TIM_OC1_SetConfig+0x2a>
 8005166:	bf00      	nop
 8005168:	40012c00 	.word	0x40012c00

0800516c <TIM_OC3_SetConfig>:
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 800516c:	6a02      	ldr	r2, [r0, #32]
  * @param  TIMx  to select the TIM peripheral
  * @param  OC_Config : The ouput configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800516e:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8005170:	f422 7280 	bic.w	r2, r2, #256	; 0x100
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8);
 8005174:	688e      	ldr	r6, [r1, #8]
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8005176:	6202      	str	r2, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8005178:	6a03      	ldr	r3, [r0, #32]
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8);

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 800517a:	4d12      	ldr	r5, [pc, #72]	; (80051c4 <TIM_OC3_SetConfig+0x58>)
  TIMx->CCER &= ~TIM_CCER_CC3E;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800517c:	6847      	ldr	r7, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800517e:	69c4      	ldr	r4, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8005180:	680a      	ldr	r2, [r1, #0]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 8005182:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8005186:	f024 0473 	bic.w	r4, r4, #115	; 0x73
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8);

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 800518a:	42a8      	cmp	r0, r5
  tmpccmrx |= OC_Config->OCMode;

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8);
 800518c:	ea43 2306 	orr.w	r3, r3, r6, lsl #8

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8005190:	ea42 0204 	orr.w	r2, r2, r4
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8);

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8005194:	d006      	beq.n	80051a4 <TIM_OC3_SetConfig+0x38>

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8005196:	6849      	ldr	r1, [r1, #4]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4);
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8005198:	6047      	str	r7, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 800519a:	61c2      	str	r2, [r0, #28]
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 800519c:	bcf0      	pop	{r4, r5, r6, r7}

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 800519e:	63c1      	str	r1, [r0, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80051a0:	6203      	str	r3, [r0, #32]
}
 80051a2:	4770      	bx	lr
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8);
 80051a4:	68ce      	ldr	r6, [r1, #12]

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4);
 80051a6:	694d      	ldr	r5, [r1, #20]
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
 80051a8:	f427 5740 	bic.w	r7, r7, #12288	; 0x3000
  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 80051ac:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4);
 80051b0:	698c      	ldr	r4, [r1, #24]
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8);
 80051b2:	ea43 2306 	orr.w	r3, r3, r6, lsl #8

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4);
 80051b6:	ea47 1505 	orr.w	r5, r7, r5, lsl #4
    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 80051ba:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4);
 80051be:	ea45 1704 	orr.w	r7, r5, r4, lsl #4
 80051c2:	e7e8      	b.n	8005196 <TIM_OC3_SetConfig+0x2a>
 80051c4:	40012c00 	.word	0x40012c00

080051c8 <TIM_OC4_SetConfig>:
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 80051c8:	6a02      	ldr	r2, [r0, #32]
  * @param  TIMx  to select the TIM peripheral
  * @param  OC_Config : The ouput configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 80051ca:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 80051cc:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12);
 80051d0:	688f      	ldr	r7, [r1, #8]
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 80051d2:	6202      	str	r2, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80051d4:	6a03      	ldr	r3, [r0, #32]
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12);

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 80051d6:	4e0d      	ldr	r6, [pc, #52]	; (800520c <TIM_OC4_SetConfig+0x44>)
  TIMx->CCER &= ~TIM_CCER_CC4E;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80051d8:	6845      	ldr	r5, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 80051da:	69c2      	ldr	r2, [r0, #28]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 80051dc:	680c      	ldr	r4, [r1, #0]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 80051de:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 80051e2:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12);

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 80051e6:	42b0      	cmp	r0, r6
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12);
 80051e8:	ea43 3307 	orr.w	r3, r3, r7, lsl #12
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 80051ec:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12);

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 80051f0:	d006      	beq.n	8005200 <TIM_OC4_SetConfig+0x38>

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 80051f2:	6849      	ldr	r1, [r1, #4]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6);
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80051f4:	6045      	str	r5, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 80051f6:	61c2      	str	r2, [r0, #28]
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 80051f8:	bcf0      	pop	{r4, r5, r6, r7}

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 80051fa:	6401      	str	r1, [r0, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80051fc:	6203      	str	r3, [r0, #32]
}
 80051fe:	4770      	bx	lr
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

   /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6);
 8005200:	694c      	ldr	r4, [r1, #20]
  if(IS_TIM_BREAK_INSTANCE(TIMx))
  {
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

   /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 8005202:	f425 4580 	bic.w	r5, r5, #16384	; 0x4000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6);
 8005206:	ea45 1584 	orr.w	r5, r5, r4, lsl #6
 800520a:	e7f2      	b.n	80051f2 <TIM_OC4_SetConfig+0x2a>
 800520c:	40012c00 	.word	0x40012c00

08005210 <HAL_TIM_PWM_MspInit>:
 8005210:	4770      	bx	lr
 8005212:	bf00      	nop

08005214 <HAL_TIM_ConfigClockSource>:
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
{
  uint32_t tmpsmcr = 0;

  /* Process Locked */
  __HAL_LOCK(htim);
 8005214:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8005218:	2b01      	cmp	r3, #1
 800521a:	d040      	beq.n	800529e <HAL_TIM_ConfigClockSource+0x8a>

  htim->State = HAL_TIM_STATE_BUSY;
 800521c:	2202      	movs	r2, #2

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 800521e:	6803      	ldr	r3, [r0, #0]
  * @param  sClockSourceConfig : pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */ 
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
{
 8005220:	b470      	push	{r4, r5, r6}
  uint32_t tmpsmcr = 0;

  /* Process Locked */
  __HAL_LOCK(htim);

  htim->State = HAL_TIM_STATE_BUSY;
 8005222:	f880 2039 	strb.w	r2, [r0, #57]	; 0x39

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 8005226:	689a      	ldr	r2, [r3, #8]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
  htim->Instance->SMCR = tmpsmcr;

  switch (sClockSourceConfig->ClockSource)
 8005228:	680c      	ldr	r4, [r1, #0]
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800522a:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 800522e:	f022 0277 	bic.w	r2, r2, #119	; 0x77
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
{
  uint32_t tmpsmcr = 0;

  /* Process Locked */
  __HAL_LOCK(htim);
 8005232:	2501      	movs	r5, #1
  tmpsmcr = htim->Instance->SMCR;
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
  htim->Instance->SMCR = tmpsmcr;

  switch (sClockSourceConfig->ClockSource)
 8005234:	2c40      	cmp	r4, #64	; 0x40
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
{
  uint32_t tmpsmcr = 0;

  /* Process Locked */
  __HAL_LOCK(htim);
 8005236:	f880 5038 	strb.w	r5, [r0, #56]	; 0x38

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
  htim->Instance->SMCR = tmpsmcr;
 800523a:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
 800523c:	d073      	beq.n	8005326 <HAL_TIM_ConfigClockSource+0x112>
 800523e:	d918      	bls.n	8005272 <HAL_TIM_ConfigClockSource+0x5e>
 8005240:	2c70      	cmp	r4, #112	; 0x70
 8005242:	d060      	beq.n	8005306 <HAL_TIM_ConfigClockSource+0xf2>
 8005244:	d92d      	bls.n	80052a2 <HAL_TIM_ConfigClockSource+0x8e>
 8005246:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 800524a:	d057      	beq.n	80052fc <HAL_TIM_ConfigClockSource+0xe8>
 800524c:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
 8005250:	d11c      	bne.n	800528c <HAL_TIM_ConfigClockSource+0x78>
static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
  uint32_t tmpsmcr = 0;

  tmpsmcr = TIMx->SMCR;
 8005252:	689c      	ldr	r4, [r3, #8]
 8005254:	688d      	ldr	r5, [r1, #8]
 8005256:	684a      	ldr	r2, [r1, #4]
 8005258:	f424 447f 	bic.w	r4, r4, #65280	; 0xff00

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
 800525c:	68c9      	ldr	r1, [r1, #12]
 800525e:	432a      	orrs	r2, r5
 8005260:	4322      	orrs	r2, r4
 8005262:	ea42 2201 	orr.w	r2, r2, r1, lsl #8

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8005266:	609a      	str	r2, [r3, #8]
      TIM_ETR_SetConfig(htim->Instance,
                        sClockSourceConfig->ClockPrescaler,
                        sClockSourceConfig->ClockPolarity,
                        sClockSourceConfig->ClockFilter);
      /* Enable the External clock mode2 */
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 8005268:	689a      	ldr	r2, [r3, #8]
 800526a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800526e:	609a      	str	r2, [r3, #8]
    }
    break;
 8005270:	e00c      	b.n	800528c <HAL_TIM_ConfigClockSource+0x78>
  tmpsmcr = htim->Instance->SMCR;
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
  htim->Instance->SMCR = tmpsmcr;

  switch (sClockSourceConfig->ClockSource)
 8005272:	2c10      	cmp	r4, #16
 8005274:	d032      	beq.n	80052dc <HAL_TIM_ConfigClockSource+0xc8>
 8005276:	d938      	bls.n	80052ea <HAL_TIM_ConfigClockSource+0xd6>
 8005278:	2c20      	cmp	r4, #32
 800527a:	d06c      	beq.n	8005356 <HAL_TIM_ConfigClockSource+0x142>
 800527c:	2c30      	cmp	r4, #48	; 0x30
 800527e:	d105      	bne.n	800528c <HAL_TIM_ConfigClockSource+0x78>
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
{
  uint32_t tmpsmcr = 0;

   /* Get the TIMx SMCR register value */
   tmpsmcr = TIMx->SMCR;
 8005280:	689a      	ldr	r2, [r3, #8]
   /* Reset the TS Bits */
   tmpsmcr &= ~TIM_SMCR_TS;
 8005282:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   /* Set the Input Trigger source and the slave mode*/
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 8005286:	f042 0237 	orr.w	r2, r2, #55	; 0x37
   /* Write to TIMx SMCR */
   TIMx->SMCR = tmpsmcr;
 800528a:	609a      	str	r2, [r3, #8]
  default:
    break;
  }
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);
 800528c:	2300      	movs	r3, #0
    break;

  default:
    break;
  }
  htim->State = HAL_TIM_STATE_READY;
 800528e:	2201      	movs	r2, #1
 8005290:	f880 2039 	strb.w	r2, [r0, #57]	; 0x39

  __HAL_UNLOCK(htim);
 8005294:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38

  return HAL_OK;
}
 8005298:	bc70      	pop	{r4, r5, r6}
  }
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);

  return HAL_OK;
 800529a:	4618      	mov	r0, r3
}
 800529c:	4770      	bx	lr
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
{
  uint32_t tmpsmcr = 0;

  /* Process Locked */
  __HAL_LOCK(htim);
 800529e:	2002      	movs	r0, #2
 80052a0:	4770      	bx	lr
  tmpsmcr = htim->Instance->SMCR;
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
  htim->Instance->SMCR = tmpsmcr;

  switch (sClockSourceConfig->ClockSource)
 80052a2:	2c50      	cmp	r4, #80	; 0x50
 80052a4:	d05e      	beq.n	8005364 <HAL_TIM_ConfigClockSource+0x150>
 80052a6:	2c60      	cmp	r4, #96	; 0x60
 80052a8:	d1f0      	bne.n	800528c <HAL_TIM_ConfigClockSource+0x78>
{
  uint32_t tmpccmr1 = 0;
  uint32_t tmpccer = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80052aa:	6a1c      	ldr	r4, [r3, #32]

       /* Check TI2 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI2_ConfigInputStage(htim->Instance,
 80052ac:	684d      	ldr	r5, [r1, #4]
{
  uint32_t tmpccmr1 = 0;
  uint32_t tmpccer = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80052ae:	f024 0410 	bic.w	r4, r4, #16

       /* Check TI2 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI2_ConfigInputStage(htim->Instance,
 80052b2:	68ce      	ldr	r6, [r1, #12]
{
  uint32_t tmpccmr1 = 0;
  uint32_t tmpccer = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80052b4:	621c      	str	r4, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 80052b6:	6999      	ldr	r1, [r3, #24]
  tmpccer = TIMx->CCER;
 80052b8:	6a1a      	ldr	r2, [r3, #32]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 80052ba:	f421 4170 	bic.w	r1, r1, #61440	; 0xf000
  tmpccmr1 |= (TIM_ICFilter << 12);

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 80052be:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
  tmpccer |= (TIM_ICPolarity << 4);
 80052c2:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
  tmpccmr1 |= (TIM_ICFilter << 12);
 80052c6:	ea41 3106 	orr.w	r1, r1, r6, lsl #12
  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
  tmpccer |= (TIM_ICPolarity << 4);

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 80052ca:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
 80052cc:	621a      	str	r2, [r3, #32]
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
{
  uint32_t tmpsmcr = 0;

   /* Get the TIMx SMCR register value */
   tmpsmcr = TIMx->SMCR;
 80052ce:	689a      	ldr	r2, [r3, #8]
   /* Reset the TS Bits */
   tmpsmcr &= ~TIM_SMCR_TS;
 80052d0:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   /* Set the Input Trigger source and the slave mode*/
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 80052d4:	f042 0267 	orr.w	r2, r2, #103	; 0x67
   /* Write to TIMx SMCR */
   TIMx->SMCR = tmpsmcr;
 80052d8:	609a      	str	r2, [r3, #8]
 80052da:	e7d7      	b.n	800528c <HAL_TIM_ConfigClockSource+0x78>
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
{
  uint32_t tmpsmcr = 0;

   /* Get the TIMx SMCR register value */
   tmpsmcr = TIMx->SMCR;
 80052dc:	689a      	ldr	r2, [r3, #8]
   /* Reset the TS Bits */
   tmpsmcr &= ~TIM_SMCR_TS;
 80052de:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   /* Set the Input Trigger source and the slave mode*/
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 80052e2:	f042 0217 	orr.w	r2, r2, #23
   /* Write to TIMx SMCR */
   TIMx->SMCR = tmpsmcr;
 80052e6:	609a      	str	r2, [r3, #8]
 80052e8:	e7d0      	b.n	800528c <HAL_TIM_ConfigClockSource+0x78>
  tmpsmcr = htim->Instance->SMCR;
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
  htim->Instance->SMCR = tmpsmcr;

  switch (sClockSourceConfig->ClockSource)
 80052ea:	2c00      	cmp	r4, #0
 80052ec:	d1ce      	bne.n	800528c <HAL_TIM_ConfigClockSource+0x78>
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
{
  uint32_t tmpsmcr = 0;

   /* Get the TIMx SMCR register value */
   tmpsmcr = TIMx->SMCR;
 80052ee:	689a      	ldr	r2, [r3, #8]
   /* Reset the TS Bits */
   tmpsmcr &= ~TIM_SMCR_TS;
 80052f0:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   /* Set the Input Trigger source and the slave mode*/
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 80052f4:	f042 0207 	orr.w	r2, r2, #7
   /* Write to TIMx SMCR */
   TIMx->SMCR = tmpsmcr;
 80052f8:	609a      	str	r2, [r3, #8]
 80052fa:	e7c7      	b.n	800528c <HAL_TIM_ConfigClockSource+0x78>
  {
  case TIM_CLOCKSOURCE_INTERNAL:
    {
      assert_param(IS_TIM_INSTANCE(htim->Instance));
      /* Disable slave mode to clock the prescaler directly with the internal clock */
      htim->Instance->SMCR &= ~TIM_SMCR_SMS;
 80052fc:	689a      	ldr	r2, [r3, #8]
 80052fe:	f022 0207 	bic.w	r2, r2, #7
 8005302:	609a      	str	r2, [r3, #8]
    }
    break;
 8005304:	e7c2      	b.n	800528c <HAL_TIM_ConfigClockSource+0x78>
static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
  uint32_t tmpsmcr = 0;

  tmpsmcr = TIMx->SMCR;
 8005306:	689c      	ldr	r4, [r3, #8]
 8005308:	688d      	ldr	r5, [r1, #8]
 800530a:	684a      	ldr	r2, [r1, #4]
 800530c:	f424 447f 	bic.w	r4, r4, #65280	; 0xff00

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
 8005310:	68c9      	ldr	r1, [r1, #12]
 8005312:	432a      	orrs	r2, r5
 8005314:	4322      	orrs	r2, r4
 8005316:	ea42 2201 	orr.w	r2, r2, r1, lsl #8

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800531a:	609a      	str	r2, [r3, #8]
      TIM_ETR_SetConfig(htim->Instance,
                        sClockSourceConfig->ClockPrescaler,
                        sClockSourceConfig->ClockPolarity,
                        sClockSourceConfig->ClockFilter);
      /* Get the TIMx SMCR register value */
      tmpsmcr = htim->Instance->SMCR;
 800531c:	689a      	ldr	r2, [r3, #8]
      /* Reset the SMS and TS Bits */
      tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
      /* Select the External clock mode1 and the ETRF trigger */
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 800531e:	f042 0277 	orr.w	r2, r2, #119	; 0x77
      /* Write to TIMx SMCR */
      htim->Instance->SMCR = tmpsmcr;
 8005322:	609a      	str	r2, [r3, #8]
    }
    break;
 8005324:	e7b2      	b.n	800528c <HAL_TIM_ConfigClockSource+0x78>
{
  uint32_t tmpccmr1 = 0;
  uint32_t tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 8005326:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8005328:	6a1c      	ldr	r4, [r3, #32]

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 800532a:	684e      	ldr	r6, [r1, #4]
  uint32_t tmpccmr1 = 0;
  uint32_t tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800532c:	f024 0401 	bic.w	r4, r4, #1

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 8005330:	68cd      	ldr	r5, [r1, #12]
  uint32_t tmpccmr1 = 0;
  uint32_t tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8005332:	621c      	str	r4, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8005334:	6999      	ldr	r1, [r3, #24]
  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
  tmpccmr1 |= (TIM_ICFilter << 4);

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8005336:	f022 020a 	bic.w	r2, r2, #10
  tmpccer = TIMx->CCER;
  TIMx->CCER &= ~TIM_CCER_CC1E;
  tmpccmr1 = TIMx->CCMR1;

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800533a:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4);

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= TIM_ICPolarity;
 800533e:	4332      	orrs	r2, r6
  TIMx->CCER &= ~TIM_CCER_CC1E;
  tmpccmr1 = TIMx->CCMR1;

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
  tmpccmr1 |= (TIM_ICFilter << 4);
 8005340:	ea41 1105 	orr.w	r1, r1, r5, lsl #4
  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= TIM_ICPolarity;

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8005344:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
 8005346:	621a      	str	r2, [r3, #32]
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
{
  uint32_t tmpsmcr = 0;

   /* Get the TIMx SMCR register value */
   tmpsmcr = TIMx->SMCR;
 8005348:	689a      	ldr	r2, [r3, #8]
   /* Reset the TS Bits */
   tmpsmcr &= ~TIM_SMCR_TS;
 800534a:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   /* Set the Input Trigger source and the slave mode*/
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 800534e:	f042 0247 	orr.w	r2, r2, #71	; 0x47
   /* Write to TIMx SMCR */
   TIMx->SMCR = tmpsmcr;
 8005352:	609a      	str	r2, [r3, #8]
 8005354:	e79a      	b.n	800528c <HAL_TIM_ConfigClockSource+0x78>
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
{
  uint32_t tmpsmcr = 0;

   /* Get the TIMx SMCR register value */
   tmpsmcr = TIMx->SMCR;
 8005356:	689a      	ldr	r2, [r3, #8]
   /* Reset the TS Bits */
   tmpsmcr &= ~TIM_SMCR_TS;
 8005358:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   /* Set the Input Trigger source and the slave mode*/
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 800535c:	f042 0227 	orr.w	r2, r2, #39	; 0x27
   /* Write to TIMx SMCR */
   TIMx->SMCR = tmpsmcr;
 8005360:	609a      	str	r2, [r3, #8]
 8005362:	e793      	b.n	800528c <HAL_TIM_ConfigClockSource+0x78>
{
  uint32_t tmpccmr1 = 0;
  uint32_t tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 8005364:	6a1a      	ldr	r2, [r3, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8005366:	6a1c      	ldr	r4, [r3, #32]

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
      
      TIM_TI1_ConfigInputStage(htim->Instance,
 8005368:	684e      	ldr	r6, [r1, #4]
  uint32_t tmpccmr1 = 0;
  uint32_t tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800536a:	f024 0401 	bic.w	r4, r4, #1

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
      
      TIM_TI1_ConfigInputStage(htim->Instance,
 800536e:	68cd      	ldr	r5, [r1, #12]
  uint32_t tmpccmr1 = 0;
  uint32_t tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8005370:	621c      	str	r4, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8005372:	6999      	ldr	r1, [r3, #24]
  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
  tmpccmr1 |= (TIM_ICFilter << 4);

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8005374:	f022 020a 	bic.w	r2, r2, #10
  tmpccer = TIMx->CCER;
  TIMx->CCER &= ~TIM_CCER_CC1E;
  tmpccmr1 = TIMx->CCMR1;

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8005378:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4);

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= TIM_ICPolarity;
 800537c:	4332      	orrs	r2, r6
  TIMx->CCER &= ~TIM_CCER_CC1E;
  tmpccmr1 = TIMx->CCMR1;

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
  tmpccmr1 |= (TIM_ICFilter << 4);
 800537e:	ea41 1105 	orr.w	r1, r1, r5, lsl #4
  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= TIM_ICPolarity;

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8005382:	6199      	str	r1, [r3, #24]
  TIMx->CCER = tmpccer;
 8005384:	621a      	str	r2, [r3, #32]
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
{
  uint32_t tmpsmcr = 0;

   /* Get the TIMx SMCR register value */
   tmpsmcr = TIMx->SMCR;
 8005386:	689a      	ldr	r2, [r3, #8]
   /* Reset the TS Bits */
   tmpsmcr &= ~TIM_SMCR_TS;
 8005388:	f022 0270 	bic.w	r2, r2, #112	; 0x70
   /* Set the Input Trigger source and the slave mode*/
   tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
 800538c:	f042 0257 	orr.w	r2, r2, #87	; 0x57
   /* Write to TIMx SMCR */
   TIMx->SMCR = tmpsmcr;
 8005390:	609a      	str	r2, [r3, #8]
 8005392:	e77b      	b.n	800528c <HAL_TIM_ConfigClockSource+0x78>

08005394 <HAL_TIM_PeriodElapsedCallback>:
 8005394:	4770      	bx	lr
 8005396:	bf00      	nop

08005398 <HAL_TIM_OC_DelayElapsedCallback>:
 8005398:	4770      	bx	lr
 800539a:	bf00      	nop

0800539c <HAL_TIM_IC_CaptureCallback>:
 800539c:	4770      	bx	lr
 800539e:	bf00      	nop

080053a0 <HAL_TIM_PWM_PulseFinishedCallback>:
 80053a0:	4770      	bx	lr
 80053a2:	bf00      	nop

080053a4 <HAL_TIM_TriggerCallback>:
 80053a4:	4770      	bx	lr
 80053a6:	bf00      	nop

080053a8 <HAL_TIM_IRQHandler>:
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
  /* Capture compare 1 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80053a8:	6803      	ldr	r3, [r0, #0]
  * @brief  This function handles TIM interrupts requests.
  * @param  htim : TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 80053aa:	b510      	push	{r4, lr}
  /* Capture compare 1 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80053ac:	691a      	ldr	r2, [r3, #16]
  * @brief  This function handles TIM interrupts requests.
  * @param  htim : TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 80053ae:	4604      	mov	r4, r0
  /* Capture compare 1 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80053b0:	0791      	lsls	r1, r2, #30
 80053b2:	d502      	bpl.n	80053ba <HAL_TIM_IRQHandler+0x12>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
 80053b4:	68da      	ldr	r2, [r3, #12]
 80053b6:	0792      	lsls	r2, r2, #30
 80053b8:	d462      	bmi.n	8005480 <HAL_TIM_IRQHandler+0xd8>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
      }
    }
  }
  /* Capture compare 2 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 80053ba:	691a      	ldr	r2, [r3, #16]
 80053bc:	0750      	lsls	r0, r2, #29
 80053be:	d502      	bpl.n	80053c6 <HAL_TIM_IRQHandler+0x1e>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
 80053c0:	68da      	ldr	r2, [r3, #12]
 80053c2:	0751      	lsls	r1, r2, #29
 80053c4:	d449      	bmi.n	800545a <HAL_TIM_IRQHandler+0xb2>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
    }
  }
  /* Capture compare 3 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 80053c6:	691a      	ldr	r2, [r3, #16]
 80053c8:	0712      	lsls	r2, r2, #28
 80053ca:	d502      	bpl.n	80053d2 <HAL_TIM_IRQHandler+0x2a>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
 80053cc:	68da      	ldr	r2, [r3, #12]
 80053ce:	0710      	lsls	r0, r2, #28
 80053d0:	d431      	bmi.n	8005436 <HAL_TIM_IRQHandler+0x8e>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
    }
  }
  /* Capture compare 4 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 80053d2:	691a      	ldr	r2, [r3, #16]
 80053d4:	06d2      	lsls	r2, r2, #27
 80053d6:	d502      	bpl.n	80053de <HAL_TIM_IRQHandler+0x36>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
 80053d8:	68da      	ldr	r2, [r3, #12]
 80053da:	06d0      	lsls	r0, r2, #27
 80053dc:	d418      	bmi.n	8005410 <HAL_TIM_IRQHandler+0x68>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
    }
  }
  /* TIM Update event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 80053de:	691a      	ldr	r2, [r3, #16]
 80053e0:	07d1      	lsls	r1, r2, #31
 80053e2:	d502      	bpl.n	80053ea <HAL_TIM_IRQHandler+0x42>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
 80053e4:	68da      	ldr	r2, [r3, #12]
 80053e6:	07d2      	lsls	r2, r2, #31
 80053e8:	d46b      	bmi.n	80054c2 <HAL_TIM_IRQHandler+0x11a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
      HAL_TIM_PeriodElapsedCallback(htim);
    }
  }
  /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 80053ea:	691a      	ldr	r2, [r3, #16]
 80053ec:	0610      	lsls	r0, r2, #24
 80053ee:	d502      	bpl.n	80053f6 <HAL_TIM_IRQHandler+0x4e>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 80053f0:	68da      	ldr	r2, [r3, #12]
 80053f2:	0611      	lsls	r1, r2, #24
 80053f4:	d46d      	bmi.n	80054d2 <HAL_TIM_IRQHandler+0x12a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
      HAL_TIMEx_BreakCallback(htim);
    }
  }
  /* TIM Trigger detection event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 80053f6:	691a      	ldr	r2, [r3, #16]
 80053f8:	0652      	lsls	r2, r2, #25
 80053fa:	d502      	bpl.n	8005402 <HAL_TIM_IRQHandler+0x5a>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
 80053fc:	68da      	ldr	r2, [r3, #12]
 80053fe:	0650      	lsls	r0, r2, #25
 8005400:	d457      	bmi.n	80054b2 <HAL_TIM_IRQHandler+0x10a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
      HAL_TIM_TriggerCallback(htim);
    }
  }
  /* TIM commutation event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8005402:	691a      	ldr	r2, [r3, #16]
 8005404:	0691      	lsls	r1, r2, #26
 8005406:	d502      	bpl.n	800540e <HAL_TIM_IRQHandler+0x66>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
 8005408:	68da      	ldr	r2, [r3, #12]
 800540a:	0692      	lsls	r2, r2, #26
 800540c:	d449      	bmi.n	80054a2 <HAL_TIM_IRQHandler+0xfa>
 800540e:	bd10      	pop	{r4, pc}
  /* Capture compare 4 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8005410:	f06f 0210 	mvn.w	r2, #16
 8005414:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
 8005416:	69db      	ldr	r3, [r3, #28]
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8005418:	2208      	movs	r2, #8
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
 800541a:	f413 7f40 	tst.w	r3, #768	; 0x300
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800541e:	7622      	strb	r2, [r4, #24]
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
      {
        HAL_TIM_IC_CaptureCallback(htim);
 8005420:	4620      	mov	r0, r4
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
 8005422:	d161      	bne.n	80054e8 <HAL_TIM_IRQHandler+0x140>
        HAL_TIM_IC_CaptureCallback(htim);
      }
      /* Output compare event */
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8005424:	f7ff ffb8 	bl	8005398 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8005428:	4620      	mov	r0, r4
 800542a:	f7ff ffb9 	bl	80053a0 <HAL_TIM_PWM_PulseFinishedCallback>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800542e:	2200      	movs	r2, #0
 8005430:	6823      	ldr	r3, [r4, #0]
 8005432:	7622      	strb	r2, [r4, #24]
 8005434:	e7d3      	b.n	80053de <HAL_TIM_IRQHandler+0x36>
  /* Capture compare 3 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8005436:	f06f 0208 	mvn.w	r2, #8
 800543a:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
 800543c:	69db      	ldr	r3, [r3, #28]
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800543e:	2204      	movs	r2, #4
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
 8005440:	0799      	lsls	r1, r3, #30
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8005442:	7622      	strb	r2, [r4, #24]
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
      {
        HAL_TIM_IC_CaptureCallback(htim);
 8005444:	4620      	mov	r0, r4
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
 8005446:	d155      	bne.n	80054f4 <HAL_TIM_IRQHandler+0x14c>
        HAL_TIM_IC_CaptureCallback(htim);
      }
      /* Output compare event */
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8005448:	f7ff ffa6 	bl	8005398 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800544c:	4620      	mov	r0, r4
 800544e:	f7ff ffa7 	bl	80053a0 <HAL_TIM_PWM_PulseFinishedCallback>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8005452:	2200      	movs	r2, #0
 8005454:	6823      	ldr	r3, [r4, #0]
 8005456:	7622      	strb	r2, [r4, #24]
 8005458:	e7bb      	b.n	80053d2 <HAL_TIM_IRQHandler+0x2a>
  /* Capture compare 2 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 800545a:	f06f 0204 	mvn.w	r2, #4
 800545e:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
      /* Input capture event */
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
 8005460:	699b      	ldr	r3, [r3, #24]
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8005462:	2202      	movs	r2, #2
      /* Input capture event */
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
 8005464:	f413 7f40 	tst.w	r3, #768	; 0x300
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8005468:	7622      	strb	r2, [r4, #24]
      /* Input capture event */
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
      {
        HAL_TIM_IC_CaptureCallback(htim);
 800546a:	4620      	mov	r0, r4
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
      /* Input capture event */
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
 800546c:	d13f      	bne.n	80054ee <HAL_TIM_IRQHandler+0x146>
        HAL_TIM_IC_CaptureCallback(htim);
      }
      /* Output compare event */
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800546e:	f7ff ff93 	bl	8005398 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8005472:	4620      	mov	r0, r4
 8005474:	f7ff ff94 	bl	80053a0 <HAL_TIM_PWM_PulseFinishedCallback>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8005478:	2200      	movs	r2, #0
 800547a:	6823      	ldr	r3, [r4, #0]
 800547c:	7622      	strb	r2, [r4, #24]
 800547e:	e7a2      	b.n	80053c6 <HAL_TIM_IRQHandler+0x1e>
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8005480:	f06f 0202 	mvn.w	r2, #2
 8005484:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;

        /* Input capture event */
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
 8005486:	699b      	ldr	r3, [r3, #24]
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8005488:	2201      	movs	r2, #1

        /* Input capture event */
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
 800548a:	079b      	lsls	r3, r3, #30
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800548c:	7602      	strb	r2, [r0, #24]

        /* Input capture event */
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
 800548e:	d128      	bne.n	80054e2 <HAL_TIM_IRQHandler+0x13a>
          HAL_TIM_IC_CaptureCallback(htim);
        }
        /* Output compare event */
        else
        {
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8005490:	f7ff ff82 	bl	8005398 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8005494:	4620      	mov	r0, r4
 8005496:	f7ff ff83 	bl	80053a0 <HAL_TIM_PWM_PulseFinishedCallback>
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800549a:	2200      	movs	r2, #0
 800549c:	6823      	ldr	r3, [r4, #0]
 800549e:	7622      	strb	r2, [r4, #24]
 80054a0:	e78b      	b.n	80053ba <HAL_TIM_IRQHandler+0x12>
  /* TIM commutation event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 80054a2:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutationCallback(htim);
 80054a6:	4620      	mov	r0, r4
    }
  }
}
 80054a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  /* TIM commutation event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 80054ac:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutationCallback(htim);
 80054ae:	f000 bc63 	b.w	8005d78 <HAL_TIMEx_CommutationCallback>
  /* TIM Trigger detection event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 80054b2:	f06f 0240 	mvn.w	r2, #64	; 0x40
 80054b6:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 80054b8:	4620      	mov	r0, r4
 80054ba:	f7ff ff73 	bl	80053a4 <HAL_TIM_TriggerCallback>
 80054be:	6823      	ldr	r3, [r4, #0]
 80054c0:	e79f      	b.n	8005402 <HAL_TIM_IRQHandler+0x5a>
  /* TIM Update event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 80054c2:	f06f 0201 	mvn.w	r2, #1
 80054c6:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 80054c8:	4620      	mov	r0, r4
 80054ca:	f7ff ff63 	bl	8005394 <HAL_TIM_PeriodElapsedCallback>
 80054ce:	6823      	ldr	r3, [r4, #0]
 80054d0:	e78b      	b.n	80053ea <HAL_TIM_IRQHandler+0x42>
  /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 80054d2:	f06f 0280 	mvn.w	r2, #128	; 0x80
 80054d6:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 80054d8:	4620      	mov	r0, r4
 80054da:	f000 fc4f 	bl	8005d7c <HAL_TIMEx_BreakCallback>
 80054de:	6823      	ldr	r3, [r4, #0]
 80054e0:	e789      	b.n	80053f6 <HAL_TIM_IRQHandler+0x4e>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;

        /* Input capture event */
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
        {
          HAL_TIM_IC_CaptureCallback(htim);
 80054e2:	f7ff ff5b 	bl	800539c <HAL_TIM_IC_CaptureCallback>
 80054e6:	e7d8      	b.n	800549a <HAL_TIM_IRQHandler+0xf2>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
      {
        HAL_TIM_IC_CaptureCallback(htim);
 80054e8:	f7ff ff58 	bl	800539c <HAL_TIM_IC_CaptureCallback>
 80054ec:	e79f      	b.n	800542e <HAL_TIM_IRQHandler+0x86>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
      /* Input capture event */
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
      {
        HAL_TIM_IC_CaptureCallback(htim);
 80054ee:	f7ff ff55 	bl	800539c <HAL_TIM_IC_CaptureCallback>
 80054f2:	e7c1      	b.n	8005478 <HAL_TIM_IRQHandler+0xd0>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
      {
        HAL_TIM_IC_CaptureCallback(htim);
 80054f4:	f7ff ff52 	bl	800539c <HAL_TIM_IC_CaptureCallback>
 80054f8:	e7ab      	b.n	8005452 <HAL_TIM_IRQHandler+0xaa>
 80054fa:	bf00      	nop

080054fc <TIM_Base_SetConfig>:
{
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80054fc:	4a1d      	ldr	r2, [pc, #116]	; (8005574 <TIM_Base_SetConfig+0x78>)
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;
 80054fe:	6803      	ldr	r3, [r0, #0]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8005500:	4290      	cmp	r0, r2
 8005502:	d025      	beq.n	8005550 <TIM_Base_SetConfig+0x54>
 8005504:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
  * @param  TIMx : TIM periheral
  * @param  Structure : TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 8005508:	b410      	push	{r4}
  uint32_t tmpcr1 = 0;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800550a:	d010      	beq.n	800552e <TIM_Base_SetConfig+0x32>
 800550c:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8005510:	4290      	cmp	r0, r2
 8005512:	d00c      	beq.n	800552e <TIM_Base_SetConfig+0x32>
 8005514:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8005518:	4290      	cmp	r0, r2
 800551a:	d008      	beq.n	800552e <TIM_Base_SetConfig+0x32>
  }

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 800551c:	688c      	ldr	r4, [r1, #8]

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 800551e:	680a      	ldr	r2, [r1, #0]
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  TIMx->CR1 = tmpcr1;
 8005520:	6003      	str	r3, [r0, #0]
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_EGR_UG;
 8005522:	2301      	movs	r3, #1
  }

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8005524:	62c4      	str	r4, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8005526:	6282      	str	r2, [r0, #40]	; 0x28
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_EGR_UG;
}
 8005528:	bc10      	pop	{r4}
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_EGR_UG;
 800552a:	6143      	str	r3, [r0, #20]
}
 800552c:	4770      	bx	lr
  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
 800552e:	684a      	ldr	r2, [r1, #4]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8005530:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8005534:	4313      	orrs	r3, r2

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8005536:	68ca      	ldr	r2, [r1, #12]
  }

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8005538:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  }

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 800553c:	688c      	ldr	r4, [r1, #8]

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800553e:	4313      	orrs	r3, r2

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8005540:	6809      	ldr	r1, [r1, #0]
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  TIMx->CR1 = tmpcr1;
 8005542:	6003      	str	r3, [r0, #0]
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_EGR_UG;
 8005544:	2301      	movs	r3, #1
  }

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8005546:	62c4      	str	r4, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8005548:	6281      	str	r1, [r0, #40]	; 0x28
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_EGR_UG;
}
 800554a:	bc10      	pop	{r4}
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_EGR_UG;
 800554c:	6143      	str	r3, [r0, #20]
}
 800554e:	4770      	bx	lr
  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
 8005550:	684a      	ldr	r2, [r1, #4]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8005552:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8005556:	4313      	orrs	r3, r2

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8005558:	68ca      	ldr	r2, [r1, #12]
  }

  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 800555a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800555e:	4313      	orrs	r3, r2
  }

  TIMx->CR1 = tmpcr1;
 8005560:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8005562:	688b      	ldr	r3, [r1, #8]
 8005564:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8005566:	680b      	ldr	r3, [r1, #0]
 8005568:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 800556a:	690b      	ldr	r3, [r1, #16]
 800556c:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_EGR_UG;
 800556e:	2301      	movs	r3, #1
 8005570:	6143      	str	r3, [r0, #20]
 8005572:	4770      	bx	lr
 8005574:	40012c00 	.word	0x40012c00

08005578 <HAL_TIM_Base_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if(htim == NULL)
 8005578:	b1b8      	cbz	r0, 80055aa <HAL_TIM_Base_Init+0x32>
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));

  if(htim->State == HAL_TIM_STATE_RESET)
 800557a:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
  *         parameters in the TIM_HandleTypeDef and create the associated handle.
  * @param  htim : TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 800557e:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));

  if(htim->State == HAL_TIM_STATE_RESET)
 8005580:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8005584:	4604      	mov	r4, r0
 8005586:	b15b      	cbz	r3, 80055a0 <HAL_TIM_Base_Init+0x28>
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
  }

  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;
 8005588:	2302      	movs	r3, #2
 800558a:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800558e:	6820      	ldr	r0, [r4, #0]
 8005590:	1d21      	adds	r1, r4, #4
 8005592:	f7ff ffb3 	bl	80054fc <TIM_Base_SetConfig>

  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 8005596:	2301      	movs	r3, #1
 8005598:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  return HAL_OK;
 800559c:	2000      	movs	r0, #0
 800559e:	bd10      	pop	{r4, pc}
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));

  if(htim->State == HAL_TIM_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 80055a0:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 80055a4:	f7fe fd98 	bl	80040d8 <HAL_TIM_Base_MspInit>
 80055a8:	e7ee      	b.n	8005588 <HAL_TIM_Base_Init+0x10>
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if(htim == NULL)
  {
    return HAL_ERROR;
 80055aa:	2001      	movs	r0, #1
 80055ac:	4770      	bx	lr
 80055ae:	bf00      	nop

080055b0 <HAL_TIM_PWM_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if(htim == NULL)
 80055b0:	b1b8      	cbz	r0, 80055e2 <HAL_TIM_PWM_Init+0x32>
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));

  if(htim->State == HAL_TIM_STATE_RESET)
 80055b2:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
  *         parameters in the TIM_HandleTypeDef and create the associated handle.
  * @param  htim : TIM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
 80055b6:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));

  if(htim->State == HAL_TIM_STATE_RESET)
 80055b8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80055bc:	4604      	mov	r4, r0
 80055be:	b15b      	cbz	r3, 80055d8 <HAL_TIM_PWM_Init+0x28>
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
  }

  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;
 80055c0:	2302      	movs	r3, #2
 80055c2:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  /* Init the base time for the PWM */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80055c6:	6820      	ldr	r0, [r4, #0]
 80055c8:	1d21      	adds	r1, r4, #4
 80055ca:	f7ff ff97 	bl	80054fc <TIM_Base_SetConfig>

  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 80055ce:	2301      	movs	r3, #1
 80055d0:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  return HAL_OK;
 80055d4:	2000      	movs	r0, #0
 80055d6:	bd10      	pop	{r4, pc}
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));

  if(htim->State == HAL_TIM_STATE_RESET)
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 80055d8:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
 80055dc:	f7ff fe18 	bl	8005210 <HAL_TIM_PWM_MspInit>
 80055e0:	e7ee      	b.n	80055c0 <HAL_TIM_PWM_Init+0x10>
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if(htim == NULL)
  {
    return HAL_ERROR;
 80055e2:	2001      	movs	r0, #1
 80055e4:	4770      	bx	lr
 80055e6:	bf00      	nop

080055e8 <TIM_OC2_SetConfig>:
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80055e8:	6a02      	ldr	r2, [r0, #32]
  * @param  TIMx  to select the TIM peripheral
  * @param  OC_Config : The ouput configuration structure
  * @retval None
  */
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 80055ea:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80055ec:	f022 0210 	bic.w	r2, r2, #16
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4);
 80055f0:	688e      	ldr	r6, [r1, #8]
  uint32_t tmpccmrx = 0;
  uint32_t tmpccer = 0;
  uint32_t tmpcr2 = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80055f2:	6202      	str	r2, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80055f4:	6a03      	ldr	r3, [r0, #32]
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4);

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 80055f6:	4d12      	ldr	r5, [pc, #72]	; (8005640 <TIM_OC2_SetConfig+0x58>)
  TIMx->CCER &= ~TIM_CCER_CC2E;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80055f8:	6847      	ldr	r7, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 80055fa:	6982      	ldr	r2, [r0, #24]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
  tmpccmrx &= ~TIM_CCMR1_CC2S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 80055fc:	680c      	ldr	r4, [r1, #0]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 80055fe:	f023 0320 	bic.w	r3, r3, #32
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8005602:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4);

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8005606:	42a8      	cmp	r0, r5
  tmpccmrx |= (OC_Config->OCMode << 8);

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4);
 8005608:	ea43 1306 	orr.w	r3, r3, r6, lsl #4
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
  tmpccmrx &= ~TIM_CCMR1_CC2S;

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8);
 800560c:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4);

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8005610:	d006      	beq.n	8005620 <TIM_OC2_SetConfig+0x38>

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 8005612:	6849      	ldr	r1, [r1, #4]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2);
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8005614:	6047      	str	r7, [r0, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8005616:	6182      	str	r2, [r0, #24]
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
}
 8005618:	bcf0      	pop	{r4, r5, r6, r7}

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 800561a:	6381      	str	r1, [r0, #56]	; 0x38

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800561c:	6203      	str	r3, [r0, #32]
}
 800561e:	4770      	bx	lr
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4);
 8005620:	68ce      	ldr	r6, [r1, #12]

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
    tmpcr2 &= ~TIM_CR2_OIS2N;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2);
 8005622:	694d      	ldr	r5, [r1, #20]
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8005624:	f427 6740 	bic.w	r7, r7, #3072	; 0xc00
  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
 8005628:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    tmpcr2 &= ~TIM_CR2_OIS2;
    tmpcr2 &= ~TIM_CR2_OIS2N;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2);
 800562c:	698c      	ldr	r4, [r1, #24]
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4);
 800562e:	ea43 1306 	orr.w	r3, r3, r6, lsl #4

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
    tmpcr2 &= ~TIM_CR2_OIS2N;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2);
 8005632:	ea47 0585 	orr.w	r5, r7, r5, lsl #2
    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;
 8005636:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    tmpcr2 &= ~TIM_CR2_OIS2;
    tmpcr2 &= ~TIM_CR2_OIS2N;
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2);
 800563a:	ea45 0784 	orr.w	r7, r5, r4, lsl #2
 800563e:	e7e8      	b.n	8005612 <TIM_OC2_SetConfig+0x2a>
 8005640:	40012c00 	.word	0x40012c00

08005644 <HAL_TIM_PWM_ConfigChannel>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
{
 8005644:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(htim);
 8005646:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 800564a:	2b01      	cmp	r3, #1
 800564c:	d02b      	beq.n	80056a6 <HAL_TIM_PWM_ConfigChannel+0x62>
 800564e:	460d      	mov	r5, r1
  assert_param(IS_TIM_CHANNELS(Channel));
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  htim->State = HAL_TIM_STATE_BUSY;
 8005650:	2302      	movs	r3, #2
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
{
  __HAL_LOCK(htim);
 8005652:	2101      	movs	r1, #1
 8005654:	4604      	mov	r4, r0
 8005656:	f880 1038 	strb.w	r1, [r0, #56]	; 0x38
  assert_param(IS_TIM_CHANNELS(Channel));
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  htim->State = HAL_TIM_STATE_BUSY;
 800565a:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39

  switch (Channel)
 800565e:	2a0c      	cmp	r2, #12
 8005660:	d81a      	bhi.n	8005698 <HAL_TIM_PWM_ConfigChannel+0x54>
 8005662:	e8df f002 	tbb	[pc, r2]
 8005666:	1935      	.short	0x1935
 8005668:	19071919 	.word	0x19071919
 800566c:	19471919 	.word	0x19471919
 8005670:	1919      	.short	0x1919
 8005672:	22          	.byte	0x22
 8005673:	00          	.byte	0x00

    case TIM_CHANNEL_2:
    {
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8005674:	4629      	mov	r1, r5
 8005676:	6800      	ldr	r0, [r0, #0]
 8005678:	f7ff ffb6 	bl	80055e8 <TIM_OC2_SetConfig>

      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 800567c:	6823      	ldr	r3, [r4, #0]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
 800567e:	6928      	ldr	r0, [r5, #16]
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);

      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8005680:	6999      	ldr	r1, [r3, #24]
 8005682:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
 8005686:	6199      	str	r1, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 8005688:	6999      	ldr	r1, [r3, #24]
 800568a:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 800568e:	6199      	str	r1, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
 8005690:	699a      	ldr	r2, [r3, #24]
 8005692:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8005696:	619a      	str	r2, [r3, #24]

    default:
    break;
  }

  htim->State = HAL_TIM_STATE_READY;
 8005698:	2301      	movs	r3, #1

  __HAL_UNLOCK(htim);
 800569a:	2000      	movs	r0, #0

    default:
    break;
  }

  htim->State = HAL_TIM_STATE_READY;
 800569c:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  __HAL_UNLOCK(htim);
 80056a0:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38

  return HAL_OK;
 80056a4:	bd38      	pop	{r3, r4, r5, pc}
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
{
  __HAL_LOCK(htim);
 80056a6:	2002      	movs	r0, #2
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);

  return HAL_OK;
}
 80056a8:	bd38      	pop	{r3, r4, r5, pc}

    case TIM_CHANNEL_4:
    {
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 80056aa:	4629      	mov	r1, r5
 80056ac:	6800      	ldr	r0, [r0, #0]
 80056ae:	f7ff fd8b 	bl	80051c8 <TIM_OC4_SetConfig>

      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 80056b2:	6823      	ldr	r3, [r4, #0]

     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;
 80056b4:	6928      	ldr	r0, [r5, #16]
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);

      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 80056b6:	69d9      	ldr	r1, [r3, #28]
 80056b8:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
 80056bc:	61d9      	str	r1, [r3, #28]

     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 80056be:	69d9      	ldr	r1, [r3, #28]
 80056c0:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 80056c4:	61d9      	str	r1, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;
 80056c6:	69da      	ldr	r2, [r3, #28]
 80056c8:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 80056cc:	61da      	str	r2, [r3, #28]
    }
    break;
 80056ce:	e7e3      	b.n	8005698 <HAL_TIM_PWM_ConfigChannel+0x54>
  {
    case TIM_CHANNEL_1:
    {
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
      /* Configure the Channel 1 in PWM mode */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 80056d0:	4629      	mov	r1, r5
 80056d2:	6800      	ldr	r0, [r0, #0]
 80056d4:	f7ff fd1e 	bl	8005114 <TIM_OC1_SetConfig>

      /* Set the Preload enable bit for channel1 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 80056d8:	6823      	ldr	r3, [r4, #0]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 80056da:	692a      	ldr	r2, [r5, #16]
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
      /* Configure the Channel 1 in PWM mode */
      TIM_OC1_SetConfig(htim->Instance, sConfig);

      /* Set the Preload enable bit for channel1 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 80056dc:	6999      	ldr	r1, [r3, #24]
 80056de:	f041 0108 	orr.w	r1, r1, #8
 80056e2:	6199      	str	r1, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 80056e4:	6999      	ldr	r1, [r3, #24]
 80056e6:	f021 0104 	bic.w	r1, r1, #4
 80056ea:	6199      	str	r1, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 80056ec:	6999      	ldr	r1, [r3, #24]
 80056ee:	430a      	orrs	r2, r1
 80056f0:	619a      	str	r2, [r3, #24]
    }
    break;
 80056f2:	e7d1      	b.n	8005698 <HAL_TIM_PWM_ConfigChannel+0x54>

    case TIM_CHANNEL_3:
    {
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 80056f4:	4629      	mov	r1, r5
 80056f6:	6800      	ldr	r0, [r0, #0]
 80056f8:	f7ff fd38 	bl	800516c <TIM_OC3_SetConfig>

      /* Set the Preload enable bit for channel3 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 80056fc:	6823      	ldr	r3, [r4, #0]

     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 80056fe:	692a      	ldr	r2, [r5, #16]
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);

      /* Set the Preload enable bit for channel3 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8005700:	69d9      	ldr	r1, [r3, #28]
 8005702:	f041 0108 	orr.w	r1, r1, #8
 8005706:	61d9      	str	r1, [r3, #28]

     /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8005708:	69d9      	ldr	r1, [r3, #28]
 800570a:	f021 0104 	bic.w	r1, r1, #4
 800570e:	61d9      	str	r1, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8005710:	69d9      	ldr	r1, [r3, #28]
 8005712:	430a      	orrs	r2, r1
 8005714:	61da      	str	r2, [r3, #28]
    }
    break;
 8005716:	e7bf      	b.n	8005698 <HAL_TIM_PWM_ConfigChannel+0x54>

08005718 <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 8005718:	b530      	push	{r4, r5, lr}
  USBD_StatusTypeDef ret = USBD_OK;  
  
  switch (req->bRequest) 
 800571a:	784b      	ldrb	r3, [r1, #1]
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 800571c:	b083      	sub	sp, #12
 800571e:	460d      	mov	r5, r1
 8005720:	4604      	mov	r4, r0
  USBD_StatusTypeDef ret = USBD_OK;  
  
  switch (req->bRequest) 
 8005722:	2b09      	cmp	r3, #9
 8005724:	d80b      	bhi.n	800573e <USBD_StdDevReq+0x26>
 8005726:	e8df f003 	tbb	[pc, r3]
 800572a:	4935      	.short	0x4935
 800572c:	050a590a 	.word	0x050a590a
 8005730:	157d0a66 	.word	0x157d0a66
static void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 8005734:	888b      	ldrh	r3, [r1, #4]
 8005736:	b913      	cbnz	r3, 800573e <USBD_StdDevReq+0x26>
 8005738:	88cb      	ldrh	r3, [r1, #6]
 800573a:	2b00      	cmp	r3, #0
 800573c:	d07f      	beq.n	800583e <USBD_StdDevReq+0x126>
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev , 0x80);
 800573e:	2180      	movs	r1, #128	; 0x80
 8005740:	4620      	mov	r0, r4
 8005742:	f7fe fb8b 	bl	8003e5c <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 8005746:	4620      	mov	r0, r4
 8005748:	2100      	movs	r1, #0
 800574a:	f7fe fb87 	bl	8003e5c <USBD_LL_StallEP>
    USBD_CtlError(pdev , req);
    break;
  }
  
  return ret;
}
 800574e:	2000      	movs	r0, #0
 8005750:	b003      	add	sp, #12
 8005752:	bd30      	pop	{r4, r5, pc}
                           USBD_SetupReqTypedef *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 8005754:	7889      	ldrb	r1, [r1, #2]
 8005756:	4d97      	ldr	r5, [pc, #604]	; (80059b4 <USBD_StdDevReq+0x29c>)
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 8005758:	2901      	cmp	r1, #1
                           USBD_SetupReqTypedef *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 800575a:	7029      	strb	r1, [r5, #0]
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 800575c:	d8ef      	bhi.n	800573e <USBD_StdDevReq+0x26>
  {            
     USBD_CtlError(pdev , req);                              
  } 
  else 
  {
    switch (pdev->dev_state) 
 800575e:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8005762:	2b02      	cmp	r3, #2
 8005764:	f000 8089 	beq.w	800587a <USBD_StdDevReq+0x162>
 8005768:	2b03      	cmp	r3, #3
 800576a:	d1e8      	bne.n	800573e <USBD_StdDevReq+0x26>
         USBD_CtlSendStatus(pdev);
      }
      break;
      
    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0) 
 800576c:	2900      	cmp	r1, #0
 800576e:	f000 8116 	beq.w	800599e <USBD_StdDevReq+0x286>
        pdev->dev_config = cfgidx;          
        USBD_ClrClassConfig(pdev , cfgidx);
        USBD_CtlSendStatus(pdev);
        
      } 
      else  if (cfgidx != pdev->dev_config) 
 8005772:	6841      	ldr	r1, [r0, #4]
 8005774:	2901      	cmp	r1, #1
 8005776:	d009      	beq.n	800578c <USBD_StdDevReq+0x74>
      {
        /* Clear old configuration */
        USBD_ClrClassConfig(pdev , pdev->dev_config);
 8005778:	b2c9      	uxtb	r1, r1
 800577a:	f7fc f9cb 	bl	8001b14 <USBD_ClrClassConfig>
        
        /* set new configuration */
        pdev->dev_config = cfgidx;
 800577e:	7829      	ldrb	r1, [r5, #0]
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 8005780:	4620      	mov	r0, r4
      {
        /* Clear old configuration */
        USBD_ClrClassConfig(pdev , pdev->dev_config);
        
        /* set new configuration */
        pdev->dev_config = cfgidx;
 8005782:	6061      	str	r1, [r4, #4]
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 8005784:	f7fc f9bc 	bl	8001b00 <USBD_SetClassConfig>
 8005788:	2802      	cmp	r0, #2
 800578a:	d0d8      	beq.n	800573e <USBD_StdDevReq+0x26>
  case USBD_STATE_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
    {
      pdev->dev_remote_wakeup = 0; 
      pdev->pClass->Setup (pdev, req);   
      USBD_CtlSendStatus(pdev);
 800578c:	4620      	mov	r0, r4
 800578e:	f000 fa99 	bl	8005cc4 <USBD_CtlSendStatus>
 8005792:	e7dc      	b.n	800574e <USBD_StdDevReq+0x36>
static void USBD_GetStatus(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
  
    
  switch (pdev->dev_state) 
 8005794:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8005798:	2201      	movs	r2, #1
 800579a:	3b02      	subs	r3, #2
 800579c:	4293      	cmp	r3, r2
 800579e:	f04f 0103 	mov.w	r1, #3
 80057a2:	d8cc      	bhi.n	800573e <USBD_StdDevReq+0x26>
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
#else
    pdev->dev_config_status = 0;                                   
#endif
                      
    if (pdev->dev_remote_wakeup) 
 80057a4:	f8d0 3204 	ldr.w	r3, [r0, #516]	; 0x204
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    
#if ( USBD_SELF_POWERED == 1)
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
 80057a8:	60c2      	str	r2, [r0, #12]
#else
    pdev->dev_config_status = 0;                                   
#endif
                      
    if (pdev->dev_remote_wakeup) 
 80057aa:	b103      	cbz	r3, 80057ae <USBD_StdDevReq+0x96>
    {
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
 80057ac:	60c1      	str	r1, [r0, #12]
    }
    
    USBD_CtlSendData (pdev, 
 80057ae:	2202      	movs	r2, #2
 80057b0:	f104 010c 	add.w	r1, r4, #12
 80057b4:	4620      	mov	r0, r4
 80057b6:	f000 fa57 	bl	8005c68 <USBD_CtlSendData>
 80057ba:	e7c8      	b.n	800574e <USBD_StdDevReq+0x36>
* @retval status
*/
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
  switch (pdev->dev_state)
 80057bc:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80057c0:	3b02      	subs	r3, #2
 80057c2:	2b01      	cmp	r3, #1
 80057c4:	d8bb      	bhi.n	800573e <USBD_StdDevReq+0x26>
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 80057c6:	884b      	ldrh	r3, [r1, #2]
 80057c8:	2b01      	cmp	r3, #1
 80057ca:	d1c0      	bne.n	800574e <USBD_StdDevReq+0x36>
    {
      pdev->dev_remote_wakeup = 0; 
      pdev->pClass->Setup (pdev, req);   
 80057cc:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
    {
      pdev->dev_remote_wakeup = 0; 
 80057d0:	2200      	movs	r2, #0
      pdev->pClass->Setup (pdev, req);   
 80057d2:	689b      	ldr	r3, [r3, #8]
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
    {
      pdev->dev_remote_wakeup = 0; 
 80057d4:	f8c0 2204 	str.w	r2, [r0, #516]	; 0x204
      pdev->pClass->Setup (pdev, req);   
 80057d8:	4798      	blx	r3
 80057da:	e7d7      	b.n	800578c <USBD_StdDevReq+0x74>
*/
static void USBD_SetFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{

  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 80057dc:	884b      	ldrh	r3, [r1, #2]
 80057de:	2b01      	cmp	r3, #1
 80057e0:	d1b5      	bne.n	800574e <USBD_StdDevReq+0x36>
  {
    pdev->dev_remote_wakeup = 1;  
    pdev->pClass->Setup (pdev, req);   
 80057e2:	f8d0 2214 	ldr.w	r2, [r0, #532]	; 0x214
                            USBD_SetupReqTypedef *req)
{

  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
  {
    pdev->dev_remote_wakeup = 1;  
 80057e6:	f8c0 3204 	str.w	r3, [r0, #516]	; 0x204
    pdev->pClass->Setup (pdev, req);   
 80057ea:	6893      	ldr	r3, [r2, #8]
 80057ec:	4798      	blx	r3
    USBD_CtlSendStatus(pdev);
 80057ee:	4620      	mov	r0, r4
 80057f0:	f000 fa68 	bl	8005cc4 <USBD_CtlSendStatus>
 80057f4:	e7ab      	b.n	800574e <USBD_StdDevReq+0x36>
 80057f6:	884a      	ldrh	r2, [r1, #2]
{
  uint16_t len;
  uint8_t *pbuf;
  
    
  switch (req->wValue >> 8)
 80057f8:	0a13      	lsrs	r3, r2, #8
 80057fa:	3b01      	subs	r3, #1
 80057fc:	2b06      	cmp	r3, #6
 80057fe:	d89e      	bhi.n	800573e <USBD_StdDevReq+0x26>
 8005800:	a101      	add	r1, pc, #4	; (adr r1, 8005808 <USBD_StdDevReq+0xf0>)
 8005802:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8005806:	bf00      	nop
 8005808:	080058eb 	.word	0x080058eb
 800580c:	0800590d 	.word	0x0800590d
 8005810:	080058fb 	.word	0x080058fb
 8005814:	0800573f 	.word	0x0800573f
 8005818:	0800573f 	.word	0x0800573f
 800581c:	080058d5 	.word	0x080058d5
 8005820:	08005895 	.word	0x08005895
*/
static void USBD_GetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{

  if (req->wLength != 1) 
 8005824:	88ca      	ldrh	r2, [r1, #6]
 8005826:	2a01      	cmp	r2, #1
 8005828:	d189      	bne.n	800573e <USBD_StdDevReq+0x26>
  {                   
     USBD_CtlError(pdev , req);
  }
  else 
  {
    switch (pdev->dev_state )  
 800582a:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800582e:	2b02      	cmp	r3, #2
 8005830:	d01c      	beq.n	800586c <USBD_StdDevReq+0x154>
 8005832:	2b03      	cmp	r3, #3
 8005834:	d183      	bne.n	800573e <USBD_StdDevReq+0x26>
                        1);
      break;
      
    case USBD_STATE_CONFIGURED:   
      
      USBD_CtlSendData (pdev, 
 8005836:	1d01      	adds	r1, r0, #4
 8005838:	f000 fa16 	bl	8005c68 <USBD_CtlSendData>
 800583c:	e787      	b.n	800574e <USBD_StdDevReq+0x36>
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 800583e:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8005842:	788d      	ldrb	r5, [r1, #2]
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8005844:	2b03      	cmp	r3, #3
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8005846:	f005 057f 	and.w	r5, r5, #127	; 0x7f
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 800584a:	f43f af78 	beq.w	800573e <USBD_StdDevReq+0x26>
    {
      USBD_CtlError(pdev , req);
    } 
    else 
    {
      pdev->dev_address = dev_addr;
 800584e:	f880 51fe 	strb.w	r5, [r0, #510]	; 0x1fe
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
 8005852:	4629      	mov	r1, r5
 8005854:	f7fe fb22 	bl	8003e9c <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);                         
 8005858:	4620      	mov	r0, r4
 800585a:	f000 fa33 	bl	8005cc4 <USBD_CtlSendStatus>
      
      if (dev_addr != 0) 
 800585e:	2d00      	cmp	r5, #0
 8005860:	f000 8090 	beq.w	8005984 <USBD_StdDevReq+0x26c>
      {
        pdev->dev_state  = USBD_STATE_ADDRESSED;
 8005864:	2302      	movs	r3, #2
 8005866:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
 800586a:	e770      	b.n	800574e <USBD_StdDevReq+0x36>
  else 
  {
    switch (pdev->dev_state )  
    {
    case USBD_STATE_ADDRESSED:                     
      pdev->dev_default_config = 0;
 800586c:	4601      	mov	r1, r0
 800586e:	2300      	movs	r3, #0
 8005870:	f841 3f08 	str.w	r3, [r1, #8]!
      USBD_CtlSendData (pdev, 
 8005874:	f000 f9f8 	bl	8005c68 <USBD_CtlSendData>
 8005878:	e769      	b.n	800574e <USBD_StdDevReq+0x36>
  else 
  {
    switch (pdev->dev_state) 
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
 800587a:	2900      	cmp	r1, #0
 800587c:	d086      	beq.n	800578c <USBD_StdDevReq+0x74>
      {                                			   							   							   				
        pdev->dev_config = cfgidx;
 800587e:	2101      	movs	r1, #1
        pdev->dev_state = USBD_STATE_CONFIGURED;
 8005880:	2303      	movs	r3, #3
    switch (pdev->dev_state) 
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
      {                                			   							   							   				
        pdev->dev_config = cfgidx;
 8005882:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
 8005884:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 8005888:	f7fc f93a 	bl	8001b00 <USBD_SetClassConfig>
 800588c:	2802      	cmp	r0, #2
 800588e:	f47f af7d 	bne.w	800578c <USBD_StdDevReq+0x74>
 8005892:	e754      	b.n	800573e <USBD_StdDevReq+0x26>
      USBD_CtlError(pdev , req);
      return;
    } 

  case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 8005894:	7c03      	ldrb	r3, [r0, #16]
 8005896:	2b00      	cmp	r3, #0
 8005898:	f47f af51 	bne.w	800573e <USBD_StdDevReq+0x26>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 800589c:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80058a0:	f10d 0006 	add.w	r0, sp, #6
 80058a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80058a6:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 80058a8:	2307      	movs	r3, #7
 80058aa:	7043      	strb	r3, [r0, #1]
  default: 
     USBD_CtlError(pdev , req);
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
 80058ac:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80058b0:	2b00      	cmp	r3, #0
 80058b2:	f43f af4c 	beq.w	800574e <USBD_StdDevReq+0x36>
 80058b6:	88ea      	ldrh	r2, [r5, #6]
 80058b8:	2a00      	cmp	r2, #0
 80058ba:	f43f af48 	beq.w	800574e <USBD_StdDevReq+0x36>
  {
    
    len = MIN(len , req->wLength);
 80058be:	4293      	cmp	r3, r2
 80058c0:	bf28      	it	cs
 80058c2:	4613      	movcs	r3, r2
    
    USBD_CtlSendData (pdev, 
 80058c4:	4601      	mov	r1, r0
 80058c6:	461a      	mov	r2, r3
 80058c8:	4620      	mov	r0, r4
  }
  
  if((len != 0)&& (req->wLength != 0))
  {
    
    len = MIN(len , req->wLength);
 80058ca:	f8ad 3006 	strh.w	r3, [sp, #6]
    
    USBD_CtlSendData (pdev, 
 80058ce:	f000 f9cb 	bl	8005c68 <USBD_CtlSendData>
 80058d2:	e73c      	b.n	800574e <USBD_StdDevReq+0x36>
#endif   
    }
    break;
  case USB_DESC_TYPE_DEVICE_QUALIFIER:                   

    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 80058d4:	7c03      	ldrb	r3, [r0, #16]
 80058d6:	2b00      	cmp	r3, #0
 80058d8:	f47f af31 	bne.w	800573e <USBD_StdDevReq+0x26>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
 80058dc:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80058e0:	f10d 0006 	add.w	r0, sp, #6
 80058e4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80058e6:	4798      	blx	r3
 80058e8:	e7e0      	b.n	80058ac <USBD_StdDevReq+0x194>
  case USB_DESC_TYPE_BOS:
    pbuf = pdev->pDesc->GetBOSDescriptor(pdev->dev_speed, &len);
    break;
#endif    
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 80058ea:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 80058ee:	f10d 0106 	add.w	r1, sp, #6
 80058f2:	681b      	ldr	r3, [r3, #0]
 80058f4:	7c00      	ldrb	r0, [r0, #16]
 80058f6:	4798      	blx	r3
 80058f8:	e7d8      	b.n	80058ac <USBD_StdDevReq+0x194>
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    }
    break;
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
 80058fa:	b2d2      	uxtb	r2, r2
 80058fc:	2a05      	cmp	r2, #5
 80058fe:	f63f af1e 	bhi.w	800573e <USBD_StdDevReq+0x26>
 8005902:	e8df f002 	tbb	[pc, r2]
 8005906:	1f27      	.short	0x1f27
 8005908:	2f370f17 	.word	0x2f370f17
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:     
    if(pdev->dev_speed == USBD_SPEED_HIGH )   
 800590c:	7c03      	ldrb	r3, [r0, #16]
 800590e:	2b00      	cmp	r3, #0
 8005910:	d13c      	bne.n	800598c <USBD_StdDevReq+0x274>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
 8005912:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8005916:	f10d 0006 	add.w	r0, sp, #6
 800591a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800591c:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 800591e:	2302      	movs	r3, #2
 8005920:	7043      	strb	r3, [r0, #1]
 8005922:	e7c3      	b.n	80058ac <USBD_StdDevReq+0x194>
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
      break;
      
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8005924:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8005928:	f10d 0106 	add.w	r1, sp, #6
 800592c:	691b      	ldr	r3, [r3, #16]
 800592e:	7c00      	ldrb	r0, [r0, #16]
 8005930:	4798      	blx	r3
 8005932:	e7bb      	b.n	80058ac <USBD_StdDevReq+0x194>
    case USBD_IDX_MFC_STR:
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
      break;
      
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8005934:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8005938:	f10d 0106 	add.w	r1, sp, #6
 800593c:	68db      	ldr	r3, [r3, #12]
 800593e:	7c00      	ldrb	r0, [r0, #16]
 8005940:	4798      	blx	r3
 8005942:	e7b3      	b.n	80058ac <USBD_StdDevReq+0x194>
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
      break;
      
    case USBD_IDX_MFC_STR:
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8005944:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8005948:	f10d 0106 	add.w	r1, sp, #6
 800594c:	689b      	ldr	r3, [r3, #8]
 800594e:	7c00      	ldrb	r0, [r0, #16]
 8005950:	4798      	blx	r3
 8005952:	e7ab      	b.n	80058ac <USBD_StdDevReq+0x194>
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
    {
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
 8005954:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8005958:	f10d 0106 	add.w	r1, sp, #6
 800595c:	685b      	ldr	r3, [r3, #4]
 800595e:	7c00      	ldrb	r0, [r0, #16]
 8005960:	4798      	blx	r3
 8005962:	e7a3      	b.n	80058ac <USBD_StdDevReq+0x194>
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
      break;
      
    case USBD_IDX_INTERFACE_STR:
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8005964:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8005968:	f10d 0106 	add.w	r1, sp, #6
 800596c:	699b      	ldr	r3, [r3, #24]
 800596e:	7c00      	ldrb	r0, [r0, #16]
 8005970:	4798      	blx	r3
 8005972:	e79b      	b.n	80058ac <USBD_StdDevReq+0x194>
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
      break;
      
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8005974:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8005978:	f10d 0106 	add.w	r1, sp, #6
 800597c:	695b      	ldr	r3, [r3, #20]
 800597e:	7c00      	ldrb	r0, [r0, #16]
 8005980:	4798      	blx	r3
 8005982:	e793      	b.n	80058ac <USBD_StdDevReq+0x194>
      {
        pdev->dev_state  = USBD_STATE_ADDRESSED;
      } 
      else 
      {
        pdev->dev_state  = USBD_STATE_DEFAULT; 
 8005984:	2301      	movs	r3, #1
 8005986:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
 800598a:	e6e0      	b.n	800574e <USBD_StdDevReq+0x36>
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    }
    else
    {
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 800598c:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8005990:	f10d 0006 	add.w	r0, sp, #6
 8005994:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005996:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8005998:	2302      	movs	r3, #2
 800599a:	7043      	strb	r3, [r0, #1]
 800599c:	e786      	b.n	80058ac <USBD_StdDevReq+0x194>
      break;
      
    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0) 
      {                           
        pdev->dev_state = USBD_STATE_ADDRESSED;
 800599e:	2302      	movs	r3, #2
        pdev->dev_config = cfgidx;          
 80059a0:	6041      	str	r1, [r0, #4]
      break;
      
    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0) 
      {                           
        pdev->dev_state = USBD_STATE_ADDRESSED;
 80059a2:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        pdev->dev_config = cfgidx;          
        USBD_ClrClassConfig(pdev , cfgidx);
 80059a6:	f7fc f8b5 	bl	8001b14 <USBD_ClrClassConfig>
        USBD_CtlSendStatus(pdev);
 80059aa:	4620      	mov	r0, r4
 80059ac:	f000 f98a 	bl	8005cc4 <USBD_CtlSendStatus>
 80059b0:	e6cd      	b.n	800574e <USBD_StdDevReq+0x36>
 80059b2:	bf00      	nop
 80059b4:	20000cf1 	.word	0x20000cf1

080059b8 <USBD_StdItfReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdItfReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 80059b8:	b538      	push	{r3, r4, r5, lr}
  USBD_StatusTypeDef ret = USBD_OK; 
  
  switch (pdev->dev_state) 
 80059ba:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdItfReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 80059be:	4604      	mov	r4, r0
  USBD_StatusTypeDef ret = USBD_OK; 
  
  switch (pdev->dev_state) 
 80059c0:	2b03      	cmp	r3, #3
 80059c2:	d103      	bne.n	80059cc <USBD_StdItfReq+0x14>
  {
  case USBD_STATE_CONFIGURED:
    
    if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES) 
 80059c4:	790b      	ldrb	r3, [r1, #4]
 80059c6:	460d      	mov	r5, r1
 80059c8:	2b01      	cmp	r3, #1
 80059ca:	d908      	bls.n	80059de <USBD_StdItfReq+0x26>
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev , 0x80);
 80059cc:	2180      	movs	r1, #128	; 0x80
 80059ce:	f7fe fa45 	bl	8003e5c <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 80059d2:	4620      	mov	r0, r4
 80059d4:	2100      	movs	r1, #0
 80059d6:	f7fe fa41 	bl	8003e5c <USBD_LL_StallEP>
  default:
     USBD_CtlError(pdev , req);
    break;
  }
  return USBD_OK;
}
 80059da:	2000      	movs	r0, #0
 80059dc:	bd38      	pop	{r3, r4, r5, pc}
  {
  case USBD_STATE_CONFIGURED:
    
    if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES) 
    {
      pdev->pClass->Setup (pdev, req); 
 80059de:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80059e2:	689b      	ldr	r3, [r3, #8]
 80059e4:	4798      	blx	r3
      
      if((req->wLength == 0)&& (ret == USBD_OK))
 80059e6:	88eb      	ldrh	r3, [r5, #6]
 80059e8:	2b00      	cmp	r3, #0
 80059ea:	d1f6      	bne.n	80059da <USBD_StdItfReq+0x22>
      {
         USBD_CtlSendStatus(pdev);
 80059ec:	4620      	mov	r0, r4
 80059ee:	f000 f969 	bl	8005cc4 <USBD_CtlSendStatus>
 80059f2:	e7f2      	b.n	80059da <USBD_StdItfReq+0x22>

080059f4 <USBD_StdEPReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdEPReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 80059f4:	b570      	push	{r4, r5, r6, lr}
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20)
 80059f6:	780b      	ldrb	r3, [r1, #0]
{
  
  uint8_t   ep_addr;
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
 80059f8:	888a      	ldrh	r2, [r1, #4]
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20)
 80059fa:	f003 0360 	and.w	r3, r3, #96	; 0x60
 80059fe:	2b20      	cmp	r3, #32
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdEPReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 8005a00:	4605      	mov	r5, r0
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20)
 8005a02:	d057      	beq.n	8005ab4 <USBD_StdEPReq+0xc0>
    pdev->pClass->Setup (pdev, req);
    
    return USBD_OK;
  }
  
  switch (req->bRequest) 
 8005a04:	784b      	ldrb	r3, [r1, #1]
 8005a06:	460c      	mov	r4, r1
 8005a08:	2b01      	cmp	r3, #1
 8005a0a:	b2d6      	uxtb	r6, r2
 8005a0c:	d034      	beq.n	8005a78 <USBD_StdEPReq+0x84>
 8005a0e:	d319      	bcc.n	8005a44 <USBD_StdEPReq+0x50>
 8005a10:	2b03      	cmp	r3, #3
 8005a12:	d115      	bne.n	8005a40 <USBD_StdEPReq+0x4c>
  {
    
  case USB_REQ_SET_FEATURE :
    
    switch (pdev->dev_state) 
 8005a14:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8005a18:	2b02      	cmp	r3, #2
 8005a1a:	d031      	beq.n	8005a80 <USBD_StdEPReq+0x8c>
 8005a1c:	2b03      	cmp	r3, #3
 8005a1e:	d140      	bne.n	8005aa2 <USBD_StdEPReq+0xae>
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 8005a20:	884b      	ldrh	r3, [r1, #2]
 8005a22:	b923      	cbnz	r3, 8005a2e <USBD_StdEPReq+0x3a>
      {
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8005a24:	0673      	lsls	r3, r6, #25
 8005a26:	d002      	beq.n	8005a2e <USBD_StdEPReq+0x3a>
        { 
          USBD_LL_StallEP(pdev , ep_addr);
 8005a28:	4631      	mov	r1, r6
 8005a2a:	f7fe fa17 	bl	8003e5c <USBD_LL_StallEP>
      if (req->wValue == USB_FEATURE_EP_HALT)
      {
        if ((ep_addr & 0x7F) != 0x00) 
        {        
          USBD_LL_ClearStallEP(pdev , ep_addr);
          pdev->pClass->Setup (pdev, req);
 8005a2e:	f8d5 3214 	ldr.w	r3, [r5, #532]	; 0x214
 8005a32:	4621      	mov	r1, r4
 8005a34:	689b      	ldr	r3, [r3, #8]
 8005a36:	4628      	mov	r0, r5
 8005a38:	4798      	blx	r3
        }
        USBD_CtlSendStatus(pdev);
 8005a3a:	4628      	mov	r0, r5
 8005a3c:	f000 f942 	bl	8005cc4 <USBD_CtlSendStatus>
    
  default:
    break;
  }
  return ret;
}
 8005a40:	2000      	movs	r0, #0
 8005a42:	bd70      	pop	{r4, r5, r6, pc}
      break;    
    }
    break;
    
  case USB_REQ_GET_STATUS:                  
    switch (pdev->dev_state) 
 8005a44:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8005a48:	2b02      	cmp	r3, #2
 8005a4a:	d019      	beq.n	8005a80 <USBD_StdEPReq+0x8c>
 8005a4c:	2b03      	cmp	r3, #3
 8005a4e:	d128      	bne.n	8005aa2 <USBD_StdEPReq+0xae>
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 8005a50:	f006 047f 	and.w	r4, r6, #127	; 0x7f
 8005a54:	0613      	lsls	r3, r2, #24
 8005a56:	eb00 1404 	add.w	r4, r0, r4, lsl #4
                                         &pdev->ep_out[ep_addr & 0x7F];
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 8005a5a:	4631      	mov	r1, r6
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 8005a5c:	bf4c      	ite	mi
 8005a5e:	3414      	addmi	r4, #20
 8005a60:	f504 7482 	addpl.w	r4, r4, #260	; 0x104
                                         &pdev->ep_out[ep_addr & 0x7F];
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 8005a64:	f7fe fa0a 	bl	8003e7c <USBD_LL_IsStallEP>
 8005a68:	bb48      	cbnz	r0, 8005abe <USBD_StdEPReq+0xca>
      {
        pep->status = 0x0001;     
      }
      else
      {
        pep->status = 0x0000;  
 8005a6a:	6020      	str	r0, [r4, #0]
      }
      
      USBD_CtlSendData (pdev,
 8005a6c:	4621      	mov	r1, r4
 8005a6e:	4628      	mov	r0, r5
 8005a70:	2202      	movs	r2, #2
 8005a72:	f000 f8f9 	bl	8005c68 <USBD_CtlSendData>
                        (uint8_t *)&pep->status,
                        2);
      break;
 8005a76:	e7e3      	b.n	8005a40 <USBD_StdEPReq+0x4c>
    }
    break;
    
  case USB_REQ_CLEAR_FEATURE :
    
    switch (pdev->dev_state) 
 8005a78:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8005a7c:	2b02      	cmp	r3, #2
 8005a7e:	d105      	bne.n	8005a8c <USBD_StdEPReq+0x98>
    
  case USB_REQ_GET_STATUS:                  
    switch (pdev->dev_state) 
    {
    case USBD_STATE_ADDRESSED:          
      if ((ep_addr & 0x7F) != 0x00) 
 8005a80:	0672      	lsls	r2, r6, #25
 8005a82:	d0dd      	beq.n	8005a40 <USBD_StdEPReq+0x4c>
      {
        USBD_LL_StallEP(pdev , ep_addr);
 8005a84:	4631      	mov	r1, r6
 8005a86:	f7fe f9e9 	bl	8003e5c <USBD_LL_StallEP>
 8005a8a:	e7d9      	b.n	8005a40 <USBD_StdEPReq+0x4c>
    }
    break;
    
  case USB_REQ_CLEAR_FEATURE :
    
    switch (pdev->dev_state) 
 8005a8c:	2b03      	cmp	r3, #3
 8005a8e:	d108      	bne.n	8005aa2 <USBD_StdEPReq+0xae>
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 8005a90:	884b      	ldrh	r3, [r1, #2]
 8005a92:	2b00      	cmp	r3, #0
 8005a94:	d1d4      	bne.n	8005a40 <USBD_StdEPReq+0x4c>
      {
        if ((ep_addr & 0x7F) != 0x00) 
 8005a96:	0671      	lsls	r1, r6, #25
 8005a98:	d0cf      	beq.n	8005a3a <USBD_StdEPReq+0x46>
        {        
          USBD_LL_ClearStallEP(pdev , ep_addr);
 8005a9a:	4631      	mov	r1, r6
 8005a9c:	f7fe f9e6 	bl	8003e6c <USBD_LL_ClearStallEP>
 8005aa0:	e7c5      	b.n	8005a2e <USBD_StdEPReq+0x3a>
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev , 0x80);
 8005aa2:	2180      	movs	r1, #128	; 0x80
 8005aa4:	f7fe f9da 	bl	8003e5c <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 8005aa8:	4628      	mov	r0, r5
 8005aaa:	2100      	movs	r1, #0
 8005aac:	f7fe f9d6 	bl	8003e5c <USBD_LL_StallEP>
    
  default:
    break;
  }
  return ret;
}
 8005ab0:	2000      	movs	r0, #0
 8005ab2:	bd70      	pop	{r4, r5, r6, pc}
  ep_addr  = LOBYTE(req->wIndex);   
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20)
  {
    pdev->pClass->Setup (pdev, req);
 8005ab4:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8005ab8:	689b      	ldr	r3, [r3, #8]
 8005aba:	4798      	blx	r3
    
    return USBD_OK;
 8005abc:	e7c0      	b.n	8005a40 <USBD_StdEPReq+0x4c>
    case USBD_STATE_CONFIGURED:
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
                                         &pdev->ep_out[ep_addr & 0x7F];
      if(USBD_LL_IsStallEP(pdev, ep_addr))
      {
        pep->status = 0x0001;     
 8005abe:	2301      	movs	r3, #1
 8005ac0:	6023      	str	r3, [r4, #0]
 8005ac2:	e7d3      	b.n	8005a6c <USBD_StdEPReq+0x78>

08005ac4 <USBD_ParseSetupRequest>:
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
 8005ac4:	780b      	ldrb	r3, [r1, #0]
 8005ac6:	7003      	strb	r3, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
 8005ac8:	784b      	ldrb	r3, [r1, #1]
 8005aca:	7043      	strb	r3, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
 8005acc:	78ca      	ldrb	r2, [r1, #3]
 8005ace:	788b      	ldrb	r3, [r1, #2]
 8005ad0:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8005ad4:	8043      	strh	r3, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
 8005ad6:	794a      	ldrb	r2, [r1, #5]
 8005ad8:	790b      	ldrb	r3, [r1, #4]
 8005ada:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8005ade:	8083      	strh	r3, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
 8005ae0:	79ca      	ldrb	r2, [r1, #7]
 8005ae2:	798b      	ldrb	r3, [r1, #6]
 8005ae4:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8005ae8:	80c3      	strh	r3, [r0, #6]
 8005aea:	4770      	bx	lr

08005aec <USBD_GetString>:
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
  uint8_t idx = 0;
  
  if (desc != NULL) 
 8005aec:	b300      	cbz	r0, 8005b30 <USBD_GetString+0x44>
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != '\0') 
 8005aee:	7803      	ldrb	r3, [r0, #0]
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 8005af0:	b430      	push	{r4, r5}
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != '\0') 
 8005af2:	b1f3      	cbz	r3, 8005b32 <USBD_GetString+0x46>
 8005af4:	4604      	mov	r4, r0
 8005af6:	2300      	movs	r3, #0
 8005af8:	f814 5f01 	ldrb.w	r5, [r4, #1]!
    {
        len++;
 8005afc:	3301      	adds	r3, #1
 8005afe:	b2db      	uxtb	r3, r3
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != '\0') 
 8005b00:	2d00      	cmp	r5, #0
 8005b02:	d1f9      	bne.n	8005af8 <USBD_GetString+0xc>
 8005b04:	005b      	lsls	r3, r3, #1
 8005b06:	3302      	adds	r3, #2
 8005b08:	b2dc      	uxtb	r4, r3
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 8005b0a:	2503      	movs	r5, #3
{
  uint8_t idx = 0;
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
 8005b0c:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *len;
 8005b0e:	700c      	strb	r4, [r1, #0]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 8005b10:	704d      	strb	r5, [r1, #1]
    
    while (*desc != '\0') 
 8005b12:	7804      	ldrb	r4, [r0, #0]
 8005b14:	b15c      	cbz	r4, 8005b2e <USBD_GetString+0x42>
 8005b16:	2302      	movs	r3, #2
    {
      unicode[idx++] = *desc++;
      unicode[idx++] =  0x00;
 8005b18:	2500      	movs	r5, #0
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
    
    while (*desc != '\0') 
    {
      unicode[idx++] = *desc++;
 8005b1a:	1c5a      	adds	r2, r3, #1
 8005b1c:	b2d2      	uxtb	r2, r2
 8005b1e:	54cc      	strb	r4, [r1, r3]
      unicode[idx++] =  0x00;
 8005b20:	548d      	strb	r5, [r1, r2]
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
    
    while (*desc != '\0') 
 8005b22:	f810 4f01 	ldrb.w	r4, [r0, #1]!
    {
      unicode[idx++] = *desc++;
      unicode[idx++] =  0x00;
 8005b26:	3302      	adds	r3, #2
 8005b28:	b2db      	uxtb	r3, r3
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
    
    while (*desc != '\0') 
 8005b2a:	2c00      	cmp	r4, #0
 8005b2c:	d1f5      	bne.n	8005b1a <USBD_GetString+0x2e>
    {
      unicode[idx++] = *desc++;
      unicode[idx++] =  0x00;
    }
  } 
}
 8005b2e:	bc30      	pop	{r4, r5}
 8005b30:	4770      	bx	lr
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != '\0') 
 8005b32:	2402      	movs	r4, #2
 8005b34:	4623      	mov	r3, r4
 8005b36:	e7e8      	b.n	8005b0a <USBD_GetString+0x1e>

08005b38 <HAL_PCDEx_PMAConfig>:

{
  PCD_EPTypeDef *ep = NULL;
  
  /* initialize ep structure*/
  if ((0x80 & ep_addr) == 0x80)
 8005b38:	f011 0f80 	tst.w	r1, #128	; 0x80
 8005b3c:	d00c      	beq.n	8005b58 <HAL_PCDEx_PMAConfig+0x20>
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8005b3e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8005b42:	eb00 1041 	add.w	r0, r0, r1, lsl #5
 8005b46:	3028      	adds	r0, #40	; 0x28
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  /* Here we check if the endpoint is single or double Buffer*/
  if (ep_kind == PCD_SNG_BUF)
 8005b48:	b162      	cbz	r2, 8005b64 <HAL_PCDEx_PMAConfig+0x2c>
  {
    /*Double Buffer Endpoint*/
    ep->doublebuffer = 1;
    /*Configure the PMA*/
    ep->pmaaddr0 =  pmaadress & 0xFFFF;
    ep->pmaaddr1 =  (pmaadress & 0xFFFF0000) >> 16;
 8005b4a:	0c19      	lsrs	r1, r3, #16
    ep->pmaadress = (uint16_t)pmaadress;
  }
  else /*USB_DBL_BUF*/
  {
    /*Double Buffer Endpoint*/
    ep->doublebuffer = 1;
 8005b4c:	2201      	movs	r2, #1
    /*Configure the PMA*/
    ep->pmaaddr0 =  pmaadress & 0xFFFF;
 8005b4e:	80c3      	strh	r3, [r0, #6]
    ep->pmaaddr1 =  (pmaadress & 0xFFFF0000) >> 16;
 8005b50:	8101      	strh	r1, [r0, #8]
    ep->pmaadress = (uint16_t)pmaadress;
  }
  else /*USB_DBL_BUF*/
  {
    /*Double Buffer Endpoint*/
    ep->doublebuffer = 1;
 8005b52:	7282      	strb	r2, [r0, #10]
    ep->pmaaddr0 =  pmaadress & 0xFFFF;
    ep->pmaaddr1 =  (pmaadress & 0xFFFF0000) >> 16;
  }
  
  return HAL_OK; 
}
 8005b54:	2000      	movs	r0, #0
 8005b56:	4770      	bx	lr
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8005b58:	eb00 1041 	add.w	r0, r0, r1, lsl #5
 8005b5c:	f500 7002 	add.w	r0, r0, #520	; 0x208
  }
  
  /* Here we check if the endpoint is single or double Buffer*/
  if (ep_kind == PCD_SNG_BUF)
 8005b60:	2a00      	cmp	r2, #0
 8005b62:	d1f2      	bne.n	8005b4a <HAL_PCDEx_PMAConfig+0x12>
  {
    /*Single Buffer*/
    ep->doublebuffer = 0;
 8005b64:	7282      	strb	r2, [r0, #10]
    /*Configure te PMA*/
    ep->pmaadress = (uint16_t)pmaadress;
 8005b66:	8083      	strh	r3, [r0, #4]
    ep->pmaaddr0 =  pmaadress & 0xFFFF;
    ep->pmaaddr1 =  (pmaadress & 0xFFFF0000) >> 16;
  }
  
  return HAL_OK; 
}
 8005b68:	2000      	movs	r0, #0
 8005b6a:	4770      	bx	lr

08005b6c <CDC_DeInit_FS>:
static int8_t CDC_DeInit_FS(void)
{
  /* USER CODE BEGIN 4 */ 
  return (USBD_OK);
  /* USER CODE END 4 */ 
}
 8005b6c:	2000      	movs	r0, #0
 8005b6e:	4770      	bx	lr

08005b70 <CDC_Control_FS>:
    break;
  }

  return (USBD_OK);
  /* USER CODE END 5 */
}
 8005b70:	2000      	movs	r0, #0
 8005b72:	4770      	bx	lr

08005b74 <CDC_Init_FS>:
  *         Initializes the CDC media low layer over the FS USB IP
  * @param  None
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Init_FS(void)
{
 8005b74:	b510      	push	{r4, lr}
  hUsbDevice_0 = &hUsbDeviceFS;
 8005b76:	4b07      	ldr	r3, [pc, #28]	; (8005b94 <CDC_Init_FS+0x20>)
 8005b78:	4c07      	ldr	r4, [pc, #28]	; (8005b98 <CDC_Init_FS+0x24>)
  /* USER CODE BEGIN 3 */ 
  /* Set Application Buffers */
  USBD_CDC_SetTxBuffer(hUsbDevice_0, UserTxBufferFS, 0);
 8005b7a:	4618      	mov	r0, r3
 8005b7c:	2200      	movs	r2, #0
 8005b7e:	4907      	ldr	r1, [pc, #28]	; (8005b9c <CDC_Init_FS+0x28>)
  * @param  None
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Init_FS(void)
{
  hUsbDevice_0 = &hUsbDeviceFS;
 8005b80:	6023      	str	r3, [r4, #0]
  /* USER CODE BEGIN 3 */ 
  /* Set Application Buffers */
  USBD_CDC_SetTxBuffer(hUsbDevice_0, UserTxBufferFS, 0);
 8005b82:	f7ff f86b 	bl	8004c5c <USBD_CDC_SetTxBuffer>
  USBD_CDC_SetRxBuffer(hUsbDevice_0, UserRxBufferFS);
 8005b86:	6820      	ldr	r0, [r4, #0]
 8005b88:	4905      	ldr	r1, [pc, #20]	; (8005ba0 <CDC_Init_FS+0x2c>)
 8005b8a:	f7ff f86f 	bl	8004c6c <USBD_CDC_SetRxBuffer>
  return (USBD_OK);
  /* USER CODE END 3 */ 
}
 8005b8e:	2000      	movs	r0, #0
 8005b90:	bd10      	pop	{r4, pc}
 8005b92:	bf00      	nop
 8005b94:	200025f0 	.word	0x200025f0
 8005b98:	200024ec 	.word	0x200024ec
 8005b9c:	20002570 	.word	0x20002570
 8005ba0:	200024f0 	.word	0x200024f0

08005ba4 <CDC_Receive_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Receive_FS (uint8_t* Buf, uint32_t *Len)
{
 8005ba4:	b538      	push	{r3, r4, r5, lr}
  /* USER CODE BEGIN 6 */
  for (int i = 0; i < *Len; i++)
 8005ba6:	680b      	ldr	r3, [r1, #0]
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Receive_FS (uint8_t* Buf, uint32_t *Len)
{
 8005ba8:	4605      	mov	r5, r0
  /* USER CODE BEGIN 6 */
  for (int i = 0; i < *Len; i++)
 8005baa:	b1e3      	cbz	r3, 8005be6 <CDC_Receive_FS+0x42>
 8005bac:	4c0f      	ldr	r4, [pc, #60]	; (8005bec <CDC_Receive_FS+0x48>)
 8005bae:	4810      	ldr	r0, [pc, #64]	; (8005bf0 <CDC_Receive_FS+0x4c>)
 8005bb0:	2300      	movs	r3, #0
  UserTxBufferFS[i] = UserRxBufferFS[i];
 8005bb2:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Receive_FS (uint8_t* Buf, uint32_t *Len)
{
  /* USER CODE BEGIN 6 */
  for (int i = 0; i < *Len; i++)
 8005bb6:	3301      	adds	r3, #1
  UserTxBufferFS[i] = UserRxBufferFS[i];
 8005bb8:	f800 2f01 	strb.w	r2, [r0, #1]!
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Receive_FS (uint8_t* Buf, uint32_t *Len)
{
  /* USER CODE BEGIN 6 */
  for (int i = 0; i < *Len; i++)
 8005bbc:	680a      	ldr	r2, [r1, #0]
 8005bbe:	429a      	cmp	r2, r3
 8005bc0:	d8f7      	bhi.n	8005bb2 <CDC_Receive_FS+0xe>
 8005bc2:	b292      	uxth	r2, r2
  UserTxBufferFS[i] = UserRxBufferFS[i];
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, &UserTxBufferFS[0], *Len);
 8005bc4:	490b      	ldr	r1, [pc, #44]	; (8005bf4 <CDC_Receive_FS+0x50>)
  USBD_CDC_TransmitPacket(&hUsbDeviceFS);

  USBD_CDC_SetRxBuffer(hUsbDevice_0, &Buf[0]);
 8005bc6:	4c0c      	ldr	r4, [pc, #48]	; (8005bf8 <CDC_Receive_FS+0x54>)
static int8_t CDC_Receive_FS (uint8_t* Buf, uint32_t *Len)
{
  /* USER CODE BEGIN 6 */
  for (int i = 0; i < *Len; i++)
  UserTxBufferFS[i] = UserRxBufferFS[i];
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, &UserTxBufferFS[0], *Len);
 8005bc8:	480c      	ldr	r0, [pc, #48]	; (8005bfc <CDC_Receive_FS+0x58>)
 8005bca:	f7ff f847 	bl	8004c5c <USBD_CDC_SetTxBuffer>
  USBD_CDC_TransmitPacket(&hUsbDeviceFS);
 8005bce:	480b      	ldr	r0, [pc, #44]	; (8005bfc <CDC_Receive_FS+0x58>)
 8005bd0:	f7ff f852 	bl	8004c78 <USBD_CDC_TransmitPacket>

  USBD_CDC_SetRxBuffer(hUsbDevice_0, &Buf[0]);
 8005bd4:	4629      	mov	r1, r5
 8005bd6:	6820      	ldr	r0, [r4, #0]
 8005bd8:	f7ff f848 	bl	8004c6c <USBD_CDC_SetRxBuffer>
  USBD_CDC_ReceivePacket(hUsbDevice_0);
 8005bdc:	6820      	ldr	r0, [r4, #0]
 8005bde:	f7ff f863 	bl	8004ca8 <USBD_CDC_ReceivePacket>
  return (USBD_OK);
  /* USER CODE END 6 */ 
}
 8005be2:	2000      	movs	r0, #0
 8005be4:	bd38      	pop	{r3, r4, r5, pc}
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Receive_FS (uint8_t* Buf, uint32_t *Len)
{
  /* USER CODE BEGIN 6 */
  for (int i = 0; i < *Len; i++)
 8005be6:	461a      	mov	r2, r3
 8005be8:	e7ec      	b.n	8005bc4 <CDC_Receive_FS+0x20>
 8005bea:	bf00      	nop
 8005bec:	200024ef 	.word	0x200024ef
 8005bf0:	2000256f 	.word	0x2000256f
 8005bf4:	20002570 	.word	0x20002570
 8005bf8:	200024ec 	.word	0x200024ec
 8005bfc:	200025f0 	.word	0x200025f0

08005c00 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8005c00:	b510      	push	{r4, lr}
 8005c02:	4604      	mov	r4, r0
void *pvReturn = NULL;
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 8005c04:	0743      	lsls	r3, r0, #29
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8005c06:	bf1c      	itt	ne
 8005c08:	f020 0407 	bicne.w	r4, r0, #7
 8005c0c:	3408      	addne	r4, #8
		}
	#endif

	vTaskSuspendAll();
 8005c0e:	f7fd fa0d 	bl	800302c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 8005c12:	4a10      	ldr	r2, [pc, #64]	; (8005c54 <pvPortMalloc+0x54>)
 8005c14:	6813      	ldr	r3, [r2, #0]
 8005c16:	b1b3      	cbz	r3, 8005c46 <pvPortMalloc+0x46>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 8005c18:	f640 70f7 	movw	r0, #4087	; 0xff7
 8005c1c:	490e      	ldr	r1, [pc, #56]	; (8005c58 <pvPortMalloc+0x58>)
 8005c1e:	f851 3cf4 	ldr.w	r3, [r1, #-244]
 8005c22:	441c      	add	r4, r3
 8005c24:	4284      	cmp	r4, r0
 8005c26:	d809      	bhi.n	8005c3c <pvPortMalloc+0x3c>
 8005c28:	42a3      	cmp	r3, r4
 8005c2a:	d207      	bcs.n	8005c3c <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 8005c2c:	6812      	ldr	r2, [r2, #0]
			xNextFreeByte += xWantedSize;
 8005c2e:	f841 4cf4 	str.w	r4, [r1, #-244]
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 8005c32:	18d4      	adds	r4, r2, r3
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 8005c34:	f7fd fa9c 	bl	8003170 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 8005c38:	4620      	mov	r0, r4
 8005c3a:	bd10      	pop	{r4, pc}

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 8005c3c:	2400      	movs	r4, #0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 8005c3e:	f7fd fa97 	bl	8003170 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 8005c42:	4620      	mov	r0, r4
 8005c44:	bd10      	pop	{r4, pc}
	vTaskSuspendAll();
	{
		if( pucAlignedHeap == NULL )
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 8005c46:	f102 030c 	add.w	r3, r2, #12
 8005c4a:	f023 0307 	bic.w	r3, r3, #7
 8005c4e:	6013      	str	r3, [r2, #0]
 8005c50:	e7e2      	b.n	8005c18 <pvPortMalloc+0x18>
 8005c52:	bf00      	nop
 8005c54:	20000cf4 	.word	0x20000cf4
 8005c58:	20001dec 	.word	0x20001dec

08005c5c <vPortFree>:
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
 8005c5c:	b118      	cbz	r0, 8005c66 <vPortFree+0xa>
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 8005c5e:	b508      	push	{r3, lr}
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
 8005c60:	f7fe fe10 	bl	8004884 <ulPortSetInterruptMask>
 8005c64:	e7fe      	b.n	8005c64 <vPortFree+0x8>
 8005c66:	4770      	bx	lr

08005c68 <USBD_CtlSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 8005c68:	b538      	push	{r3, r4, r5, lr}
 8005c6a:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
 8005c6c:	2502      	movs	r5, #2
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 8005c6e:	460a      	mov	r2, r1
                               uint8_t *pbuf,
                               uint16_t len)
{
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
  pdev->ep_in[0].total_length = len;
 8005c70:	6183      	str	r3, [r0, #24]
  pdev->ep_in[0].rem_length   = len;
 8005c72:	61c3      	str	r3, [r0, #28]
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
 8005c74:	f8c0 51f4 	str.w	r5, [r0, #500]	; 0x1f4
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 8005c78:	2100      	movs	r1, #0
 8005c7a:	f7fe f917 	bl	8003eac <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8005c7e:	2000      	movs	r0, #0
 8005c80:	bd38      	pop	{r3, r4, r5, pc}
 8005c82:	bf00      	nop

08005c84 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 8005c84:	b508      	push	{r3, lr}
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);   
 8005c86:	4613      	mov	r3, r2
 8005c88:	460a      	mov	r2, r1
 8005c8a:	2100      	movs	r1, #0
 8005c8c:	f7fe f90e 	bl	8003eac <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8005c90:	2000      	movs	r0, #0
 8005c92:	bd08      	pop	{r3, pc}

08005c94 <USBD_CtlPrepareRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlPrepareRx (USBD_HandleTypeDef  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
 8005c94:	b538      	push	{r3, r4, r5, lr}
 8005c96:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT; 
 8005c98:	2503      	movs	r5, #3
  pdev->ep_out[0].total_length = len;
  pdev->ep_out[0].rem_length   = len;
  /* Start the transfer */
  USBD_LL_PrepareReceive (pdev,
 8005c9a:	460a      	mov	r2, r1
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT; 
  pdev->ep_out[0].total_length = len;
 8005c9c:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
  pdev->ep_out[0].rem_length   = len;
 8005ca0:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
USBD_StatusTypeDef  USBD_CtlPrepareRx (USBD_HandleTypeDef  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT; 
 8005ca4:	f8c0 51f4 	str.w	r5, [r0, #500]	; 0x1f4
  pdev->ep_out[0].total_length = len;
  pdev->ep_out[0].rem_length   = len;
  /* Start the transfer */
  USBD_LL_PrepareReceive (pdev,
 8005ca8:	2100      	movs	r1, #0
 8005caa:	f7fe f907 	bl	8003ebc <USBD_LL_PrepareReceive>
                          0,
                          pbuf,
                         len);
  
  return USBD_OK;
}
 8005cae:	2000      	movs	r0, #0
 8005cb0:	bd38      	pop	{r3, r4, r5, pc}
 8005cb2:	bf00      	nop

08005cb4 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 8005cb4:	b508      	push	{r3, lr}

  USBD_LL_PrepareReceive (pdev,
 8005cb6:	4613      	mov	r3, r2
 8005cb8:	460a      	mov	r2, r1
 8005cba:	2100      	movs	r1, #0
 8005cbc:	f7fe f8fe 	bl	8003ebc <USBD_LL_PrepareReceive>
                          0,                     
                          pbuf,                         
                          len);
  return USBD_OK;
}
 8005cc0:	2000      	movs	r0, #0
 8005cc2:	bd08      	pop	{r3, pc}

08005cc4 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{
 8005cc4:	b508      	push	{r3, lr}

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8005cc6:	2204      	movs	r2, #4
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
 8005cc8:	2300      	movs	r3, #0
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8005cca:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
 8005cce:	4619      	mov	r1, r3
 8005cd0:	461a      	mov	r2, r3
 8005cd2:	f7fe f8eb 	bl	8003eac <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8005cd6:	2000      	movs	r0, #0
 8005cd8:	bd08      	pop	{r3, pc}
 8005cda:	bf00      	nop

08005cdc <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
 8005cdc:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
 8005cde:	2205      	movs	r2, #5
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
 8005ce0:	2300      	movs	r3, #0
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
 8005ce2:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
 8005ce6:	4619      	mov	r1, r3
 8005ce8:	461a      	mov	r2, r3
 8005cea:	f7fe f8e7 	bl	8003ebc <USBD_LL_PrepareReceive>
                    0,
                    NULL,
                    0);  

  return USBD_OK;
}
 8005cee:	2000      	movs	r0, #0
 8005cf0:	bd08      	pop	{r3, pc}
 8005cf2:	bf00      	nop

08005cf4 <MX_USB_DEVICE_Init>:
/* USB Device Core handle declaration */
USBD_HandleTypeDef hUsbDeviceFS;

/* init function */				        
void MX_USB_DEVICE_Init(void)
{
 8005cf4:	b510      	push	{r4, lr}
  /* Init Device Library,Add Supported Class and Start the library*/
  USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS);
 8005cf6:	4c09      	ldr	r4, [pc, #36]	; (8005d1c <MX_USB_DEVICE_Init+0x28>)
 8005cf8:	2200      	movs	r2, #0
 8005cfa:	4620      	mov	r0, r4
 8005cfc:	4908      	ldr	r1, [pc, #32]	; (8005d20 <MX_USB_DEVICE_Init+0x2c>)
 8005cfe:	f7fb fedb 	bl	8001ab8 <USBD_Init>

  USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC);
 8005d02:	4620      	mov	r0, r4
 8005d04:	4907      	ldr	r1, [pc, #28]	; (8005d24 <MX_USB_DEVICE_Init+0x30>)
 8005d06:	f7fb feed 	bl	8001ae4 <USBD_RegisterClass>

  USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS);
 8005d0a:	4620      	mov	r0, r4
 8005d0c:	4906      	ldr	r1, [pc, #24]	; (8005d28 <MX_USB_DEVICE_Init+0x34>)
 8005d0e:	f7fe ff9d 	bl	8004c4c <USBD_CDC_RegisterInterface>

  USBD_Start(&hUsbDeviceFS);
 8005d12:	4620      	mov	r0, r4

}
 8005d14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC);

  USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS);

  USBD_Start(&hUsbDeviceFS);
 8005d18:	f7fb beec 	b.w	8001af4 <USBD_Start>
 8005d1c:	200025f0 	.word	0x200025f0
 8005d20:	20000454 	.word	0x20000454
 8005d24:	2000054c 	.word	0x2000054c
 8005d28:	20000584 	.word	0x20000584

08005d2c <HAL_TIMEx_MasterConfigSynchronization>:
  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  __HAL_LOCK(htim);
 8005d2c:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8005d30:	2b01      	cmp	r3, #1
 8005d32:	d01e      	beq.n	8005d72 <HAL_TIMEx_MasterConfigSynchronization+0x46>
 8005d34:	4602      	mov	r2, r0

  htim->State = HAL_TIM_STATE_BUSY;
 8005d36:	2002      	movs	r0, #2

  /* Reset the MMS Bits */
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 8005d38:	6813      	ldr	r3, [r2, #0]
  *         contains the selected trigger output (TRGO) and the Master/Slave
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)
{
 8005d3a:	b430      	push	{r4, r5}
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  __HAL_LOCK(htim);

  htim->State = HAL_TIM_STATE_BUSY;
 8005d3c:	f882 0039 	strb.w	r0, [r2, #57]	; 0x39

  /* Reset the MMS Bits */
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 8005d40:	685c      	ldr	r4, [r3, #4]
  /* Select the TRGO source */
  htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;
 8005d42:	6808      	ldr	r0, [r1, #0]
  __HAL_LOCK(htim);

  htim->State = HAL_TIM_STATE_BUSY;

  /* Reset the MMS Bits */
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 8005d44:	f024 0470 	bic.w	r4, r4, #112	; 0x70
 8005d48:	605c      	str	r4, [r3, #4]
  /* Select the TRGO source */
  htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;
 8005d4a:	685c      	ldr	r4, [r3, #4]

  /* Reset the MSM Bit */
  htim->Instance->SMCR &= ~TIM_SMCR_MSM;
  /* Set or Reset the MSM Bit */
  htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
 8005d4c:	6849      	ldr	r1, [r1, #4]
  htim->State = HAL_TIM_STATE_BUSY;

  /* Reset the MMS Bits */
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;
 8005d4e:	4320      	orrs	r0, r4
 8005d50:	6058      	str	r0, [r3, #4]

  /* Reset the MSM Bit */
  htim->Instance->SMCR &= ~TIM_SMCR_MSM;
 8005d52:	6898      	ldr	r0, [r3, #8]
  /* Set or Reset the MSM Bit */
  htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;

  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);
 8005d54:	2400      	movs	r4, #0
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;

  /* Reset the MSM Bit */
  htim->Instance->SMCR &= ~TIM_SMCR_MSM;
 8005d56:	f020 0080 	bic.w	r0, r0, #128	; 0x80
 8005d5a:	6098      	str	r0, [r3, #8]
  /* Set or Reset the MSM Bit */
  htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
 8005d5c:	6898      	ldr	r0, [r3, #8]

  htim->State = HAL_TIM_STATE_READY;
 8005d5e:	2501      	movs	r5, #1
  htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;

  /* Reset the MSM Bit */
  htim->Instance->SMCR &= ~TIM_SMCR_MSM;
  /* Set or Reset the MSM Bit */
  htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
 8005d60:	4301      	orrs	r1, r0
 8005d62:	6099      	str	r1, [r3, #8]

  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);

  return HAL_OK;
 8005d64:	4620      	mov	r0, r4
  /* Reset the MSM Bit */
  htim->Instance->SMCR &= ~TIM_SMCR_MSM;
  /* Set or Reset the MSM Bit */
  htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;

  htim->State = HAL_TIM_STATE_READY;
 8005d66:	f882 5039 	strb.w	r5, [r2, #57]	; 0x39

  __HAL_UNLOCK(htim);
 8005d6a:	f882 4038 	strb.w	r4, [r2, #56]	; 0x38

  return HAL_OK;
}
 8005d6e:	bc30      	pop	{r4, r5}
 8005d70:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  __HAL_LOCK(htim);
 8005d72:	2002      	movs	r0, #2
 8005d74:	4770      	bx	lr
 8005d76:	bf00      	nop

08005d78 <HAL_TIMEx_CommutationCallback>:
 8005d78:	4770      	bx	lr
 8005d7a:	bf00      	nop

08005d7c <HAL_TIMEx_BreakCallback>:
  * @brief  Hall Break detection callback in non blocking mode
  * @param  htim : TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 8005d7c:	4770      	bx	lr
 8005d7e:	bf00      	nop

08005d80 <free>:
 8005d80:	4b02      	ldr	r3, [pc, #8]	; (8005d8c <free+0xc>)
 8005d82:	4601      	mov	r1, r0
 8005d84:	6818      	ldr	r0, [r3, #0]
 8005d86:	f000 b92b 	b.w	8005fe0 <_free_r>
 8005d8a:	bf00      	nop
 8005d8c:	20000008 	.word	0x20000008

08005d90 <memcpy>:
 8005d90:	4684      	mov	ip, r0
 8005d92:	ea41 0300 	orr.w	r3, r1, r0
 8005d96:	f013 0303 	ands.w	r3, r3, #3
 8005d9a:	d149      	bne.n	8005e30 <memcpy+0xa0>
 8005d9c:	3a40      	subs	r2, #64	; 0x40
 8005d9e:	d323      	bcc.n	8005de8 <memcpy+0x58>
 8005da0:	680b      	ldr	r3, [r1, #0]
 8005da2:	6003      	str	r3, [r0, #0]
 8005da4:	684b      	ldr	r3, [r1, #4]
 8005da6:	6043      	str	r3, [r0, #4]
 8005da8:	688b      	ldr	r3, [r1, #8]
 8005daa:	6083      	str	r3, [r0, #8]
 8005dac:	68cb      	ldr	r3, [r1, #12]
 8005dae:	60c3      	str	r3, [r0, #12]
 8005db0:	690b      	ldr	r3, [r1, #16]
 8005db2:	6103      	str	r3, [r0, #16]
 8005db4:	694b      	ldr	r3, [r1, #20]
 8005db6:	6143      	str	r3, [r0, #20]
 8005db8:	698b      	ldr	r3, [r1, #24]
 8005dba:	6183      	str	r3, [r0, #24]
 8005dbc:	69cb      	ldr	r3, [r1, #28]
 8005dbe:	61c3      	str	r3, [r0, #28]
 8005dc0:	6a0b      	ldr	r3, [r1, #32]
 8005dc2:	6203      	str	r3, [r0, #32]
 8005dc4:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8005dc6:	6243      	str	r3, [r0, #36]	; 0x24
 8005dc8:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8005dca:	6283      	str	r3, [r0, #40]	; 0x28
 8005dcc:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 8005dce:	62c3      	str	r3, [r0, #44]	; 0x2c
 8005dd0:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8005dd2:	6303      	str	r3, [r0, #48]	; 0x30
 8005dd4:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 8005dd6:	6343      	str	r3, [r0, #52]	; 0x34
 8005dd8:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 8005dda:	6383      	str	r3, [r0, #56]	; 0x38
 8005ddc:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8005dde:	63c3      	str	r3, [r0, #60]	; 0x3c
 8005de0:	3040      	adds	r0, #64	; 0x40
 8005de2:	3140      	adds	r1, #64	; 0x40
 8005de4:	3a40      	subs	r2, #64	; 0x40
 8005de6:	d2db      	bcs.n	8005da0 <memcpy+0x10>
 8005de8:	3230      	adds	r2, #48	; 0x30
 8005dea:	d30b      	bcc.n	8005e04 <memcpy+0x74>
 8005dec:	680b      	ldr	r3, [r1, #0]
 8005dee:	6003      	str	r3, [r0, #0]
 8005df0:	684b      	ldr	r3, [r1, #4]
 8005df2:	6043      	str	r3, [r0, #4]
 8005df4:	688b      	ldr	r3, [r1, #8]
 8005df6:	6083      	str	r3, [r0, #8]
 8005df8:	68cb      	ldr	r3, [r1, #12]
 8005dfa:	60c3      	str	r3, [r0, #12]
 8005dfc:	3010      	adds	r0, #16
 8005dfe:	3110      	adds	r1, #16
 8005e00:	3a10      	subs	r2, #16
 8005e02:	d2f3      	bcs.n	8005dec <memcpy+0x5c>
 8005e04:	320c      	adds	r2, #12
 8005e06:	d305      	bcc.n	8005e14 <memcpy+0x84>
 8005e08:	f851 3b04 	ldr.w	r3, [r1], #4
 8005e0c:	f840 3b04 	str.w	r3, [r0], #4
 8005e10:	3a04      	subs	r2, #4
 8005e12:	d2f9      	bcs.n	8005e08 <memcpy+0x78>
 8005e14:	3204      	adds	r2, #4
 8005e16:	d008      	beq.n	8005e2a <memcpy+0x9a>
 8005e18:	07d2      	lsls	r2, r2, #31
 8005e1a:	bf1c      	itt	ne
 8005e1c:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8005e20:	f800 3b01 	strbne.w	r3, [r0], #1
 8005e24:	d301      	bcc.n	8005e2a <memcpy+0x9a>
 8005e26:	880b      	ldrh	r3, [r1, #0]
 8005e28:	8003      	strh	r3, [r0, #0]
 8005e2a:	4660      	mov	r0, ip
 8005e2c:	4770      	bx	lr
 8005e2e:	bf00      	nop
 8005e30:	2a08      	cmp	r2, #8
 8005e32:	d313      	bcc.n	8005e5c <memcpy+0xcc>
 8005e34:	078b      	lsls	r3, r1, #30
 8005e36:	d0b1      	beq.n	8005d9c <memcpy+0xc>
 8005e38:	f010 0303 	ands.w	r3, r0, #3
 8005e3c:	d0ae      	beq.n	8005d9c <memcpy+0xc>
 8005e3e:	f1c3 0304 	rsb	r3, r3, #4
 8005e42:	1ad2      	subs	r2, r2, r3
 8005e44:	07db      	lsls	r3, r3, #31
 8005e46:	bf1c      	itt	ne
 8005e48:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8005e4c:	f800 3b01 	strbne.w	r3, [r0], #1
 8005e50:	d3a4      	bcc.n	8005d9c <memcpy+0xc>
 8005e52:	f831 3b02 	ldrh.w	r3, [r1], #2
 8005e56:	f820 3b02 	strh.w	r3, [r0], #2
 8005e5a:	e79f      	b.n	8005d9c <memcpy+0xc>
 8005e5c:	3a04      	subs	r2, #4
 8005e5e:	d3d9      	bcc.n	8005e14 <memcpy+0x84>
 8005e60:	3a01      	subs	r2, #1
 8005e62:	f811 3b01 	ldrb.w	r3, [r1], #1
 8005e66:	f800 3b01 	strb.w	r3, [r0], #1
 8005e6a:	d2f9      	bcs.n	8005e60 <memcpy+0xd0>
 8005e6c:	780b      	ldrb	r3, [r1, #0]
 8005e6e:	7003      	strb	r3, [r0, #0]
 8005e70:	784b      	ldrb	r3, [r1, #1]
 8005e72:	7043      	strb	r3, [r0, #1]
 8005e74:	788b      	ldrb	r3, [r1, #2]
 8005e76:	7083      	strb	r3, [r0, #2]
 8005e78:	4660      	mov	r0, ip
 8005e7a:	4770      	bx	lr

08005e7c <memset>:
 8005e7c:	b470      	push	{r4, r5, r6}
 8005e7e:	0784      	lsls	r4, r0, #30
 8005e80:	d046      	beq.n	8005f10 <memset+0x94>
 8005e82:	1e54      	subs	r4, r2, #1
 8005e84:	2a00      	cmp	r2, #0
 8005e86:	d041      	beq.n	8005f0c <memset+0x90>
 8005e88:	b2cd      	uxtb	r5, r1
 8005e8a:	4603      	mov	r3, r0
 8005e8c:	e002      	b.n	8005e94 <memset+0x18>
 8005e8e:	1e62      	subs	r2, r4, #1
 8005e90:	b3e4      	cbz	r4, 8005f0c <memset+0x90>
 8005e92:	4614      	mov	r4, r2
 8005e94:	f803 5b01 	strb.w	r5, [r3], #1
 8005e98:	079a      	lsls	r2, r3, #30
 8005e9a:	d1f8      	bne.n	8005e8e <memset+0x12>
 8005e9c:	2c03      	cmp	r4, #3
 8005e9e:	d92e      	bls.n	8005efe <memset+0x82>
 8005ea0:	b2cd      	uxtb	r5, r1
 8005ea2:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8005ea6:	2c0f      	cmp	r4, #15
 8005ea8:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8005eac:	d919      	bls.n	8005ee2 <memset+0x66>
 8005eae:	4626      	mov	r6, r4
 8005eb0:	f103 0210 	add.w	r2, r3, #16
 8005eb4:	3e10      	subs	r6, #16
 8005eb6:	2e0f      	cmp	r6, #15
 8005eb8:	f842 5c10 	str.w	r5, [r2, #-16]
 8005ebc:	f842 5c0c 	str.w	r5, [r2, #-12]
 8005ec0:	f842 5c08 	str.w	r5, [r2, #-8]
 8005ec4:	f842 5c04 	str.w	r5, [r2, #-4]
 8005ec8:	f102 0210 	add.w	r2, r2, #16
 8005ecc:	d8f2      	bhi.n	8005eb4 <memset+0x38>
 8005ece:	f1a4 0210 	sub.w	r2, r4, #16
 8005ed2:	f022 020f 	bic.w	r2, r2, #15
 8005ed6:	f004 040f 	and.w	r4, r4, #15
 8005eda:	3210      	adds	r2, #16
 8005edc:	2c03      	cmp	r4, #3
 8005ede:	4413      	add	r3, r2
 8005ee0:	d90d      	bls.n	8005efe <memset+0x82>
 8005ee2:	461e      	mov	r6, r3
 8005ee4:	4622      	mov	r2, r4
 8005ee6:	3a04      	subs	r2, #4
 8005ee8:	2a03      	cmp	r2, #3
 8005eea:	f846 5b04 	str.w	r5, [r6], #4
 8005eee:	d8fa      	bhi.n	8005ee6 <memset+0x6a>
 8005ef0:	1f22      	subs	r2, r4, #4
 8005ef2:	f022 0203 	bic.w	r2, r2, #3
 8005ef6:	3204      	adds	r2, #4
 8005ef8:	4413      	add	r3, r2
 8005efa:	f004 0403 	and.w	r4, r4, #3
 8005efe:	b12c      	cbz	r4, 8005f0c <memset+0x90>
 8005f00:	b2c9      	uxtb	r1, r1
 8005f02:	441c      	add	r4, r3
 8005f04:	f803 1b01 	strb.w	r1, [r3], #1
 8005f08:	42a3      	cmp	r3, r4
 8005f0a:	d1fb      	bne.n	8005f04 <memset+0x88>
 8005f0c:	bc70      	pop	{r4, r5, r6}
 8005f0e:	4770      	bx	lr
 8005f10:	4614      	mov	r4, r2
 8005f12:	4603      	mov	r3, r0
 8005f14:	e7c2      	b.n	8005e9c <memset+0x20>
 8005f16:	bf00      	nop

08005f18 <__malloc_lock>:
 8005f18:	4770      	bx	lr
 8005f1a:	bf00      	nop

08005f1c <__malloc_unlock>:
 8005f1c:	4770      	bx	lr
 8005f1e:	bf00      	nop

08005f20 <_sbrk_r>:
 8005f20:	b538      	push	{r3, r4, r5, lr}
 8005f22:	4c07      	ldr	r4, [pc, #28]	; (8005f40 <_sbrk_r+0x20>)
 8005f24:	2300      	movs	r3, #0
 8005f26:	4605      	mov	r5, r0
 8005f28:	4608      	mov	r0, r1
 8005f2a:	6023      	str	r3, [r4, #0]
 8005f2c:	f7fe f828 	bl	8003f80 <_sbrk>
 8005f30:	1c43      	adds	r3, r0, #1
 8005f32:	d000      	beq.n	8005f36 <_sbrk_r+0x16>
 8005f34:	bd38      	pop	{r3, r4, r5, pc}
 8005f36:	6823      	ldr	r3, [r4, #0]
 8005f38:	2b00      	cmp	r3, #0
 8005f3a:	d0fb      	beq.n	8005f34 <_sbrk_r+0x14>
 8005f3c:	602b      	str	r3, [r5, #0]
 8005f3e:	bd38      	pop	{r3, r4, r5, pc}
 8005f40:	20002814 	.word	0x20002814

08005f44 <_malloc_trim_r>:
 8005f44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005f46:	460c      	mov	r4, r1
 8005f48:	4f22      	ldr	r7, [pc, #136]	; (8005fd4 <_malloc_trim_r+0x90>)
 8005f4a:	4606      	mov	r6, r0
 8005f4c:	f7ff ffe4 	bl	8005f18 <__malloc_lock>
 8005f50:	68bb      	ldr	r3, [r7, #8]
 8005f52:	685d      	ldr	r5, [r3, #4]
 8005f54:	f025 0503 	bic.w	r5, r5, #3
 8005f58:	1b29      	subs	r1, r5, r4
 8005f5a:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
 8005f5e:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
 8005f62:	f021 010f 	bic.w	r1, r1, #15
 8005f66:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
 8005f6a:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 8005f6e:	db07      	blt.n	8005f80 <_malloc_trim_r+0x3c>
 8005f70:	2100      	movs	r1, #0
 8005f72:	4630      	mov	r0, r6
 8005f74:	f7ff ffd4 	bl	8005f20 <_sbrk_r>
 8005f78:	68bb      	ldr	r3, [r7, #8]
 8005f7a:	442b      	add	r3, r5
 8005f7c:	4298      	cmp	r0, r3
 8005f7e:	d004      	beq.n	8005f8a <_malloc_trim_r+0x46>
 8005f80:	4630      	mov	r0, r6
 8005f82:	f7ff ffcb 	bl	8005f1c <__malloc_unlock>
 8005f86:	2000      	movs	r0, #0
 8005f88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005f8a:	4261      	negs	r1, r4
 8005f8c:	4630      	mov	r0, r6
 8005f8e:	f7ff ffc7 	bl	8005f20 <_sbrk_r>
 8005f92:	3001      	adds	r0, #1
 8005f94:	d00d      	beq.n	8005fb2 <_malloc_trim_r+0x6e>
 8005f96:	4b10      	ldr	r3, [pc, #64]	; (8005fd8 <_malloc_trim_r+0x94>)
 8005f98:	68ba      	ldr	r2, [r7, #8]
 8005f9a:	6819      	ldr	r1, [r3, #0]
 8005f9c:	1b2d      	subs	r5, r5, r4
 8005f9e:	f045 0501 	orr.w	r5, r5, #1
 8005fa2:	4630      	mov	r0, r6
 8005fa4:	1b09      	subs	r1, r1, r4
 8005fa6:	6055      	str	r5, [r2, #4]
 8005fa8:	6019      	str	r1, [r3, #0]
 8005faa:	f7ff ffb7 	bl	8005f1c <__malloc_unlock>
 8005fae:	2001      	movs	r0, #1
 8005fb0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005fb2:	2100      	movs	r1, #0
 8005fb4:	4630      	mov	r0, r6
 8005fb6:	f7ff ffb3 	bl	8005f20 <_sbrk_r>
 8005fba:	68ba      	ldr	r2, [r7, #8]
 8005fbc:	1a83      	subs	r3, r0, r2
 8005fbe:	2b0f      	cmp	r3, #15
 8005fc0:	ddde      	ble.n	8005f80 <_malloc_trim_r+0x3c>
 8005fc2:	4c06      	ldr	r4, [pc, #24]	; (8005fdc <_malloc_trim_r+0x98>)
 8005fc4:	4904      	ldr	r1, [pc, #16]	; (8005fd8 <_malloc_trim_r+0x94>)
 8005fc6:	6824      	ldr	r4, [r4, #0]
 8005fc8:	f043 0301 	orr.w	r3, r3, #1
 8005fcc:	1b00      	subs	r0, r0, r4
 8005fce:	6053      	str	r3, [r2, #4]
 8005fd0:	6008      	str	r0, [r1, #0]
 8005fd2:	e7d5      	b.n	8005f80 <_malloc_trim_r+0x3c>
 8005fd4:	20000594 	.word	0x20000594
 8005fd8:	20001d00 	.word	0x20001d00
 8005fdc:	200009a0 	.word	0x200009a0

08005fe0 <_free_r>:
 8005fe0:	2900      	cmp	r1, #0
 8005fe2:	d045      	beq.n	8006070 <_free_r+0x90>
 8005fe4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005fe8:	460d      	mov	r5, r1
 8005fea:	4680      	mov	r8, r0
 8005fec:	f7ff ff94 	bl	8005f18 <__malloc_lock>
 8005ff0:	f855 7c04 	ldr.w	r7, [r5, #-4]
 8005ff4:	496a      	ldr	r1, [pc, #424]	; (80061a0 <_free_r+0x1c0>)
 8005ff6:	f1a5 0408 	sub.w	r4, r5, #8
 8005ffa:	f027 0301 	bic.w	r3, r7, #1
 8005ffe:	18e2      	adds	r2, r4, r3
 8006000:	688e      	ldr	r6, [r1, #8]
 8006002:	6850      	ldr	r0, [r2, #4]
 8006004:	42b2      	cmp	r2, r6
 8006006:	f020 0003 	bic.w	r0, r0, #3
 800600a:	d062      	beq.n	80060d2 <_free_r+0xf2>
 800600c:	07fe      	lsls	r6, r7, #31
 800600e:	6050      	str	r0, [r2, #4]
 8006010:	d40b      	bmi.n	800602a <_free_r+0x4a>
 8006012:	f855 7c08 	ldr.w	r7, [r5, #-8]
 8006016:	f101 0e08 	add.w	lr, r1, #8
 800601a:	1be4      	subs	r4, r4, r7
 800601c:	68a5      	ldr	r5, [r4, #8]
 800601e:	443b      	add	r3, r7
 8006020:	4575      	cmp	r5, lr
 8006022:	d06f      	beq.n	8006104 <_free_r+0x124>
 8006024:	68e7      	ldr	r7, [r4, #12]
 8006026:	60ef      	str	r7, [r5, #12]
 8006028:	60bd      	str	r5, [r7, #8]
 800602a:	1815      	adds	r5, r2, r0
 800602c:	686d      	ldr	r5, [r5, #4]
 800602e:	07ed      	lsls	r5, r5, #31
 8006030:	d542      	bpl.n	80060b8 <_free_r+0xd8>
 8006032:	f043 0201 	orr.w	r2, r3, #1
 8006036:	6062      	str	r2, [r4, #4]
 8006038:	50e3      	str	r3, [r4, r3]
 800603a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800603e:	d218      	bcs.n	8006072 <_free_r+0x92>
 8006040:	08db      	lsrs	r3, r3, #3
 8006042:	6848      	ldr	r0, [r1, #4]
 8006044:	109d      	asrs	r5, r3, #2
 8006046:	2201      	movs	r2, #1
 8006048:	3301      	adds	r3, #1
 800604a:	f851 7033 	ldr.w	r7, [r1, r3, lsl #3]
 800604e:	fa02 f505 	lsl.w	r5, r2, r5
 8006052:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
 8006056:	4328      	orrs	r0, r5
 8006058:	3a08      	subs	r2, #8
 800605a:	60e2      	str	r2, [r4, #12]
 800605c:	60a7      	str	r7, [r4, #8]
 800605e:	6048      	str	r0, [r1, #4]
 8006060:	f841 4033 	str.w	r4, [r1, r3, lsl #3]
 8006064:	60fc      	str	r4, [r7, #12]
 8006066:	4640      	mov	r0, r8
 8006068:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800606c:	f7ff bf56 	b.w	8005f1c <__malloc_unlock>
 8006070:	4770      	bx	lr
 8006072:	0a5a      	lsrs	r2, r3, #9
 8006074:	2a04      	cmp	r2, #4
 8006076:	d853      	bhi.n	8006120 <_free_r+0x140>
 8006078:	099a      	lsrs	r2, r3, #6
 800607a:	f102 0739 	add.w	r7, r2, #57	; 0x39
 800607e:	007f      	lsls	r7, r7, #1
 8006080:	f102 0538 	add.w	r5, r2, #56	; 0x38
 8006084:	eb01 0087 	add.w	r0, r1, r7, lsl #2
 8006088:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
 800608c:	3808      	subs	r0, #8
 800608e:	4290      	cmp	r0, r2
 8006090:	4943      	ldr	r1, [pc, #268]	; (80061a0 <_free_r+0x1c0>)
 8006092:	d04d      	beq.n	8006130 <_free_r+0x150>
 8006094:	6851      	ldr	r1, [r2, #4]
 8006096:	f021 0103 	bic.w	r1, r1, #3
 800609a:	428b      	cmp	r3, r1
 800609c:	d202      	bcs.n	80060a4 <_free_r+0xc4>
 800609e:	6892      	ldr	r2, [r2, #8]
 80060a0:	4290      	cmp	r0, r2
 80060a2:	d1f7      	bne.n	8006094 <_free_r+0xb4>
 80060a4:	68d0      	ldr	r0, [r2, #12]
 80060a6:	60e0      	str	r0, [r4, #12]
 80060a8:	60a2      	str	r2, [r4, #8]
 80060aa:	6084      	str	r4, [r0, #8]
 80060ac:	60d4      	str	r4, [r2, #12]
 80060ae:	4640      	mov	r0, r8
 80060b0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80060b4:	f7ff bf32 	b.w	8005f1c <__malloc_unlock>
 80060b8:	6895      	ldr	r5, [r2, #8]
 80060ba:	4f3a      	ldr	r7, [pc, #232]	; (80061a4 <_free_r+0x1c4>)
 80060bc:	4403      	add	r3, r0
 80060be:	42bd      	cmp	r5, r7
 80060c0:	d03f      	beq.n	8006142 <_free_r+0x162>
 80060c2:	68d0      	ldr	r0, [r2, #12]
 80060c4:	f043 0201 	orr.w	r2, r3, #1
 80060c8:	60e8      	str	r0, [r5, #12]
 80060ca:	6085      	str	r5, [r0, #8]
 80060cc:	6062      	str	r2, [r4, #4]
 80060ce:	50e3      	str	r3, [r4, r3]
 80060d0:	e7b3      	b.n	800603a <_free_r+0x5a>
 80060d2:	07ff      	lsls	r7, r7, #31
 80060d4:	4403      	add	r3, r0
 80060d6:	d407      	bmi.n	80060e8 <_free_r+0x108>
 80060d8:	f855 5c08 	ldr.w	r5, [r5, #-8]
 80060dc:	1b64      	subs	r4, r4, r5
 80060de:	68e2      	ldr	r2, [r4, #12]
 80060e0:	68a0      	ldr	r0, [r4, #8]
 80060e2:	442b      	add	r3, r5
 80060e4:	60c2      	str	r2, [r0, #12]
 80060e6:	6090      	str	r0, [r2, #8]
 80060e8:	4a2f      	ldr	r2, [pc, #188]	; (80061a8 <_free_r+0x1c8>)
 80060ea:	f043 0001 	orr.w	r0, r3, #1
 80060ee:	6812      	ldr	r2, [r2, #0]
 80060f0:	6060      	str	r0, [r4, #4]
 80060f2:	4293      	cmp	r3, r2
 80060f4:	608c      	str	r4, [r1, #8]
 80060f6:	d3b6      	bcc.n	8006066 <_free_r+0x86>
 80060f8:	4b2c      	ldr	r3, [pc, #176]	; (80061ac <_free_r+0x1cc>)
 80060fa:	4640      	mov	r0, r8
 80060fc:	6819      	ldr	r1, [r3, #0]
 80060fe:	f7ff ff21 	bl	8005f44 <_malloc_trim_r>
 8006102:	e7b0      	b.n	8006066 <_free_r+0x86>
 8006104:	1811      	adds	r1, r2, r0
 8006106:	6849      	ldr	r1, [r1, #4]
 8006108:	07c9      	lsls	r1, r1, #31
 800610a:	d444      	bmi.n	8006196 <_free_r+0x1b6>
 800610c:	6891      	ldr	r1, [r2, #8]
 800610e:	4403      	add	r3, r0
 8006110:	68d2      	ldr	r2, [r2, #12]
 8006112:	f043 0001 	orr.w	r0, r3, #1
 8006116:	60ca      	str	r2, [r1, #12]
 8006118:	6091      	str	r1, [r2, #8]
 800611a:	6060      	str	r0, [r4, #4]
 800611c:	50e3      	str	r3, [r4, r3]
 800611e:	e7a2      	b.n	8006066 <_free_r+0x86>
 8006120:	2a14      	cmp	r2, #20
 8006122:	d817      	bhi.n	8006154 <_free_r+0x174>
 8006124:	f102 075c 	add.w	r7, r2, #92	; 0x5c
 8006128:	007f      	lsls	r7, r7, #1
 800612a:	f102 055b 	add.w	r5, r2, #91	; 0x5b
 800612e:	e7a9      	b.n	8006084 <_free_r+0xa4>
 8006130:	10aa      	asrs	r2, r5, #2
 8006132:	684b      	ldr	r3, [r1, #4]
 8006134:	2501      	movs	r5, #1
 8006136:	fa05 f202 	lsl.w	r2, r5, r2
 800613a:	4313      	orrs	r3, r2
 800613c:	604b      	str	r3, [r1, #4]
 800613e:	4602      	mov	r2, r0
 8006140:	e7b1      	b.n	80060a6 <_free_r+0xc6>
 8006142:	f043 0201 	orr.w	r2, r3, #1
 8006146:	614c      	str	r4, [r1, #20]
 8006148:	610c      	str	r4, [r1, #16]
 800614a:	60e5      	str	r5, [r4, #12]
 800614c:	60a5      	str	r5, [r4, #8]
 800614e:	6062      	str	r2, [r4, #4]
 8006150:	50e3      	str	r3, [r4, r3]
 8006152:	e788      	b.n	8006066 <_free_r+0x86>
 8006154:	2a54      	cmp	r2, #84	; 0x54
 8006156:	d806      	bhi.n	8006166 <_free_r+0x186>
 8006158:	0b1a      	lsrs	r2, r3, #12
 800615a:	f102 076f 	add.w	r7, r2, #111	; 0x6f
 800615e:	007f      	lsls	r7, r7, #1
 8006160:	f102 056e 	add.w	r5, r2, #110	; 0x6e
 8006164:	e78e      	b.n	8006084 <_free_r+0xa4>
 8006166:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 800616a:	d806      	bhi.n	800617a <_free_r+0x19a>
 800616c:	0bda      	lsrs	r2, r3, #15
 800616e:	f102 0778 	add.w	r7, r2, #120	; 0x78
 8006172:	007f      	lsls	r7, r7, #1
 8006174:	f102 0577 	add.w	r5, r2, #119	; 0x77
 8006178:	e784      	b.n	8006084 <_free_r+0xa4>
 800617a:	f240 5054 	movw	r0, #1364	; 0x554
 800617e:	4282      	cmp	r2, r0
 8006180:	d806      	bhi.n	8006190 <_free_r+0x1b0>
 8006182:	0c9a      	lsrs	r2, r3, #18
 8006184:	f102 077d 	add.w	r7, r2, #125	; 0x7d
 8006188:	007f      	lsls	r7, r7, #1
 800618a:	f102 057c 	add.w	r5, r2, #124	; 0x7c
 800618e:	e779      	b.n	8006084 <_free_r+0xa4>
 8006190:	27fe      	movs	r7, #254	; 0xfe
 8006192:	257e      	movs	r5, #126	; 0x7e
 8006194:	e776      	b.n	8006084 <_free_r+0xa4>
 8006196:	f043 0201 	orr.w	r2, r3, #1
 800619a:	6062      	str	r2, [r4, #4]
 800619c:	50e3      	str	r3, [r4, r3]
 800619e:	e762      	b.n	8006066 <_free_r+0x86>
 80061a0:	20000594 	.word	0x20000594
 80061a4:	2000059c 	.word	0x2000059c
 80061a8:	2000099c 	.word	0x2000099c
 80061ac:	20001cfc 	.word	0x20001cfc
 80061b0:	05040302 	.word	0x05040302
 80061b4:	09080706 	.word	0x09080706
 80061b8:	0d0c0b0a 	.word	0x0d0c0b0a
 80061bc:	10100f0e 	.word	0x10100f0e
 80061c0:	00000201 	.word	0x00000201
 80061c4:	05040302 	.word	0x05040302
 80061c8:	09080706 	.word	0x09080706
 80061cc:	0d0c0b0a 	.word	0x0d0c0b0a
 80061d0:	10100f0e 	.word	0x10100f0e
 80061d4:	00000201 	.word	0x00000201

080061d8 <aAPBAHBPrescTable>:
 80061d8:	00000000 04030201 04030201 09080706     ................
 80061e8:	0800626c 08001d1d 00000000 00000000     lb..............
 80061f8:	00000080 0800625c 08001d45 00000000     ....\b..E.......
 8006208:	00000000 00000040 08006250 08001d39     ....@...Pb..9...
	...
 8006220:	00000040 08006240 08001d2d 00000000     @...@b..-.......
 8006230:	00000000 00000040 00000080 00000001     ....@...........
 8006240:	6b736154 57627355 65746972 00000000     TaskUsbWrite....
 8006250:	6b736154 52627355 00646165 6b736154     TaskUsbRead.Task
 8006260:	4664654c 6873616c 00000000 61666564     LedFlash....defa
 8006270:	54746c75 006b7361 51726d54 00000000     ultTask.TmrQ....
 8006280:	20726d54 00637653 454c4449 00000000     Tmr Svc.IDLE....
 8006290:	694d5453 656f7263 7463656c 696e6f72     STMicroelectroni
 80062a0:	00007363 334d5453 69562032 61757472     cs..STM32 Virtua
 80062b0:	6f43206c 726f506d 00000074 30303030     l ComPort...0000
 80062c0:	30303030 41313030 00000000 20434443     0000001A....CDC 
 80062d0:	666e6f43 00006769 20434443 65746e49     Config..CDC Inte
 80062e0:	63616672 00000065                       rface...
